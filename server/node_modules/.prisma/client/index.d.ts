
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model GmailConnection
 * 
 */
export type GmailConnection = $Result.DefaultSelection<Prisma.$GmailConnectionPayload>
/**
 * Model Profile
 * 
 */
export type Profile = $Result.DefaultSelection<Prisma.$ProfilePayload>
/**
 * Model Job
 * 
 */
export type Job = $Result.DefaultSelection<Prisma.$JobPayload>
/**
 * Model Artifact
 * 
 */
export type Artifact = $Result.DefaultSelection<Prisma.$ArtifactPayload>
/**
 * Model Embedding
 * 
 */
export type Embedding = $Result.DefaultSelection<Prisma.$EmbeddingPayload>
/**
 * Model Subscription
 * 
 */
export type Subscription = $Result.DefaultSelection<Prisma.$SubscriptionPayload>
/**
 * Model UsageTracking
 * 
 */
export type UsageTracking = $Result.DefaultSelection<Prisma.$UsageTrackingPayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model AggregatedJob
 * 
 */
export type AggregatedJob = $Result.DefaultSelection<Prisma.$AggregatedJobPayload>
/**
 * Model AutoApplication
 * 
 */
export type AutoApplication = $Result.DefaultSelection<Prisma.$AutoApplicationPayload>
/**
 * Model ApplicationRecipe
 * 
 */
export type ApplicationRecipe = $Result.DefaultSelection<Prisma.$ApplicationRecipePayload>
/**
 * Model RecipeExecution
 * 
 */
export type RecipeExecution = $Result.DefaultSelection<Prisma.$RecipeExecutionPayload>
/**
 * Model DiscoveredCompany
 * 
 */
export type DiscoveredCompany = $Result.DefaultSelection<Prisma.$DiscoveredCompanyPayload>
/**
 * Model Conversation
 * 
 */
export type Conversation = $Result.DefaultSelection<Prisma.$ConversationPayload>
/**
 * Model Message
 * 
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>
/**
 * Model Goal
 * 
 */
export type Goal = $Result.DefaultSelection<Prisma.$GoalPayload>
/**
 * Model MessageUsage
 * 
 */
export type MessageUsage = $Result.DefaultSelection<Prisma.$MessageUsagePayload>
/**
 * Model Routine
 * 
 */
export type Routine = $Result.DefaultSelection<Prisma.$RoutinePayload>
/**
 * Model RoutineExecution
 * 
 */
export type RoutineExecution = $Result.DefaultSelection<Prisma.$RoutineExecutionPayload>
/**
 * Model Worker
 * 
 */
export type Worker = $Result.DefaultSelection<Prisma.$WorkerPayload>
/**
 * Model WorkerSession
 * 
 */
export type WorkerSession = $Result.DefaultSelection<Prisma.$WorkerSessionPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const JobStatus: {
  PENDING: 'PENDING',
  PROCESSING: 'PROCESSING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  RETRYING: 'RETRYING'
};

export type JobStatus = (typeof JobStatus)[keyof typeof JobStatus]


export const ArtifactType: {
  RESUME_JSON: 'RESUME_JSON',
  LATEX_SOURCE: 'LATEX_SOURCE',
  PDF_OUTPUT: 'PDF_OUTPUT',
  JOB_DESCRIPTION: 'JOB_DESCRIPTION',
  DIAGNOSTIC_LOG: 'DIAGNOSTIC_LOG'
};

export type ArtifactType = (typeof ArtifactType)[keyof typeof ArtifactType]


export const EmbeddingType: {
  SKILL: 'SKILL',
  EXPERIENCE: 'EXPERIENCE',
  REQUIREMENT: 'REQUIREMENT',
  KEYWORD: 'KEYWORD'
};

export type EmbeddingType = (typeof EmbeddingType)[keyof typeof EmbeddingType]


export const SubscriptionTier: {
  FREE: 'FREE',
  PRO: 'PRO',
  UNLIMITED: 'UNLIMITED'
};

export type SubscriptionTier = (typeof SubscriptionTier)[keyof typeof SubscriptionTier]


export const SubscriptionStatus: {
  ACTIVE: 'ACTIVE',
  CANCELED: 'CANCELED',
  PAST_DUE: 'PAST_DUE',
  PAUSED: 'PAUSED',
  INCOMPLETE: 'INCOMPLETE'
};

export type SubscriptionStatus = (typeof SubscriptionStatus)[keyof typeof SubscriptionStatus]


export const PaymentStatus: {
  PENDING: 'PENDING',
  SUCCEEDED: 'SUCCEEDED',
  FAILED: 'FAILED',
  REFUNDED: 'REFUNDED'
};

export type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus]


export const AutoApplicationStatus: {
  QUEUED: 'QUEUED',
  APPLYING: 'APPLYING',
  SUBMITTED: 'SUBMITTED',
  FAILED: 'FAILED',
  CANCELLED: 'CANCELLED',
  RETRYING: 'RETRYING',
  MANUAL_REQUIRED: 'MANUAL_REQUIRED'
};

export type AutoApplicationStatus = (typeof AutoApplicationStatus)[keyof typeof AutoApplicationStatus]


export const MessageRole: {
  USER: 'USER',
  ASSISTANT: 'ASSISTANT',
  SYSTEM: 'SYSTEM'
};

export type MessageRole = (typeof MessageRole)[keyof typeof MessageRole]


export const GoalType: {
  JOB_SEARCH: 'JOB_SEARCH',
  RESUME_IMPROVEMENT: 'RESUME_IMPROVEMENT',
  SKILL_DEVELOPMENT: 'SKILL_DEVELOPMENT',
  INTERVIEW_PREP: 'INTERVIEW_PREP',
  CAREER_PLANNING: 'CAREER_PLANNING',
  OTHER: 'OTHER'
};

export type GoalType = (typeof GoalType)[keyof typeof GoalType]


export const GoalStatus: {
  ACTIVE: 'ACTIVE',
  PAUSED: 'PAUSED',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type GoalStatus = (typeof GoalStatus)[keyof typeof GoalStatus]


export const RoutineType: {
  SEARCH_JOBS: 'SEARCH_JOBS',
  APPLY_TO_JOBS: 'APPLY_TO_JOBS',
  REVIEW_APPLICATIONS: 'REVIEW_APPLICATIONS',
  UPDATE_GOALS: 'UPDATE_GOALS',
  DAILY_DIGEST: 'DAILY_DIGEST',
  WEEKLY_SUMMARY: 'WEEKLY_SUMMARY',
  CUSTOM: 'CUSTOM'
};

export type RoutineType = (typeof RoutineType)[keyof typeof RoutineType]


export const WorkerRole: {
  OPERATOR: 'OPERATOR',
  ADMIN: 'ADMIN'
};

export type WorkerRole = (typeof WorkerRole)[keyof typeof WorkerRole]


export const WorkerSessionStatus: {
  QUEUED: 'QUEUED',
  ASSIGNED: 'ASSIGNED',
  AI_PROCESSING: 'AI_PROCESSING',
  READY_FOR_SUBMIT: 'READY_FOR_SUBMIT',
  SUBMITTED: 'SUBMITTED',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  SKIPPED: 'SKIPPED'
};

export type WorkerSessionStatus = (typeof WorkerSessionStatus)[keyof typeof WorkerSessionStatus]

}

export type JobStatus = $Enums.JobStatus

export const JobStatus: typeof $Enums.JobStatus

export type ArtifactType = $Enums.ArtifactType

export const ArtifactType: typeof $Enums.ArtifactType

export type EmbeddingType = $Enums.EmbeddingType

export const EmbeddingType: typeof $Enums.EmbeddingType

export type SubscriptionTier = $Enums.SubscriptionTier

export const SubscriptionTier: typeof $Enums.SubscriptionTier

export type SubscriptionStatus = $Enums.SubscriptionStatus

export const SubscriptionStatus: typeof $Enums.SubscriptionStatus

export type PaymentStatus = $Enums.PaymentStatus

export const PaymentStatus: typeof $Enums.PaymentStatus

export type AutoApplicationStatus = $Enums.AutoApplicationStatus

export const AutoApplicationStatus: typeof $Enums.AutoApplicationStatus

export type MessageRole = $Enums.MessageRole

export const MessageRole: typeof $Enums.MessageRole

export type GoalType = $Enums.GoalType

export const GoalType: typeof $Enums.GoalType

export type GoalStatus = $Enums.GoalStatus

export const GoalStatus: typeof $Enums.GoalStatus

export type RoutineType = $Enums.RoutineType

export const RoutineType: typeof $Enums.RoutineType

export type WorkerRole = $Enums.WorkerRole

export const WorkerRole: typeof $Enums.WorkerRole

export type WorkerSessionStatus = $Enums.WorkerSessionStatus

export const WorkerSessionStatus: typeof $Enums.WorkerSessionStatus

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.gmailConnection`: Exposes CRUD operations for the **GmailConnection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GmailConnections
    * const gmailConnections = await prisma.gmailConnection.findMany()
    * ```
    */
  get gmailConnection(): Prisma.GmailConnectionDelegate<ExtArgs>;

  /**
   * `prisma.profile`: Exposes CRUD operations for the **Profile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Profiles
    * const profiles = await prisma.profile.findMany()
    * ```
    */
  get profile(): Prisma.ProfileDelegate<ExtArgs>;

  /**
   * `prisma.job`: Exposes CRUD operations for the **Job** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Jobs
    * const jobs = await prisma.job.findMany()
    * ```
    */
  get job(): Prisma.JobDelegate<ExtArgs>;

  /**
   * `prisma.artifact`: Exposes CRUD operations for the **Artifact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Artifacts
    * const artifacts = await prisma.artifact.findMany()
    * ```
    */
  get artifact(): Prisma.ArtifactDelegate<ExtArgs>;

  /**
   * `prisma.embedding`: Exposes CRUD operations for the **Embedding** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Embeddings
    * const embeddings = await prisma.embedding.findMany()
    * ```
    */
  get embedding(): Prisma.EmbeddingDelegate<ExtArgs>;

  /**
   * `prisma.subscription`: Exposes CRUD operations for the **Subscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subscriptions
    * const subscriptions = await prisma.subscription.findMany()
    * ```
    */
  get subscription(): Prisma.SubscriptionDelegate<ExtArgs>;

  /**
   * `prisma.usageTracking`: Exposes CRUD operations for the **UsageTracking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UsageTrackings
    * const usageTrackings = await prisma.usageTracking.findMany()
    * ```
    */
  get usageTracking(): Prisma.UsageTrackingDelegate<ExtArgs>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs>;

  /**
   * `prisma.aggregatedJob`: Exposes CRUD operations for the **AggregatedJob** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AggregatedJobs
    * const aggregatedJobs = await prisma.aggregatedJob.findMany()
    * ```
    */
  get aggregatedJob(): Prisma.AggregatedJobDelegate<ExtArgs>;

  /**
   * `prisma.autoApplication`: Exposes CRUD operations for the **AutoApplication** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AutoApplications
    * const autoApplications = await prisma.autoApplication.findMany()
    * ```
    */
  get autoApplication(): Prisma.AutoApplicationDelegate<ExtArgs>;

  /**
   * `prisma.applicationRecipe`: Exposes CRUD operations for the **ApplicationRecipe** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ApplicationRecipes
    * const applicationRecipes = await prisma.applicationRecipe.findMany()
    * ```
    */
  get applicationRecipe(): Prisma.ApplicationRecipeDelegate<ExtArgs>;

  /**
   * `prisma.recipeExecution`: Exposes CRUD operations for the **RecipeExecution** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RecipeExecutions
    * const recipeExecutions = await prisma.recipeExecution.findMany()
    * ```
    */
  get recipeExecution(): Prisma.RecipeExecutionDelegate<ExtArgs>;

  /**
   * `prisma.discoveredCompany`: Exposes CRUD operations for the **DiscoveredCompany** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DiscoveredCompanies
    * const discoveredCompanies = await prisma.discoveredCompany.findMany()
    * ```
    */
  get discoveredCompany(): Prisma.DiscoveredCompanyDelegate<ExtArgs>;

  /**
   * `prisma.conversation`: Exposes CRUD operations for the **Conversation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Conversations
    * const conversations = await prisma.conversation.findMany()
    * ```
    */
  get conversation(): Prisma.ConversationDelegate<ExtArgs>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs>;

  /**
   * `prisma.goal`: Exposes CRUD operations for the **Goal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Goals
    * const goals = await prisma.goal.findMany()
    * ```
    */
  get goal(): Prisma.GoalDelegate<ExtArgs>;

  /**
   * `prisma.messageUsage`: Exposes CRUD operations for the **MessageUsage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MessageUsages
    * const messageUsages = await prisma.messageUsage.findMany()
    * ```
    */
  get messageUsage(): Prisma.MessageUsageDelegate<ExtArgs>;

  /**
   * `prisma.routine`: Exposes CRUD operations for the **Routine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Routines
    * const routines = await prisma.routine.findMany()
    * ```
    */
  get routine(): Prisma.RoutineDelegate<ExtArgs>;

  /**
   * `prisma.routineExecution`: Exposes CRUD operations for the **RoutineExecution** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RoutineExecutions
    * const routineExecutions = await prisma.routineExecution.findMany()
    * ```
    */
  get routineExecution(): Prisma.RoutineExecutionDelegate<ExtArgs>;

  /**
   * `prisma.worker`: Exposes CRUD operations for the **Worker** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Workers
    * const workers = await prisma.worker.findMany()
    * ```
    */
  get worker(): Prisma.WorkerDelegate<ExtArgs>;

  /**
   * `prisma.workerSession`: Exposes CRUD operations for the **WorkerSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkerSessions
    * const workerSessions = await prisma.workerSession.findMany()
    * ```
    */
  get workerSession(): Prisma.WorkerSessionDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    GmailConnection: 'GmailConnection',
    Profile: 'Profile',
    Job: 'Job',
    Artifact: 'Artifact',
    Embedding: 'Embedding',
    Subscription: 'Subscription',
    UsageTracking: 'UsageTracking',
    Payment: 'Payment',
    AggregatedJob: 'AggregatedJob',
    AutoApplication: 'AutoApplication',
    ApplicationRecipe: 'ApplicationRecipe',
    RecipeExecution: 'RecipeExecution',
    DiscoveredCompany: 'DiscoveredCompany',
    Conversation: 'Conversation',
    Message: 'Message',
    Goal: 'Goal',
    MessageUsage: 'MessageUsage',
    Routine: 'Routine',
    RoutineExecution: 'RoutineExecution',
    Worker: 'Worker',
    WorkerSession: 'WorkerSession'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "gmailConnection" | "profile" | "job" | "artifact" | "embedding" | "subscription" | "usageTracking" | "payment" | "aggregatedJob" | "autoApplication" | "applicationRecipe" | "recipeExecution" | "discoveredCompany" | "conversation" | "message" | "goal" | "messageUsage" | "routine" | "routineExecution" | "worker" | "workerSession"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      GmailConnection: {
        payload: Prisma.$GmailConnectionPayload<ExtArgs>
        fields: Prisma.GmailConnectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GmailConnectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GmailConnectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GmailConnectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GmailConnectionPayload>
          }
          findFirst: {
            args: Prisma.GmailConnectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GmailConnectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GmailConnectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GmailConnectionPayload>
          }
          findMany: {
            args: Prisma.GmailConnectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GmailConnectionPayload>[]
          }
          create: {
            args: Prisma.GmailConnectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GmailConnectionPayload>
          }
          createMany: {
            args: Prisma.GmailConnectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GmailConnectionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GmailConnectionPayload>[]
          }
          delete: {
            args: Prisma.GmailConnectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GmailConnectionPayload>
          }
          update: {
            args: Prisma.GmailConnectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GmailConnectionPayload>
          }
          deleteMany: {
            args: Prisma.GmailConnectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GmailConnectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GmailConnectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GmailConnectionPayload>
          }
          aggregate: {
            args: Prisma.GmailConnectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGmailConnection>
          }
          groupBy: {
            args: Prisma.GmailConnectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<GmailConnectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.GmailConnectionCountArgs<ExtArgs>
            result: $Utils.Optional<GmailConnectionCountAggregateOutputType> | number
          }
        }
      }
      Profile: {
        payload: Prisma.$ProfilePayload<ExtArgs>
        fields: Prisma.ProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          findFirst: {
            args: Prisma.ProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          findMany: {
            args: Prisma.ProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>[]
          }
          create: {
            args: Prisma.ProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          createMany: {
            args: Prisma.ProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>[]
          }
          delete: {
            args: Prisma.ProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          update: {
            args: Prisma.ProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          deleteMany: {
            args: Prisma.ProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          aggregate: {
            args: Prisma.ProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProfile>
          }
          groupBy: {
            args: Prisma.ProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProfileCountArgs<ExtArgs>
            result: $Utils.Optional<ProfileCountAggregateOutputType> | number
          }
        }
      }
      Job: {
        payload: Prisma.$JobPayload<ExtArgs>
        fields: Prisma.JobFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JobFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JobFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>
          }
          findFirst: {
            args: Prisma.JobFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JobFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>
          }
          findMany: {
            args: Prisma.JobFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>[]
          }
          create: {
            args: Prisma.JobCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>
          }
          createMany: {
            args: Prisma.JobCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JobCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>[]
          }
          delete: {
            args: Prisma.JobDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>
          }
          update: {
            args: Prisma.JobUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>
          }
          deleteMany: {
            args: Prisma.JobDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JobUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.JobUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>
          }
          aggregate: {
            args: Prisma.JobAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJob>
          }
          groupBy: {
            args: Prisma.JobGroupByArgs<ExtArgs>
            result: $Utils.Optional<JobGroupByOutputType>[]
          }
          count: {
            args: Prisma.JobCountArgs<ExtArgs>
            result: $Utils.Optional<JobCountAggregateOutputType> | number
          }
        }
      }
      Artifact: {
        payload: Prisma.$ArtifactPayload<ExtArgs>
        fields: Prisma.ArtifactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ArtifactFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtifactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ArtifactFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtifactPayload>
          }
          findFirst: {
            args: Prisma.ArtifactFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtifactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ArtifactFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtifactPayload>
          }
          findMany: {
            args: Prisma.ArtifactFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtifactPayload>[]
          }
          create: {
            args: Prisma.ArtifactCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtifactPayload>
          }
          createMany: {
            args: Prisma.ArtifactCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ArtifactCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtifactPayload>[]
          }
          delete: {
            args: Prisma.ArtifactDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtifactPayload>
          }
          update: {
            args: Prisma.ArtifactUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtifactPayload>
          }
          deleteMany: {
            args: Prisma.ArtifactDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ArtifactUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ArtifactUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtifactPayload>
          }
          aggregate: {
            args: Prisma.ArtifactAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateArtifact>
          }
          groupBy: {
            args: Prisma.ArtifactGroupByArgs<ExtArgs>
            result: $Utils.Optional<ArtifactGroupByOutputType>[]
          }
          count: {
            args: Prisma.ArtifactCountArgs<ExtArgs>
            result: $Utils.Optional<ArtifactCountAggregateOutputType> | number
          }
        }
      }
      Embedding: {
        payload: Prisma.$EmbeddingPayload<ExtArgs>
        fields: Prisma.EmbeddingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmbeddingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmbeddingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmbeddingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmbeddingPayload>
          }
          findFirst: {
            args: Prisma.EmbeddingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmbeddingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmbeddingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmbeddingPayload>
          }
          findMany: {
            args: Prisma.EmbeddingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmbeddingPayload>[]
          }
          create: {
            args: Prisma.EmbeddingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmbeddingPayload>
          }
          createMany: {
            args: Prisma.EmbeddingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmbeddingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmbeddingPayload>[]
          }
          delete: {
            args: Prisma.EmbeddingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmbeddingPayload>
          }
          update: {
            args: Prisma.EmbeddingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmbeddingPayload>
          }
          deleteMany: {
            args: Prisma.EmbeddingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmbeddingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmbeddingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmbeddingPayload>
          }
          aggregate: {
            args: Prisma.EmbeddingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmbedding>
          }
          groupBy: {
            args: Prisma.EmbeddingGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmbeddingGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmbeddingCountArgs<ExtArgs>
            result: $Utils.Optional<EmbeddingCountAggregateOutputType> | number
          }
        }
      }
      Subscription: {
        payload: Prisma.$SubscriptionPayload<ExtArgs>
        fields: Prisma.SubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findFirst: {
            args: Prisma.SubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findMany: {
            args: Prisma.SubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          create: {
            args: Prisma.SubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          createMany: {
            args: Prisma.SubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          delete: {
            args: Prisma.SubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          update: {
            args: Prisma.SubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.SubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscription>
          }
          groupBy: {
            args: Prisma.SubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionCountAggregateOutputType> | number
          }
        }
      }
      UsageTracking: {
        payload: Prisma.$UsageTrackingPayload<ExtArgs>
        fields: Prisma.UsageTrackingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsageTrackingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageTrackingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsageTrackingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageTrackingPayload>
          }
          findFirst: {
            args: Prisma.UsageTrackingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageTrackingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsageTrackingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageTrackingPayload>
          }
          findMany: {
            args: Prisma.UsageTrackingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageTrackingPayload>[]
          }
          create: {
            args: Prisma.UsageTrackingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageTrackingPayload>
          }
          createMany: {
            args: Prisma.UsageTrackingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UsageTrackingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageTrackingPayload>[]
          }
          delete: {
            args: Prisma.UsageTrackingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageTrackingPayload>
          }
          update: {
            args: Prisma.UsageTrackingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageTrackingPayload>
          }
          deleteMany: {
            args: Prisma.UsageTrackingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsageTrackingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UsageTrackingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageTrackingPayload>
          }
          aggregate: {
            args: Prisma.UsageTrackingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsageTracking>
          }
          groupBy: {
            args: Prisma.UsageTrackingGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsageTrackingGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsageTrackingCountArgs<ExtArgs>
            result: $Utils.Optional<UsageTrackingCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      AggregatedJob: {
        payload: Prisma.$AggregatedJobPayload<ExtArgs>
        fields: Prisma.AggregatedJobFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AggregatedJobFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AggregatedJobPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AggregatedJobFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AggregatedJobPayload>
          }
          findFirst: {
            args: Prisma.AggregatedJobFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AggregatedJobPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AggregatedJobFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AggregatedJobPayload>
          }
          findMany: {
            args: Prisma.AggregatedJobFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AggregatedJobPayload>[]
          }
          create: {
            args: Prisma.AggregatedJobCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AggregatedJobPayload>
          }
          createMany: {
            args: Prisma.AggregatedJobCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AggregatedJobCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AggregatedJobPayload>[]
          }
          delete: {
            args: Prisma.AggregatedJobDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AggregatedJobPayload>
          }
          update: {
            args: Prisma.AggregatedJobUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AggregatedJobPayload>
          }
          deleteMany: {
            args: Prisma.AggregatedJobDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AggregatedJobUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AggregatedJobUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AggregatedJobPayload>
          }
          aggregate: {
            args: Prisma.AggregatedJobAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAggregatedJob>
          }
          groupBy: {
            args: Prisma.AggregatedJobGroupByArgs<ExtArgs>
            result: $Utils.Optional<AggregatedJobGroupByOutputType>[]
          }
          count: {
            args: Prisma.AggregatedJobCountArgs<ExtArgs>
            result: $Utils.Optional<AggregatedJobCountAggregateOutputType> | number
          }
        }
      }
      AutoApplication: {
        payload: Prisma.$AutoApplicationPayload<ExtArgs>
        fields: Prisma.AutoApplicationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AutoApplicationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoApplicationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AutoApplicationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoApplicationPayload>
          }
          findFirst: {
            args: Prisma.AutoApplicationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoApplicationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AutoApplicationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoApplicationPayload>
          }
          findMany: {
            args: Prisma.AutoApplicationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoApplicationPayload>[]
          }
          create: {
            args: Prisma.AutoApplicationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoApplicationPayload>
          }
          createMany: {
            args: Prisma.AutoApplicationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AutoApplicationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoApplicationPayload>[]
          }
          delete: {
            args: Prisma.AutoApplicationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoApplicationPayload>
          }
          update: {
            args: Prisma.AutoApplicationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoApplicationPayload>
          }
          deleteMany: {
            args: Prisma.AutoApplicationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AutoApplicationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AutoApplicationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoApplicationPayload>
          }
          aggregate: {
            args: Prisma.AutoApplicationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAutoApplication>
          }
          groupBy: {
            args: Prisma.AutoApplicationGroupByArgs<ExtArgs>
            result: $Utils.Optional<AutoApplicationGroupByOutputType>[]
          }
          count: {
            args: Prisma.AutoApplicationCountArgs<ExtArgs>
            result: $Utils.Optional<AutoApplicationCountAggregateOutputType> | number
          }
        }
      }
      ApplicationRecipe: {
        payload: Prisma.$ApplicationRecipePayload<ExtArgs>
        fields: Prisma.ApplicationRecipeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApplicationRecipeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationRecipePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApplicationRecipeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationRecipePayload>
          }
          findFirst: {
            args: Prisma.ApplicationRecipeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationRecipePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApplicationRecipeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationRecipePayload>
          }
          findMany: {
            args: Prisma.ApplicationRecipeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationRecipePayload>[]
          }
          create: {
            args: Prisma.ApplicationRecipeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationRecipePayload>
          }
          createMany: {
            args: Prisma.ApplicationRecipeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ApplicationRecipeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationRecipePayload>[]
          }
          delete: {
            args: Prisma.ApplicationRecipeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationRecipePayload>
          }
          update: {
            args: Prisma.ApplicationRecipeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationRecipePayload>
          }
          deleteMany: {
            args: Prisma.ApplicationRecipeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApplicationRecipeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ApplicationRecipeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationRecipePayload>
          }
          aggregate: {
            args: Prisma.ApplicationRecipeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApplicationRecipe>
          }
          groupBy: {
            args: Prisma.ApplicationRecipeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApplicationRecipeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApplicationRecipeCountArgs<ExtArgs>
            result: $Utils.Optional<ApplicationRecipeCountAggregateOutputType> | number
          }
        }
      }
      RecipeExecution: {
        payload: Prisma.$RecipeExecutionPayload<ExtArgs>
        fields: Prisma.RecipeExecutionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RecipeExecutionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeExecutionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RecipeExecutionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeExecutionPayload>
          }
          findFirst: {
            args: Prisma.RecipeExecutionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeExecutionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RecipeExecutionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeExecutionPayload>
          }
          findMany: {
            args: Prisma.RecipeExecutionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeExecutionPayload>[]
          }
          create: {
            args: Prisma.RecipeExecutionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeExecutionPayload>
          }
          createMany: {
            args: Prisma.RecipeExecutionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RecipeExecutionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeExecutionPayload>[]
          }
          delete: {
            args: Prisma.RecipeExecutionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeExecutionPayload>
          }
          update: {
            args: Prisma.RecipeExecutionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeExecutionPayload>
          }
          deleteMany: {
            args: Prisma.RecipeExecutionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RecipeExecutionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RecipeExecutionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeExecutionPayload>
          }
          aggregate: {
            args: Prisma.RecipeExecutionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRecipeExecution>
          }
          groupBy: {
            args: Prisma.RecipeExecutionGroupByArgs<ExtArgs>
            result: $Utils.Optional<RecipeExecutionGroupByOutputType>[]
          }
          count: {
            args: Prisma.RecipeExecutionCountArgs<ExtArgs>
            result: $Utils.Optional<RecipeExecutionCountAggregateOutputType> | number
          }
        }
      }
      DiscoveredCompany: {
        payload: Prisma.$DiscoveredCompanyPayload<ExtArgs>
        fields: Prisma.DiscoveredCompanyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DiscoveredCompanyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscoveredCompanyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DiscoveredCompanyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscoveredCompanyPayload>
          }
          findFirst: {
            args: Prisma.DiscoveredCompanyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscoveredCompanyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DiscoveredCompanyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscoveredCompanyPayload>
          }
          findMany: {
            args: Prisma.DiscoveredCompanyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscoveredCompanyPayload>[]
          }
          create: {
            args: Prisma.DiscoveredCompanyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscoveredCompanyPayload>
          }
          createMany: {
            args: Prisma.DiscoveredCompanyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DiscoveredCompanyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscoveredCompanyPayload>[]
          }
          delete: {
            args: Prisma.DiscoveredCompanyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscoveredCompanyPayload>
          }
          update: {
            args: Prisma.DiscoveredCompanyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscoveredCompanyPayload>
          }
          deleteMany: {
            args: Prisma.DiscoveredCompanyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DiscoveredCompanyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DiscoveredCompanyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscoveredCompanyPayload>
          }
          aggregate: {
            args: Prisma.DiscoveredCompanyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDiscoveredCompany>
          }
          groupBy: {
            args: Prisma.DiscoveredCompanyGroupByArgs<ExtArgs>
            result: $Utils.Optional<DiscoveredCompanyGroupByOutputType>[]
          }
          count: {
            args: Prisma.DiscoveredCompanyCountArgs<ExtArgs>
            result: $Utils.Optional<DiscoveredCompanyCountAggregateOutputType> | number
          }
        }
      }
      Conversation: {
        payload: Prisma.$ConversationPayload<ExtArgs>
        fields: Prisma.ConversationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConversationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConversationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          findFirst: {
            args: Prisma.ConversationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConversationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          findMany: {
            args: Prisma.ConversationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>[]
          }
          create: {
            args: Prisma.ConversationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          createMany: {
            args: Prisma.ConversationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConversationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>[]
          }
          delete: {
            args: Prisma.ConversationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          update: {
            args: Prisma.ConversationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          deleteMany: {
            args: Prisma.ConversationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConversationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ConversationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          aggregate: {
            args: Prisma.ConversationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConversation>
          }
          groupBy: {
            args: Prisma.ConversationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConversationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConversationCountArgs<ExtArgs>
            result: $Utils.Optional<ConversationCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      Goal: {
        payload: Prisma.$GoalPayload<ExtArgs>
        fields: Prisma.GoalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GoalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GoalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalPayload>
          }
          findFirst: {
            args: Prisma.GoalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GoalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalPayload>
          }
          findMany: {
            args: Prisma.GoalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalPayload>[]
          }
          create: {
            args: Prisma.GoalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalPayload>
          }
          createMany: {
            args: Prisma.GoalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GoalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalPayload>[]
          }
          delete: {
            args: Prisma.GoalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalPayload>
          }
          update: {
            args: Prisma.GoalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalPayload>
          }
          deleteMany: {
            args: Prisma.GoalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GoalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GoalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalPayload>
          }
          aggregate: {
            args: Prisma.GoalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGoal>
          }
          groupBy: {
            args: Prisma.GoalGroupByArgs<ExtArgs>
            result: $Utils.Optional<GoalGroupByOutputType>[]
          }
          count: {
            args: Prisma.GoalCountArgs<ExtArgs>
            result: $Utils.Optional<GoalCountAggregateOutputType> | number
          }
        }
      }
      MessageUsage: {
        payload: Prisma.$MessageUsagePayload<ExtArgs>
        fields: Prisma.MessageUsageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageUsageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageUsagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageUsageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageUsagePayload>
          }
          findFirst: {
            args: Prisma.MessageUsageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageUsagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageUsageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageUsagePayload>
          }
          findMany: {
            args: Prisma.MessageUsageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageUsagePayload>[]
          }
          create: {
            args: Prisma.MessageUsageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageUsagePayload>
          }
          createMany: {
            args: Prisma.MessageUsageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageUsageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageUsagePayload>[]
          }
          delete: {
            args: Prisma.MessageUsageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageUsagePayload>
          }
          update: {
            args: Prisma.MessageUsageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageUsagePayload>
          }
          deleteMany: {
            args: Prisma.MessageUsageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUsageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MessageUsageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageUsagePayload>
          }
          aggregate: {
            args: Prisma.MessageUsageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessageUsage>
          }
          groupBy: {
            args: Prisma.MessageUsageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageUsageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageUsageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageUsageCountAggregateOutputType> | number
          }
        }
      }
      Routine: {
        payload: Prisma.$RoutinePayload<ExtArgs>
        fields: Prisma.RoutineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoutineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoutineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutinePayload>
          }
          findFirst: {
            args: Prisma.RoutineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoutineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutinePayload>
          }
          findMany: {
            args: Prisma.RoutineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutinePayload>[]
          }
          create: {
            args: Prisma.RoutineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutinePayload>
          }
          createMany: {
            args: Prisma.RoutineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoutineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutinePayload>[]
          }
          delete: {
            args: Prisma.RoutineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutinePayload>
          }
          update: {
            args: Prisma.RoutineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutinePayload>
          }
          deleteMany: {
            args: Prisma.RoutineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoutineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RoutineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutinePayload>
          }
          aggregate: {
            args: Prisma.RoutineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoutine>
          }
          groupBy: {
            args: Prisma.RoutineGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoutineGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoutineCountArgs<ExtArgs>
            result: $Utils.Optional<RoutineCountAggregateOutputType> | number
          }
        }
      }
      RoutineExecution: {
        payload: Prisma.$RoutineExecutionPayload<ExtArgs>
        fields: Prisma.RoutineExecutionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoutineExecutionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutineExecutionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoutineExecutionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutineExecutionPayload>
          }
          findFirst: {
            args: Prisma.RoutineExecutionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutineExecutionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoutineExecutionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutineExecutionPayload>
          }
          findMany: {
            args: Prisma.RoutineExecutionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutineExecutionPayload>[]
          }
          create: {
            args: Prisma.RoutineExecutionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutineExecutionPayload>
          }
          createMany: {
            args: Prisma.RoutineExecutionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoutineExecutionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutineExecutionPayload>[]
          }
          delete: {
            args: Prisma.RoutineExecutionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutineExecutionPayload>
          }
          update: {
            args: Prisma.RoutineExecutionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutineExecutionPayload>
          }
          deleteMany: {
            args: Prisma.RoutineExecutionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoutineExecutionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RoutineExecutionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutineExecutionPayload>
          }
          aggregate: {
            args: Prisma.RoutineExecutionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoutineExecution>
          }
          groupBy: {
            args: Prisma.RoutineExecutionGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoutineExecutionGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoutineExecutionCountArgs<ExtArgs>
            result: $Utils.Optional<RoutineExecutionCountAggregateOutputType> | number
          }
        }
      }
      Worker: {
        payload: Prisma.$WorkerPayload<ExtArgs>
        fields: Prisma.WorkerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerPayload>
          }
          findFirst: {
            args: Prisma.WorkerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerPayload>
          }
          findMany: {
            args: Prisma.WorkerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerPayload>[]
          }
          create: {
            args: Prisma.WorkerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerPayload>
          }
          createMany: {
            args: Prisma.WorkerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerPayload>[]
          }
          delete: {
            args: Prisma.WorkerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerPayload>
          }
          update: {
            args: Prisma.WorkerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerPayload>
          }
          deleteMany: {
            args: Prisma.WorkerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WorkerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerPayload>
          }
          aggregate: {
            args: Prisma.WorkerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorker>
          }
          groupBy: {
            args: Prisma.WorkerGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkerGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkerCountArgs<ExtArgs>
            result: $Utils.Optional<WorkerCountAggregateOutputType> | number
          }
        }
      }
      WorkerSession: {
        payload: Prisma.$WorkerSessionPayload<ExtArgs>
        fields: Prisma.WorkerSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkerSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkerSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerSessionPayload>
          }
          findFirst: {
            args: Prisma.WorkerSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkerSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerSessionPayload>
          }
          findMany: {
            args: Prisma.WorkerSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerSessionPayload>[]
          }
          create: {
            args: Prisma.WorkerSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerSessionPayload>
          }
          createMany: {
            args: Prisma.WorkerSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkerSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerSessionPayload>[]
          }
          delete: {
            args: Prisma.WorkerSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerSessionPayload>
          }
          update: {
            args: Prisma.WorkerSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerSessionPayload>
          }
          deleteMany: {
            args: Prisma.WorkerSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkerSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WorkerSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerSessionPayload>
          }
          aggregate: {
            args: Prisma.WorkerSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkerSession>
          }
          groupBy: {
            args: Prisma.WorkerSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkerSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkerSessionCountArgs<ExtArgs>
            result: $Utils.Optional<WorkerSessionCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    jobs: number
    usageTracking: number
    payments: number
    autoApplications: number
    conversations: number
    goals: number
    routines: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobs?: boolean | UserCountOutputTypeCountJobsArgs
    usageTracking?: boolean | UserCountOutputTypeCountUsageTrackingArgs
    payments?: boolean | UserCountOutputTypeCountPaymentsArgs
    autoApplications?: boolean | UserCountOutputTypeCountAutoApplicationsArgs
    conversations?: boolean | UserCountOutputTypeCountConversationsArgs
    goals?: boolean | UserCountOutputTypeCountGoalsArgs
    routines?: boolean | UserCountOutputTypeCountRoutinesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUsageTrackingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsageTrackingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAutoApplicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutoApplicationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountConversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGoalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GoalWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRoutinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoutineWhereInput
  }


  /**
   * Count Type JobCountOutputType
   */

  export type JobCountOutputType = {
    artifacts: number
    embeddings: number
  }

  export type JobCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    artifacts?: boolean | JobCountOutputTypeCountArtifactsArgs
    embeddings?: boolean | JobCountOutputTypeCountEmbeddingsArgs
  }

  // Custom InputTypes
  /**
   * JobCountOutputType without action
   */
  export type JobCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobCountOutputType
     */
    select?: JobCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * JobCountOutputType without action
   */
  export type JobCountOutputTypeCountArtifactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArtifactWhereInput
  }

  /**
   * JobCountOutputType without action
   */
  export type JobCountOutputTypeCountEmbeddingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmbeddingWhereInput
  }


  /**
   * Count Type AggregatedJobCountOutputType
   */

  export type AggregatedJobCountOutputType = {
    applications: number
  }

  export type AggregatedJobCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    applications?: boolean | AggregatedJobCountOutputTypeCountApplicationsArgs
  }

  // Custom InputTypes
  /**
   * AggregatedJobCountOutputType without action
   */
  export type AggregatedJobCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AggregatedJobCountOutputType
     */
    select?: AggregatedJobCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AggregatedJobCountOutputType without action
   */
  export type AggregatedJobCountOutputTypeCountApplicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutoApplicationWhereInput
  }


  /**
   * Count Type ApplicationRecipeCountOutputType
   */

  export type ApplicationRecipeCountOutputType = {
    executions: number
  }

  export type ApplicationRecipeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    executions?: boolean | ApplicationRecipeCountOutputTypeCountExecutionsArgs
  }

  // Custom InputTypes
  /**
   * ApplicationRecipeCountOutputType without action
   */
  export type ApplicationRecipeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicationRecipeCountOutputType
     */
    select?: ApplicationRecipeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ApplicationRecipeCountOutputType without action
   */
  export type ApplicationRecipeCountOutputTypeCountExecutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipeExecutionWhereInput
  }


  /**
   * Count Type ConversationCountOutputType
   */

  export type ConversationCountOutputType = {
    messages: number
    goals: number
  }

  export type ConversationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | ConversationCountOutputTypeCountMessagesArgs
    goals?: boolean | ConversationCountOutputTypeCountGoalsArgs
  }

  // Custom InputTypes
  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationCountOutputType
     */
    select?: ConversationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeCountGoalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GoalWhereInput
  }


  /**
   * Count Type RoutineCountOutputType
   */

  export type RoutineCountOutputType = {
    executions: number
  }

  export type RoutineCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    executions?: boolean | RoutineCountOutputTypeCountExecutionsArgs
  }

  // Custom InputTypes
  /**
   * RoutineCountOutputType without action
   */
  export type RoutineCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoutineCountOutputType
     */
    select?: RoutineCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoutineCountOutputType without action
   */
  export type RoutineCountOutputTypeCountExecutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoutineExecutionWhereInput
  }


  /**
   * Count Type WorkerCountOutputType
   */

  export type WorkerCountOutputType = {
    sessions: number
  }

  export type WorkerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | WorkerCountOutputTypeCountSessionsArgs
  }

  // Custom InputTypes
  /**
   * WorkerCountOutputType without action
   */
  export type WorkerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerCountOutputType
     */
    select?: WorkerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WorkerCountOutputType without action
   */
  export type WorkerCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkerSessionWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    clerkId: string | null
    createdAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    clerkId: string | null
    createdAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    clerkId: number
    createdAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    clerkId?: true
    createdAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    clerkId?: true
    createdAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    clerkId?: true
    createdAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    email: string
    password: string
    clerkId: string | null
    createdAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    clerkId?: boolean
    createdAt?: boolean
    jobs?: boolean | User$jobsArgs<ExtArgs>
    profile?: boolean | User$profileArgs<ExtArgs>
    subscription?: boolean | User$subscriptionArgs<ExtArgs>
    usageTracking?: boolean | User$usageTrackingArgs<ExtArgs>
    payments?: boolean | User$paymentsArgs<ExtArgs>
    autoApplications?: boolean | User$autoApplicationsArgs<ExtArgs>
    conversations?: boolean | User$conversationsArgs<ExtArgs>
    goals?: boolean | User$goalsArgs<ExtArgs>
    routines?: boolean | User$routinesArgs<ExtArgs>
    gmailConnection?: boolean | User$gmailConnectionArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    clerkId?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    clerkId?: boolean
    createdAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobs?: boolean | User$jobsArgs<ExtArgs>
    profile?: boolean | User$profileArgs<ExtArgs>
    subscription?: boolean | User$subscriptionArgs<ExtArgs>
    usageTracking?: boolean | User$usageTrackingArgs<ExtArgs>
    payments?: boolean | User$paymentsArgs<ExtArgs>
    autoApplications?: boolean | User$autoApplicationsArgs<ExtArgs>
    conversations?: boolean | User$conversationsArgs<ExtArgs>
    goals?: boolean | User$goalsArgs<ExtArgs>
    routines?: boolean | User$routinesArgs<ExtArgs>
    gmailConnection?: boolean | User$gmailConnectionArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      jobs: Prisma.$JobPayload<ExtArgs>[]
      profile: Prisma.$ProfilePayload<ExtArgs> | null
      subscription: Prisma.$SubscriptionPayload<ExtArgs> | null
      usageTracking: Prisma.$UsageTrackingPayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      autoApplications: Prisma.$AutoApplicationPayload<ExtArgs>[]
      conversations: Prisma.$ConversationPayload<ExtArgs>[]
      goals: Prisma.$GoalPayload<ExtArgs>[]
      routines: Prisma.$RoutinePayload<ExtArgs>[]
      gmailConnection: Prisma.$GmailConnectionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      password: string
      clerkId: string | null
      createdAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    jobs<T extends User$jobsArgs<ExtArgs> = {}>(args?: Subset<T, User$jobsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findMany"> | Null>
    profile<T extends User$profileArgs<ExtArgs> = {}>(args?: Subset<T, User$profileArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    subscription<T extends User$subscriptionArgs<ExtArgs> = {}>(args?: Subset<T, User$subscriptionArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    usageTracking<T extends User$usageTrackingArgs<ExtArgs> = {}>(args?: Subset<T, User$usageTrackingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsageTrackingPayload<ExtArgs>, T, "findMany"> | Null>
    payments<T extends User$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, User$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany"> | Null>
    autoApplications<T extends User$autoApplicationsArgs<ExtArgs> = {}>(args?: Subset<T, User$autoApplicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutoApplicationPayload<ExtArgs>, T, "findMany"> | Null>
    conversations<T extends User$conversationsArgs<ExtArgs> = {}>(args?: Subset<T, User$conversationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findMany"> | Null>
    goals<T extends User$goalsArgs<ExtArgs> = {}>(args?: Subset<T, User$goalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "findMany"> | Null>
    routines<T extends User$routinesArgs<ExtArgs> = {}>(args?: Subset<T, User$routinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoutinePayload<ExtArgs>, T, "findMany"> | Null>
    gmailConnection<T extends User$gmailConnectionArgs<ExtArgs> = {}>(args?: Subset<T, User$gmailConnectionArgs<ExtArgs>>): Prisma__GmailConnectionClient<$Result.GetResult<Prisma.$GmailConnectionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly clerkId: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.jobs
   */
  export type User$jobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    where?: JobWhereInput
    orderBy?: JobOrderByWithRelationInput | JobOrderByWithRelationInput[]
    cursor?: JobWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobScalarFieldEnum | JobScalarFieldEnum[]
  }

  /**
   * User.profile
   */
  export type User$profileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    where?: ProfileWhereInput
  }

  /**
   * User.subscription
   */
  export type User$subscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    where?: SubscriptionWhereInput
  }

  /**
   * User.usageTracking
   */
  export type User$usageTrackingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageTracking
     */
    select?: UsageTrackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageTrackingInclude<ExtArgs> | null
    where?: UsageTrackingWhereInput
    orderBy?: UsageTrackingOrderByWithRelationInput | UsageTrackingOrderByWithRelationInput[]
    cursor?: UsageTrackingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsageTrackingScalarFieldEnum | UsageTrackingScalarFieldEnum[]
  }

  /**
   * User.payments
   */
  export type User$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * User.autoApplications
   */
  export type User$autoApplicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoApplication
     */
    select?: AutoApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoApplicationInclude<ExtArgs> | null
    where?: AutoApplicationWhereInput
    orderBy?: AutoApplicationOrderByWithRelationInput | AutoApplicationOrderByWithRelationInput[]
    cursor?: AutoApplicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AutoApplicationScalarFieldEnum | AutoApplicationScalarFieldEnum[]
  }

  /**
   * User.conversations
   */
  export type User$conversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    where?: ConversationWhereInput
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    cursor?: ConversationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * User.goals
   */
  export type User$goalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
    where?: GoalWhereInput
    orderBy?: GoalOrderByWithRelationInput | GoalOrderByWithRelationInput[]
    cursor?: GoalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GoalScalarFieldEnum | GoalScalarFieldEnum[]
  }

  /**
   * User.routines
   */
  export type User$routinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Routine
     */
    select?: RoutineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutineInclude<ExtArgs> | null
    where?: RoutineWhereInput
    orderBy?: RoutineOrderByWithRelationInput | RoutineOrderByWithRelationInput[]
    cursor?: RoutineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoutineScalarFieldEnum | RoutineScalarFieldEnum[]
  }

  /**
   * User.gmailConnection
   */
  export type User$gmailConnectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GmailConnection
     */
    select?: GmailConnectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GmailConnectionInclude<ExtArgs> | null
    where?: GmailConnectionWhereInput
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model GmailConnection
   */

  export type AggregateGmailConnection = {
    _count: GmailConnectionCountAggregateOutputType | null
    _avg: GmailConnectionAvgAggregateOutputType | null
    _sum: GmailConnectionSumAggregateOutputType | null
    _min: GmailConnectionMinAggregateOutputType | null
    _max: GmailConnectionMaxAggregateOutputType | null
  }

  export type GmailConnectionAvgAggregateOutputType = {
    userId: number | null
  }

  export type GmailConnectionSumAggregateOutputType = {
    userId: number | null
  }

  export type GmailConnectionMinAggregateOutputType = {
    id: string | null
    userId: number | null
    email: string | null
    accessToken: string | null
    refreshToken: string | null
    expiresAt: Date | null
    scope: string | null
    isActive: boolean | null
    lastUsed: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GmailConnectionMaxAggregateOutputType = {
    id: string | null
    userId: number | null
    email: string | null
    accessToken: string | null
    refreshToken: string | null
    expiresAt: Date | null
    scope: string | null
    isActive: boolean | null
    lastUsed: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GmailConnectionCountAggregateOutputType = {
    id: number
    userId: number
    email: number
    accessToken: number
    refreshToken: number
    expiresAt: number
    scope: number
    isActive: number
    lastUsed: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GmailConnectionAvgAggregateInputType = {
    userId?: true
  }

  export type GmailConnectionSumAggregateInputType = {
    userId?: true
  }

  export type GmailConnectionMinAggregateInputType = {
    id?: true
    userId?: true
    email?: true
    accessToken?: true
    refreshToken?: true
    expiresAt?: true
    scope?: true
    isActive?: true
    lastUsed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GmailConnectionMaxAggregateInputType = {
    id?: true
    userId?: true
    email?: true
    accessToken?: true
    refreshToken?: true
    expiresAt?: true
    scope?: true
    isActive?: true
    lastUsed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GmailConnectionCountAggregateInputType = {
    id?: true
    userId?: true
    email?: true
    accessToken?: true
    refreshToken?: true
    expiresAt?: true
    scope?: true
    isActive?: true
    lastUsed?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GmailConnectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GmailConnection to aggregate.
     */
    where?: GmailConnectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GmailConnections to fetch.
     */
    orderBy?: GmailConnectionOrderByWithRelationInput | GmailConnectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GmailConnectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GmailConnections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GmailConnections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GmailConnections
    **/
    _count?: true | GmailConnectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GmailConnectionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GmailConnectionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GmailConnectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GmailConnectionMaxAggregateInputType
  }

  export type GetGmailConnectionAggregateType<T extends GmailConnectionAggregateArgs> = {
        [P in keyof T & keyof AggregateGmailConnection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGmailConnection[P]>
      : GetScalarType<T[P], AggregateGmailConnection[P]>
  }




  export type GmailConnectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GmailConnectionWhereInput
    orderBy?: GmailConnectionOrderByWithAggregationInput | GmailConnectionOrderByWithAggregationInput[]
    by: GmailConnectionScalarFieldEnum[] | GmailConnectionScalarFieldEnum
    having?: GmailConnectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GmailConnectionCountAggregateInputType | true
    _avg?: GmailConnectionAvgAggregateInputType
    _sum?: GmailConnectionSumAggregateInputType
    _min?: GmailConnectionMinAggregateInputType
    _max?: GmailConnectionMaxAggregateInputType
  }

  export type GmailConnectionGroupByOutputType = {
    id: string
    userId: number
    email: string
    accessToken: string
    refreshToken: string
    expiresAt: Date
    scope: string
    isActive: boolean
    lastUsed: Date | null
    createdAt: Date
    updatedAt: Date
    _count: GmailConnectionCountAggregateOutputType | null
    _avg: GmailConnectionAvgAggregateOutputType | null
    _sum: GmailConnectionSumAggregateOutputType | null
    _min: GmailConnectionMinAggregateOutputType | null
    _max: GmailConnectionMaxAggregateOutputType | null
  }

  type GetGmailConnectionGroupByPayload<T extends GmailConnectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GmailConnectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GmailConnectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GmailConnectionGroupByOutputType[P]>
            : GetScalarType<T[P], GmailConnectionGroupByOutputType[P]>
        }
      >
    >


  export type GmailConnectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    email?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    expiresAt?: boolean
    scope?: boolean
    isActive?: boolean
    lastUsed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gmailConnection"]>

  export type GmailConnectionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    email?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    expiresAt?: boolean
    scope?: boolean
    isActive?: boolean
    lastUsed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gmailConnection"]>

  export type GmailConnectionSelectScalar = {
    id?: boolean
    userId?: boolean
    email?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    expiresAt?: boolean
    scope?: boolean
    isActive?: boolean
    lastUsed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GmailConnectionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type GmailConnectionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $GmailConnectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GmailConnection"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: number
      email: string
      accessToken: string
      refreshToken: string
      expiresAt: Date
      scope: string
      isActive: boolean
      lastUsed: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["gmailConnection"]>
    composites: {}
  }

  type GmailConnectionGetPayload<S extends boolean | null | undefined | GmailConnectionDefaultArgs> = $Result.GetResult<Prisma.$GmailConnectionPayload, S>

  type GmailConnectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GmailConnectionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GmailConnectionCountAggregateInputType | true
    }

  export interface GmailConnectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GmailConnection'], meta: { name: 'GmailConnection' } }
    /**
     * Find zero or one GmailConnection that matches the filter.
     * @param {GmailConnectionFindUniqueArgs} args - Arguments to find a GmailConnection
     * @example
     * // Get one GmailConnection
     * const gmailConnection = await prisma.gmailConnection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GmailConnectionFindUniqueArgs>(args: SelectSubset<T, GmailConnectionFindUniqueArgs<ExtArgs>>): Prisma__GmailConnectionClient<$Result.GetResult<Prisma.$GmailConnectionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one GmailConnection that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {GmailConnectionFindUniqueOrThrowArgs} args - Arguments to find a GmailConnection
     * @example
     * // Get one GmailConnection
     * const gmailConnection = await prisma.gmailConnection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GmailConnectionFindUniqueOrThrowArgs>(args: SelectSubset<T, GmailConnectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GmailConnectionClient<$Result.GetResult<Prisma.$GmailConnectionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first GmailConnection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GmailConnectionFindFirstArgs} args - Arguments to find a GmailConnection
     * @example
     * // Get one GmailConnection
     * const gmailConnection = await prisma.gmailConnection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GmailConnectionFindFirstArgs>(args?: SelectSubset<T, GmailConnectionFindFirstArgs<ExtArgs>>): Prisma__GmailConnectionClient<$Result.GetResult<Prisma.$GmailConnectionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first GmailConnection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GmailConnectionFindFirstOrThrowArgs} args - Arguments to find a GmailConnection
     * @example
     * // Get one GmailConnection
     * const gmailConnection = await prisma.gmailConnection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GmailConnectionFindFirstOrThrowArgs>(args?: SelectSubset<T, GmailConnectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__GmailConnectionClient<$Result.GetResult<Prisma.$GmailConnectionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more GmailConnections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GmailConnectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GmailConnections
     * const gmailConnections = await prisma.gmailConnection.findMany()
     * 
     * // Get first 10 GmailConnections
     * const gmailConnections = await prisma.gmailConnection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gmailConnectionWithIdOnly = await prisma.gmailConnection.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GmailConnectionFindManyArgs>(args?: SelectSubset<T, GmailConnectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GmailConnectionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a GmailConnection.
     * @param {GmailConnectionCreateArgs} args - Arguments to create a GmailConnection.
     * @example
     * // Create one GmailConnection
     * const GmailConnection = await prisma.gmailConnection.create({
     *   data: {
     *     // ... data to create a GmailConnection
     *   }
     * })
     * 
     */
    create<T extends GmailConnectionCreateArgs>(args: SelectSubset<T, GmailConnectionCreateArgs<ExtArgs>>): Prisma__GmailConnectionClient<$Result.GetResult<Prisma.$GmailConnectionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many GmailConnections.
     * @param {GmailConnectionCreateManyArgs} args - Arguments to create many GmailConnections.
     * @example
     * // Create many GmailConnections
     * const gmailConnection = await prisma.gmailConnection.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GmailConnectionCreateManyArgs>(args?: SelectSubset<T, GmailConnectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GmailConnections and returns the data saved in the database.
     * @param {GmailConnectionCreateManyAndReturnArgs} args - Arguments to create many GmailConnections.
     * @example
     * // Create many GmailConnections
     * const gmailConnection = await prisma.gmailConnection.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GmailConnections and only return the `id`
     * const gmailConnectionWithIdOnly = await prisma.gmailConnection.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GmailConnectionCreateManyAndReturnArgs>(args?: SelectSubset<T, GmailConnectionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GmailConnectionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a GmailConnection.
     * @param {GmailConnectionDeleteArgs} args - Arguments to delete one GmailConnection.
     * @example
     * // Delete one GmailConnection
     * const GmailConnection = await prisma.gmailConnection.delete({
     *   where: {
     *     // ... filter to delete one GmailConnection
     *   }
     * })
     * 
     */
    delete<T extends GmailConnectionDeleteArgs>(args: SelectSubset<T, GmailConnectionDeleteArgs<ExtArgs>>): Prisma__GmailConnectionClient<$Result.GetResult<Prisma.$GmailConnectionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one GmailConnection.
     * @param {GmailConnectionUpdateArgs} args - Arguments to update one GmailConnection.
     * @example
     * // Update one GmailConnection
     * const gmailConnection = await prisma.gmailConnection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GmailConnectionUpdateArgs>(args: SelectSubset<T, GmailConnectionUpdateArgs<ExtArgs>>): Prisma__GmailConnectionClient<$Result.GetResult<Prisma.$GmailConnectionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more GmailConnections.
     * @param {GmailConnectionDeleteManyArgs} args - Arguments to filter GmailConnections to delete.
     * @example
     * // Delete a few GmailConnections
     * const { count } = await prisma.gmailConnection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GmailConnectionDeleteManyArgs>(args?: SelectSubset<T, GmailConnectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GmailConnections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GmailConnectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GmailConnections
     * const gmailConnection = await prisma.gmailConnection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GmailConnectionUpdateManyArgs>(args: SelectSubset<T, GmailConnectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GmailConnection.
     * @param {GmailConnectionUpsertArgs} args - Arguments to update or create a GmailConnection.
     * @example
     * // Update or create a GmailConnection
     * const gmailConnection = await prisma.gmailConnection.upsert({
     *   create: {
     *     // ... data to create a GmailConnection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GmailConnection we want to update
     *   }
     * })
     */
    upsert<T extends GmailConnectionUpsertArgs>(args: SelectSubset<T, GmailConnectionUpsertArgs<ExtArgs>>): Prisma__GmailConnectionClient<$Result.GetResult<Prisma.$GmailConnectionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of GmailConnections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GmailConnectionCountArgs} args - Arguments to filter GmailConnections to count.
     * @example
     * // Count the number of GmailConnections
     * const count = await prisma.gmailConnection.count({
     *   where: {
     *     // ... the filter for the GmailConnections we want to count
     *   }
     * })
    **/
    count<T extends GmailConnectionCountArgs>(
      args?: Subset<T, GmailConnectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GmailConnectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GmailConnection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GmailConnectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GmailConnectionAggregateArgs>(args: Subset<T, GmailConnectionAggregateArgs>): Prisma.PrismaPromise<GetGmailConnectionAggregateType<T>>

    /**
     * Group by GmailConnection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GmailConnectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GmailConnectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GmailConnectionGroupByArgs['orderBy'] }
        : { orderBy?: GmailConnectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GmailConnectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGmailConnectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GmailConnection model
   */
  readonly fields: GmailConnectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GmailConnection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GmailConnectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GmailConnection model
   */ 
  interface GmailConnectionFieldRefs {
    readonly id: FieldRef<"GmailConnection", 'String'>
    readonly userId: FieldRef<"GmailConnection", 'Int'>
    readonly email: FieldRef<"GmailConnection", 'String'>
    readonly accessToken: FieldRef<"GmailConnection", 'String'>
    readonly refreshToken: FieldRef<"GmailConnection", 'String'>
    readonly expiresAt: FieldRef<"GmailConnection", 'DateTime'>
    readonly scope: FieldRef<"GmailConnection", 'String'>
    readonly isActive: FieldRef<"GmailConnection", 'Boolean'>
    readonly lastUsed: FieldRef<"GmailConnection", 'DateTime'>
    readonly createdAt: FieldRef<"GmailConnection", 'DateTime'>
    readonly updatedAt: FieldRef<"GmailConnection", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GmailConnection findUnique
   */
  export type GmailConnectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GmailConnection
     */
    select?: GmailConnectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GmailConnectionInclude<ExtArgs> | null
    /**
     * Filter, which GmailConnection to fetch.
     */
    where: GmailConnectionWhereUniqueInput
  }

  /**
   * GmailConnection findUniqueOrThrow
   */
  export type GmailConnectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GmailConnection
     */
    select?: GmailConnectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GmailConnectionInclude<ExtArgs> | null
    /**
     * Filter, which GmailConnection to fetch.
     */
    where: GmailConnectionWhereUniqueInput
  }

  /**
   * GmailConnection findFirst
   */
  export type GmailConnectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GmailConnection
     */
    select?: GmailConnectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GmailConnectionInclude<ExtArgs> | null
    /**
     * Filter, which GmailConnection to fetch.
     */
    where?: GmailConnectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GmailConnections to fetch.
     */
    orderBy?: GmailConnectionOrderByWithRelationInput | GmailConnectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GmailConnections.
     */
    cursor?: GmailConnectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GmailConnections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GmailConnections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GmailConnections.
     */
    distinct?: GmailConnectionScalarFieldEnum | GmailConnectionScalarFieldEnum[]
  }

  /**
   * GmailConnection findFirstOrThrow
   */
  export type GmailConnectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GmailConnection
     */
    select?: GmailConnectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GmailConnectionInclude<ExtArgs> | null
    /**
     * Filter, which GmailConnection to fetch.
     */
    where?: GmailConnectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GmailConnections to fetch.
     */
    orderBy?: GmailConnectionOrderByWithRelationInput | GmailConnectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GmailConnections.
     */
    cursor?: GmailConnectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GmailConnections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GmailConnections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GmailConnections.
     */
    distinct?: GmailConnectionScalarFieldEnum | GmailConnectionScalarFieldEnum[]
  }

  /**
   * GmailConnection findMany
   */
  export type GmailConnectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GmailConnection
     */
    select?: GmailConnectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GmailConnectionInclude<ExtArgs> | null
    /**
     * Filter, which GmailConnections to fetch.
     */
    where?: GmailConnectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GmailConnections to fetch.
     */
    orderBy?: GmailConnectionOrderByWithRelationInput | GmailConnectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GmailConnections.
     */
    cursor?: GmailConnectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GmailConnections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GmailConnections.
     */
    skip?: number
    distinct?: GmailConnectionScalarFieldEnum | GmailConnectionScalarFieldEnum[]
  }

  /**
   * GmailConnection create
   */
  export type GmailConnectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GmailConnection
     */
    select?: GmailConnectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GmailConnectionInclude<ExtArgs> | null
    /**
     * The data needed to create a GmailConnection.
     */
    data: XOR<GmailConnectionCreateInput, GmailConnectionUncheckedCreateInput>
  }

  /**
   * GmailConnection createMany
   */
  export type GmailConnectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GmailConnections.
     */
    data: GmailConnectionCreateManyInput | GmailConnectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GmailConnection createManyAndReturn
   */
  export type GmailConnectionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GmailConnection
     */
    select?: GmailConnectionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many GmailConnections.
     */
    data: GmailConnectionCreateManyInput | GmailConnectionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GmailConnectionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GmailConnection update
   */
  export type GmailConnectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GmailConnection
     */
    select?: GmailConnectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GmailConnectionInclude<ExtArgs> | null
    /**
     * The data needed to update a GmailConnection.
     */
    data: XOR<GmailConnectionUpdateInput, GmailConnectionUncheckedUpdateInput>
    /**
     * Choose, which GmailConnection to update.
     */
    where: GmailConnectionWhereUniqueInput
  }

  /**
   * GmailConnection updateMany
   */
  export type GmailConnectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GmailConnections.
     */
    data: XOR<GmailConnectionUpdateManyMutationInput, GmailConnectionUncheckedUpdateManyInput>
    /**
     * Filter which GmailConnections to update
     */
    where?: GmailConnectionWhereInput
  }

  /**
   * GmailConnection upsert
   */
  export type GmailConnectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GmailConnection
     */
    select?: GmailConnectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GmailConnectionInclude<ExtArgs> | null
    /**
     * The filter to search for the GmailConnection to update in case it exists.
     */
    where: GmailConnectionWhereUniqueInput
    /**
     * In case the GmailConnection found by the `where` argument doesn't exist, create a new GmailConnection with this data.
     */
    create: XOR<GmailConnectionCreateInput, GmailConnectionUncheckedCreateInput>
    /**
     * In case the GmailConnection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GmailConnectionUpdateInput, GmailConnectionUncheckedUpdateInput>
  }

  /**
   * GmailConnection delete
   */
  export type GmailConnectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GmailConnection
     */
    select?: GmailConnectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GmailConnectionInclude<ExtArgs> | null
    /**
     * Filter which GmailConnection to delete.
     */
    where: GmailConnectionWhereUniqueInput
  }

  /**
   * GmailConnection deleteMany
   */
  export type GmailConnectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GmailConnections to delete
     */
    where?: GmailConnectionWhereInput
  }

  /**
   * GmailConnection without action
   */
  export type GmailConnectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GmailConnection
     */
    select?: GmailConnectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GmailConnectionInclude<ExtArgs> | null
  }


  /**
   * Model Profile
   */

  export type AggregateProfile = {
    _count: ProfileCountAggregateOutputType | null
    _avg: ProfileAvgAggregateOutputType | null
    _sum: ProfileSumAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  export type ProfileAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type ProfileSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type ProfileMinAggregateOutputType = {
    id: number | null
    userId: number | null
    updatedAt: Date | null
  }

  export type ProfileMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    updatedAt: Date | null
  }

  export type ProfileCountAggregateOutputType = {
    id: number
    userId: number
    data: number
    updatedAt: number
    _all: number
  }


  export type ProfileAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type ProfileSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type ProfileMinAggregateInputType = {
    id?: true
    userId?: true
    updatedAt?: true
  }

  export type ProfileMaxAggregateInputType = {
    id?: true
    userId?: true
    updatedAt?: true
  }

  export type ProfileCountAggregateInputType = {
    id?: true
    userId?: true
    data?: true
    updatedAt?: true
    _all?: true
  }

  export type ProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profile to aggregate.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Profiles
    **/
    _count?: true | ProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfileMaxAggregateInputType
  }

  export type GetProfileAggregateType<T extends ProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfile[P]>
      : GetScalarType<T[P], AggregateProfile[P]>
  }




  export type ProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileWhereInput
    orderBy?: ProfileOrderByWithAggregationInput | ProfileOrderByWithAggregationInput[]
    by: ProfileScalarFieldEnum[] | ProfileScalarFieldEnum
    having?: ProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfileCountAggregateInputType | true
    _avg?: ProfileAvgAggregateInputType
    _sum?: ProfileSumAggregateInputType
    _min?: ProfileMinAggregateInputType
    _max?: ProfileMaxAggregateInputType
  }

  export type ProfileGroupByOutputType = {
    id: number
    userId: number
    data: JsonValue
    updatedAt: Date
    _count: ProfileCountAggregateOutputType | null
    _avg: ProfileAvgAggregateOutputType | null
    _sum: ProfileSumAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  type GetProfileGroupByPayload<T extends ProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfileGroupByOutputType[P]>
            : GetScalarType<T[P], ProfileGroupByOutputType[P]>
        }
      >
    >


  export type ProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    data?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profile"]>

  export type ProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    data?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profile"]>

  export type ProfileSelectScalar = {
    id?: boolean
    userId?: boolean
    data?: boolean
    updatedAt?: boolean
  }

  export type ProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Profile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      data: Prisma.JsonValue
      updatedAt: Date
    }, ExtArgs["result"]["profile"]>
    composites: {}
  }

  type ProfileGetPayload<S extends boolean | null | undefined | ProfileDefaultArgs> = $Result.GetResult<Prisma.$ProfilePayload, S>

  type ProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProfileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProfileCountAggregateInputType | true
    }

  export interface ProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Profile'], meta: { name: 'Profile' } }
    /**
     * Find zero or one Profile that matches the filter.
     * @param {ProfileFindUniqueArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProfileFindUniqueArgs>(args: SelectSubset<T, ProfileFindUniqueArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Profile that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProfileFindUniqueOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, ProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Profile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindFirstArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProfileFindFirstArgs>(args?: SelectSubset<T, ProfileFindFirstArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Profile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindFirstOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, ProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Profiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Profiles
     * const profiles = await prisma.profile.findMany()
     * 
     * // Get first 10 Profiles
     * const profiles = await prisma.profile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const profileWithIdOnly = await prisma.profile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProfileFindManyArgs>(args?: SelectSubset<T, ProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Profile.
     * @param {ProfileCreateArgs} args - Arguments to create a Profile.
     * @example
     * // Create one Profile
     * const Profile = await prisma.profile.create({
     *   data: {
     *     // ... data to create a Profile
     *   }
     * })
     * 
     */
    create<T extends ProfileCreateArgs>(args: SelectSubset<T, ProfileCreateArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Profiles.
     * @param {ProfileCreateManyArgs} args - Arguments to create many Profiles.
     * @example
     * // Create many Profiles
     * const profile = await prisma.profile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProfileCreateManyArgs>(args?: SelectSubset<T, ProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Profiles and returns the data saved in the database.
     * @param {ProfileCreateManyAndReturnArgs} args - Arguments to create many Profiles.
     * @example
     * // Create many Profiles
     * const profile = await prisma.profile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Profiles and only return the `id`
     * const profileWithIdOnly = await prisma.profile.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, ProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Profile.
     * @param {ProfileDeleteArgs} args - Arguments to delete one Profile.
     * @example
     * // Delete one Profile
     * const Profile = await prisma.profile.delete({
     *   where: {
     *     // ... filter to delete one Profile
     *   }
     * })
     * 
     */
    delete<T extends ProfileDeleteArgs>(args: SelectSubset<T, ProfileDeleteArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Profile.
     * @param {ProfileUpdateArgs} args - Arguments to update one Profile.
     * @example
     * // Update one Profile
     * const profile = await prisma.profile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProfileUpdateArgs>(args: SelectSubset<T, ProfileUpdateArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Profiles.
     * @param {ProfileDeleteManyArgs} args - Arguments to filter Profiles to delete.
     * @example
     * // Delete a few Profiles
     * const { count } = await prisma.profile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProfileDeleteManyArgs>(args?: SelectSubset<T, ProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Profiles
     * const profile = await prisma.profile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProfileUpdateManyArgs>(args: SelectSubset<T, ProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Profile.
     * @param {ProfileUpsertArgs} args - Arguments to update or create a Profile.
     * @example
     * // Update or create a Profile
     * const profile = await prisma.profile.upsert({
     *   create: {
     *     // ... data to create a Profile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Profile we want to update
     *   }
     * })
     */
    upsert<T extends ProfileUpsertArgs>(args: SelectSubset<T, ProfileUpsertArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileCountArgs} args - Arguments to filter Profiles to count.
     * @example
     * // Count the number of Profiles
     * const count = await prisma.profile.count({
     *   where: {
     *     // ... the filter for the Profiles we want to count
     *   }
     * })
    **/
    count<T extends ProfileCountArgs>(
      args?: Subset<T, ProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfileAggregateArgs>(args: Subset<T, ProfileAggregateArgs>): Prisma.PrismaPromise<GetProfileAggregateType<T>>

    /**
     * Group by Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProfileGroupByArgs['orderBy'] }
        : { orderBy?: ProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Profile model
   */
  readonly fields: ProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Profile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Profile model
   */ 
  interface ProfileFieldRefs {
    readonly id: FieldRef<"Profile", 'Int'>
    readonly userId: FieldRef<"Profile", 'Int'>
    readonly data: FieldRef<"Profile", 'Json'>
    readonly updatedAt: FieldRef<"Profile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Profile findUnique
   */
  export type ProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile findUniqueOrThrow
   */
  export type ProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile findFirst
   */
  export type ProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile findFirstOrThrow
   */
  export type ProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile findMany
   */
  export type ProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profiles to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile create
   */
  export type ProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a Profile.
     */
    data: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
  }

  /**
   * Profile createMany
   */
  export type ProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Profiles.
     */
    data: ProfileCreateManyInput | ProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Profile createManyAndReturn
   */
  export type ProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Profiles.
     */
    data: ProfileCreateManyInput | ProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Profile update
   */
  export type ProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a Profile.
     */
    data: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
    /**
     * Choose, which Profile to update.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile updateMany
   */
  export type ProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Profiles.
     */
    data: XOR<ProfileUpdateManyMutationInput, ProfileUncheckedUpdateManyInput>
    /**
     * Filter which Profiles to update
     */
    where?: ProfileWhereInput
  }

  /**
   * Profile upsert
   */
  export type ProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the Profile to update in case it exists.
     */
    where: ProfileWhereUniqueInput
    /**
     * In case the Profile found by the `where` argument doesn't exist, create a new Profile with this data.
     */
    create: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
    /**
     * In case the Profile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
  }

  /**
   * Profile delete
   */
  export type ProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter which Profile to delete.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile deleteMany
   */
  export type ProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profiles to delete
     */
    where?: ProfileWhereInput
  }

  /**
   * Profile without action
   */
  export type ProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
  }


  /**
   * Model Job
   */

  export type AggregateJob = {
    _count: JobCountAggregateOutputType | null
    _avg: JobAvgAggregateOutputType | null
    _sum: JobSumAggregateOutputType | null
    _min: JobMinAggregateOutputType | null
    _max: JobMaxAggregateOutputType | null
  }

  export type JobAvgAggregateOutputType = {
    userId: number | null
    priority: number | null
    attempts: number | null
    maxAttempts: number | null
  }

  export type JobSumAggregateOutputType = {
    userId: number | null
    priority: number | null
    attempts: number | null
    maxAttempts: number | null
  }

  export type JobMinAggregateOutputType = {
    id: string | null
    userId: number | null
    status: $Enums.JobStatus | null
    priority: number | null
    attempts: number | null
    maxAttempts: number | null
    resumeText: string | null
    jobDescription: string | null
    aiMode: string | null
    matchMode: string | null
    error: string | null
    createdAt: Date | null
    updatedAt: Date | null
    startedAt: Date | null
    completedAt: Date | null
    company: string | null
    jobUrl: string | null
    role: string | null
  }

  export type JobMaxAggregateOutputType = {
    id: string | null
    userId: number | null
    status: $Enums.JobStatus | null
    priority: number | null
    attempts: number | null
    maxAttempts: number | null
    resumeText: string | null
    jobDescription: string | null
    aiMode: string | null
    matchMode: string | null
    error: string | null
    createdAt: Date | null
    updatedAt: Date | null
    startedAt: Date | null
    completedAt: Date | null
    company: string | null
    jobUrl: string | null
    role: string | null
  }

  export type JobCountAggregateOutputType = {
    id: number
    userId: number
    status: number
    priority: number
    attempts: number
    maxAttempts: number
    resumeText: number
    jobDescription: number
    aiMode: number
    matchMode: number
    error: number
    diagnostics: number
    processingLog: number
    metadata: number
    createdAt: number
    updatedAt: number
    startedAt: number
    completedAt: number
    company: number
    jobUrl: number
    role: number
    _all: number
  }


  export type JobAvgAggregateInputType = {
    userId?: true
    priority?: true
    attempts?: true
    maxAttempts?: true
  }

  export type JobSumAggregateInputType = {
    userId?: true
    priority?: true
    attempts?: true
    maxAttempts?: true
  }

  export type JobMinAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    priority?: true
    attempts?: true
    maxAttempts?: true
    resumeText?: true
    jobDescription?: true
    aiMode?: true
    matchMode?: true
    error?: true
    createdAt?: true
    updatedAt?: true
    startedAt?: true
    completedAt?: true
    company?: true
    jobUrl?: true
    role?: true
  }

  export type JobMaxAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    priority?: true
    attempts?: true
    maxAttempts?: true
    resumeText?: true
    jobDescription?: true
    aiMode?: true
    matchMode?: true
    error?: true
    createdAt?: true
    updatedAt?: true
    startedAt?: true
    completedAt?: true
    company?: true
    jobUrl?: true
    role?: true
  }

  export type JobCountAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    priority?: true
    attempts?: true
    maxAttempts?: true
    resumeText?: true
    jobDescription?: true
    aiMode?: true
    matchMode?: true
    error?: true
    diagnostics?: true
    processingLog?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    startedAt?: true
    completedAt?: true
    company?: true
    jobUrl?: true
    role?: true
    _all?: true
  }

  export type JobAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Job to aggregate.
     */
    where?: JobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jobs to fetch.
     */
    orderBy?: JobOrderByWithRelationInput | JobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Jobs
    **/
    _count?: true | JobCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JobAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JobSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobMaxAggregateInputType
  }

  export type GetJobAggregateType<T extends JobAggregateArgs> = {
        [P in keyof T & keyof AggregateJob]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJob[P]>
      : GetScalarType<T[P], AggregateJob[P]>
  }




  export type JobGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobWhereInput
    orderBy?: JobOrderByWithAggregationInput | JobOrderByWithAggregationInput[]
    by: JobScalarFieldEnum[] | JobScalarFieldEnum
    having?: JobScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobCountAggregateInputType | true
    _avg?: JobAvgAggregateInputType
    _sum?: JobSumAggregateInputType
    _min?: JobMinAggregateInputType
    _max?: JobMaxAggregateInputType
  }

  export type JobGroupByOutputType = {
    id: string
    userId: number | null
    status: $Enums.JobStatus
    priority: number
    attempts: number
    maxAttempts: number
    resumeText: string | null
    jobDescription: string
    aiMode: string | null
    matchMode: string | null
    error: string | null
    diagnostics: JsonValue | null
    processingLog: JsonValue[]
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    startedAt: Date | null
    completedAt: Date | null
    company: string | null
    jobUrl: string | null
    role: string | null
    _count: JobCountAggregateOutputType | null
    _avg: JobAvgAggregateOutputType | null
    _sum: JobSumAggregateOutputType | null
    _min: JobMinAggregateOutputType | null
    _max: JobMaxAggregateOutputType | null
  }

  type GetJobGroupByPayload<T extends JobGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JobGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobGroupByOutputType[P]>
            : GetScalarType<T[P], JobGroupByOutputType[P]>
        }
      >
    >


  export type JobSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    status?: boolean
    priority?: boolean
    attempts?: boolean
    maxAttempts?: boolean
    resumeText?: boolean
    jobDescription?: boolean
    aiMode?: boolean
    matchMode?: boolean
    error?: boolean
    diagnostics?: boolean
    processingLog?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
    company?: boolean
    jobUrl?: boolean
    role?: boolean
    artifacts?: boolean | Job$artifactsArgs<ExtArgs>
    embeddings?: boolean | Job$embeddingsArgs<ExtArgs>
    user?: boolean | Job$userArgs<ExtArgs>
    _count?: boolean | JobCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["job"]>

  export type JobSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    status?: boolean
    priority?: boolean
    attempts?: boolean
    maxAttempts?: boolean
    resumeText?: boolean
    jobDescription?: boolean
    aiMode?: boolean
    matchMode?: boolean
    error?: boolean
    diagnostics?: boolean
    processingLog?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
    company?: boolean
    jobUrl?: boolean
    role?: boolean
    user?: boolean | Job$userArgs<ExtArgs>
  }, ExtArgs["result"]["job"]>

  export type JobSelectScalar = {
    id?: boolean
    userId?: boolean
    status?: boolean
    priority?: boolean
    attempts?: boolean
    maxAttempts?: boolean
    resumeText?: boolean
    jobDescription?: boolean
    aiMode?: boolean
    matchMode?: boolean
    error?: boolean
    diagnostics?: boolean
    processingLog?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
    company?: boolean
    jobUrl?: boolean
    role?: boolean
  }

  export type JobInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    artifacts?: boolean | Job$artifactsArgs<ExtArgs>
    embeddings?: boolean | Job$embeddingsArgs<ExtArgs>
    user?: boolean | Job$userArgs<ExtArgs>
    _count?: boolean | JobCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type JobIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Job$userArgs<ExtArgs>
  }

  export type $JobPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Job"
    objects: {
      artifacts: Prisma.$ArtifactPayload<ExtArgs>[]
      embeddings: Prisma.$EmbeddingPayload<ExtArgs>[]
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: number | null
      status: $Enums.JobStatus
      priority: number
      attempts: number
      maxAttempts: number
      resumeText: string | null
      jobDescription: string
      aiMode: string | null
      matchMode: string | null
      error: string | null
      diagnostics: Prisma.JsonValue | null
      processingLog: Prisma.JsonValue[]
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
      startedAt: Date | null
      completedAt: Date | null
      company: string | null
      jobUrl: string | null
      role: string | null
    }, ExtArgs["result"]["job"]>
    composites: {}
  }

  type JobGetPayload<S extends boolean | null | undefined | JobDefaultArgs> = $Result.GetResult<Prisma.$JobPayload, S>

  type JobCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<JobFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: JobCountAggregateInputType | true
    }

  export interface JobDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Job'], meta: { name: 'Job' } }
    /**
     * Find zero or one Job that matches the filter.
     * @param {JobFindUniqueArgs} args - Arguments to find a Job
     * @example
     * // Get one Job
     * const job = await prisma.job.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JobFindUniqueArgs>(args: SelectSubset<T, JobFindUniqueArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Job that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {JobFindUniqueOrThrowArgs} args - Arguments to find a Job
     * @example
     * // Get one Job
     * const job = await prisma.job.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JobFindUniqueOrThrowArgs>(args: SelectSubset<T, JobFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Job that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobFindFirstArgs} args - Arguments to find a Job
     * @example
     * // Get one Job
     * const job = await prisma.job.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JobFindFirstArgs>(args?: SelectSubset<T, JobFindFirstArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Job that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobFindFirstOrThrowArgs} args - Arguments to find a Job
     * @example
     * // Get one Job
     * const job = await prisma.job.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JobFindFirstOrThrowArgs>(args?: SelectSubset<T, JobFindFirstOrThrowArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Jobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Jobs
     * const jobs = await prisma.job.findMany()
     * 
     * // Get first 10 Jobs
     * const jobs = await prisma.job.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jobWithIdOnly = await prisma.job.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JobFindManyArgs>(args?: SelectSubset<T, JobFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Job.
     * @param {JobCreateArgs} args - Arguments to create a Job.
     * @example
     * // Create one Job
     * const Job = await prisma.job.create({
     *   data: {
     *     // ... data to create a Job
     *   }
     * })
     * 
     */
    create<T extends JobCreateArgs>(args: SelectSubset<T, JobCreateArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Jobs.
     * @param {JobCreateManyArgs} args - Arguments to create many Jobs.
     * @example
     * // Create many Jobs
     * const job = await prisma.job.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JobCreateManyArgs>(args?: SelectSubset<T, JobCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Jobs and returns the data saved in the database.
     * @param {JobCreateManyAndReturnArgs} args - Arguments to create many Jobs.
     * @example
     * // Create many Jobs
     * const job = await prisma.job.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Jobs and only return the `id`
     * const jobWithIdOnly = await prisma.job.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JobCreateManyAndReturnArgs>(args?: SelectSubset<T, JobCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Job.
     * @param {JobDeleteArgs} args - Arguments to delete one Job.
     * @example
     * // Delete one Job
     * const Job = await prisma.job.delete({
     *   where: {
     *     // ... filter to delete one Job
     *   }
     * })
     * 
     */
    delete<T extends JobDeleteArgs>(args: SelectSubset<T, JobDeleteArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Job.
     * @param {JobUpdateArgs} args - Arguments to update one Job.
     * @example
     * // Update one Job
     * const job = await prisma.job.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JobUpdateArgs>(args: SelectSubset<T, JobUpdateArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Jobs.
     * @param {JobDeleteManyArgs} args - Arguments to filter Jobs to delete.
     * @example
     * // Delete a few Jobs
     * const { count } = await prisma.job.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JobDeleteManyArgs>(args?: SelectSubset<T, JobDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Jobs
     * const job = await prisma.job.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JobUpdateManyArgs>(args: SelectSubset<T, JobUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Job.
     * @param {JobUpsertArgs} args - Arguments to update or create a Job.
     * @example
     * // Update or create a Job
     * const job = await prisma.job.upsert({
     *   create: {
     *     // ... data to create a Job
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Job we want to update
     *   }
     * })
     */
    upsert<T extends JobUpsertArgs>(args: SelectSubset<T, JobUpsertArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobCountArgs} args - Arguments to filter Jobs to count.
     * @example
     * // Count the number of Jobs
     * const count = await prisma.job.count({
     *   where: {
     *     // ... the filter for the Jobs we want to count
     *   }
     * })
    **/
    count<T extends JobCountArgs>(
      args?: Subset<T, JobCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Job.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobAggregateArgs>(args: Subset<T, JobAggregateArgs>): Prisma.PrismaPromise<GetJobAggregateType<T>>

    /**
     * Group by Job.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JobGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JobGroupByArgs['orderBy'] }
        : { orderBy?: JobGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JobGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Job model
   */
  readonly fields: JobFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Job.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JobClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    artifacts<T extends Job$artifactsArgs<ExtArgs> = {}>(args?: Subset<T, Job$artifactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArtifactPayload<ExtArgs>, T, "findMany"> | Null>
    embeddings<T extends Job$embeddingsArgs<ExtArgs> = {}>(args?: Subset<T, Job$embeddingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmbeddingPayload<ExtArgs>, T, "findMany"> | Null>
    user<T extends Job$userArgs<ExtArgs> = {}>(args?: Subset<T, Job$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Job model
   */ 
  interface JobFieldRefs {
    readonly id: FieldRef<"Job", 'String'>
    readonly userId: FieldRef<"Job", 'Int'>
    readonly status: FieldRef<"Job", 'JobStatus'>
    readonly priority: FieldRef<"Job", 'Int'>
    readonly attempts: FieldRef<"Job", 'Int'>
    readonly maxAttempts: FieldRef<"Job", 'Int'>
    readonly resumeText: FieldRef<"Job", 'String'>
    readonly jobDescription: FieldRef<"Job", 'String'>
    readonly aiMode: FieldRef<"Job", 'String'>
    readonly matchMode: FieldRef<"Job", 'String'>
    readonly error: FieldRef<"Job", 'String'>
    readonly diagnostics: FieldRef<"Job", 'Json'>
    readonly processingLog: FieldRef<"Job", 'Json[]'>
    readonly metadata: FieldRef<"Job", 'Json'>
    readonly createdAt: FieldRef<"Job", 'DateTime'>
    readonly updatedAt: FieldRef<"Job", 'DateTime'>
    readonly startedAt: FieldRef<"Job", 'DateTime'>
    readonly completedAt: FieldRef<"Job", 'DateTime'>
    readonly company: FieldRef<"Job", 'String'>
    readonly jobUrl: FieldRef<"Job", 'String'>
    readonly role: FieldRef<"Job", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Job findUnique
   */
  export type JobFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    /**
     * Filter, which Job to fetch.
     */
    where: JobWhereUniqueInput
  }

  /**
   * Job findUniqueOrThrow
   */
  export type JobFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    /**
     * Filter, which Job to fetch.
     */
    where: JobWhereUniqueInput
  }

  /**
   * Job findFirst
   */
  export type JobFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    /**
     * Filter, which Job to fetch.
     */
    where?: JobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jobs to fetch.
     */
    orderBy?: JobOrderByWithRelationInput | JobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Jobs.
     */
    cursor?: JobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Jobs.
     */
    distinct?: JobScalarFieldEnum | JobScalarFieldEnum[]
  }

  /**
   * Job findFirstOrThrow
   */
  export type JobFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    /**
     * Filter, which Job to fetch.
     */
    where?: JobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jobs to fetch.
     */
    orderBy?: JobOrderByWithRelationInput | JobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Jobs.
     */
    cursor?: JobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Jobs.
     */
    distinct?: JobScalarFieldEnum | JobScalarFieldEnum[]
  }

  /**
   * Job findMany
   */
  export type JobFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    /**
     * Filter, which Jobs to fetch.
     */
    where?: JobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jobs to fetch.
     */
    orderBy?: JobOrderByWithRelationInput | JobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Jobs.
     */
    cursor?: JobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jobs.
     */
    skip?: number
    distinct?: JobScalarFieldEnum | JobScalarFieldEnum[]
  }

  /**
   * Job create
   */
  export type JobCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    /**
     * The data needed to create a Job.
     */
    data: XOR<JobCreateInput, JobUncheckedCreateInput>
  }

  /**
   * Job createMany
   */
  export type JobCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Jobs.
     */
    data: JobCreateManyInput | JobCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Job createManyAndReturn
   */
  export type JobCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Jobs.
     */
    data: JobCreateManyInput | JobCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Job update
   */
  export type JobUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    /**
     * The data needed to update a Job.
     */
    data: XOR<JobUpdateInput, JobUncheckedUpdateInput>
    /**
     * Choose, which Job to update.
     */
    where: JobWhereUniqueInput
  }

  /**
   * Job updateMany
   */
  export type JobUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Jobs.
     */
    data: XOR<JobUpdateManyMutationInput, JobUncheckedUpdateManyInput>
    /**
     * Filter which Jobs to update
     */
    where?: JobWhereInput
  }

  /**
   * Job upsert
   */
  export type JobUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    /**
     * The filter to search for the Job to update in case it exists.
     */
    where: JobWhereUniqueInput
    /**
     * In case the Job found by the `where` argument doesn't exist, create a new Job with this data.
     */
    create: XOR<JobCreateInput, JobUncheckedCreateInput>
    /**
     * In case the Job was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JobUpdateInput, JobUncheckedUpdateInput>
  }

  /**
   * Job delete
   */
  export type JobDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    /**
     * Filter which Job to delete.
     */
    where: JobWhereUniqueInput
  }

  /**
   * Job deleteMany
   */
  export type JobDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Jobs to delete
     */
    where?: JobWhereInput
  }

  /**
   * Job.artifacts
   */
  export type Job$artifactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artifact
     */
    select?: ArtifactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactInclude<ExtArgs> | null
    where?: ArtifactWhereInput
    orderBy?: ArtifactOrderByWithRelationInput | ArtifactOrderByWithRelationInput[]
    cursor?: ArtifactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ArtifactScalarFieldEnum | ArtifactScalarFieldEnum[]
  }

  /**
   * Job.embeddings
   */
  export type Job$embeddingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Embedding
     */
    select?: EmbeddingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmbeddingInclude<ExtArgs> | null
    where?: EmbeddingWhereInput
    orderBy?: EmbeddingOrderByWithRelationInput | EmbeddingOrderByWithRelationInput[]
    cursor?: EmbeddingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmbeddingScalarFieldEnum | EmbeddingScalarFieldEnum[]
  }

  /**
   * Job.user
   */
  export type Job$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Job without action
   */
  export type JobDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
  }


  /**
   * Model Artifact
   */

  export type AggregateArtifact = {
    _count: ArtifactCountAggregateOutputType | null
    _avg: ArtifactAvgAggregateOutputType | null
    _sum: ArtifactSumAggregateOutputType | null
    _min: ArtifactMinAggregateOutputType | null
    _max: ArtifactMaxAggregateOutputType | null
  }

  export type ArtifactAvgAggregateOutputType = {
    version: number | null
  }

  export type ArtifactSumAggregateOutputType = {
    version: number | null
  }

  export type ArtifactMinAggregateOutputType = {
    id: string | null
    jobId: string | null
    type: $Enums.ArtifactType | null
    version: number | null
    content: Buffer | null
    validated: boolean | null
    createdAt: Date | null
  }

  export type ArtifactMaxAggregateOutputType = {
    id: string | null
    jobId: string | null
    type: $Enums.ArtifactType | null
    version: number | null
    content: Buffer | null
    validated: boolean | null
    createdAt: Date | null
  }

  export type ArtifactCountAggregateOutputType = {
    id: number
    jobId: number
    type: number
    version: number
    content: number
    metadata: number
    schema: number
    validated: number
    createdAt: number
    _all: number
  }


  export type ArtifactAvgAggregateInputType = {
    version?: true
  }

  export type ArtifactSumAggregateInputType = {
    version?: true
  }

  export type ArtifactMinAggregateInputType = {
    id?: true
    jobId?: true
    type?: true
    version?: true
    content?: true
    validated?: true
    createdAt?: true
  }

  export type ArtifactMaxAggregateInputType = {
    id?: true
    jobId?: true
    type?: true
    version?: true
    content?: true
    validated?: true
    createdAt?: true
  }

  export type ArtifactCountAggregateInputType = {
    id?: true
    jobId?: true
    type?: true
    version?: true
    content?: true
    metadata?: true
    schema?: true
    validated?: true
    createdAt?: true
    _all?: true
  }

  export type ArtifactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Artifact to aggregate.
     */
    where?: ArtifactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Artifacts to fetch.
     */
    orderBy?: ArtifactOrderByWithRelationInput | ArtifactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ArtifactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Artifacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Artifacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Artifacts
    **/
    _count?: true | ArtifactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ArtifactAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ArtifactSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ArtifactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ArtifactMaxAggregateInputType
  }

  export type GetArtifactAggregateType<T extends ArtifactAggregateArgs> = {
        [P in keyof T & keyof AggregateArtifact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateArtifact[P]>
      : GetScalarType<T[P], AggregateArtifact[P]>
  }




  export type ArtifactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArtifactWhereInput
    orderBy?: ArtifactOrderByWithAggregationInput | ArtifactOrderByWithAggregationInput[]
    by: ArtifactScalarFieldEnum[] | ArtifactScalarFieldEnum
    having?: ArtifactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ArtifactCountAggregateInputType | true
    _avg?: ArtifactAvgAggregateInputType
    _sum?: ArtifactSumAggregateInputType
    _min?: ArtifactMinAggregateInputType
    _max?: ArtifactMaxAggregateInputType
  }

  export type ArtifactGroupByOutputType = {
    id: string
    jobId: string
    type: $Enums.ArtifactType
    version: number
    content: Buffer
    metadata: JsonValue | null
    schema: JsonValue | null
    validated: boolean
    createdAt: Date
    _count: ArtifactCountAggregateOutputType | null
    _avg: ArtifactAvgAggregateOutputType | null
    _sum: ArtifactSumAggregateOutputType | null
    _min: ArtifactMinAggregateOutputType | null
    _max: ArtifactMaxAggregateOutputType | null
  }

  type GetArtifactGroupByPayload<T extends ArtifactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ArtifactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ArtifactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ArtifactGroupByOutputType[P]>
            : GetScalarType<T[P], ArtifactGroupByOutputType[P]>
        }
      >
    >


  export type ArtifactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobId?: boolean
    type?: boolean
    version?: boolean
    content?: boolean
    metadata?: boolean
    schema?: boolean
    validated?: boolean
    createdAt?: boolean
    job?: boolean | JobDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["artifact"]>

  export type ArtifactSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobId?: boolean
    type?: boolean
    version?: boolean
    content?: boolean
    metadata?: boolean
    schema?: boolean
    validated?: boolean
    createdAt?: boolean
    job?: boolean | JobDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["artifact"]>

  export type ArtifactSelectScalar = {
    id?: boolean
    jobId?: boolean
    type?: boolean
    version?: boolean
    content?: boolean
    metadata?: boolean
    schema?: boolean
    validated?: boolean
    createdAt?: boolean
  }

  export type ArtifactInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job?: boolean | JobDefaultArgs<ExtArgs>
  }
  export type ArtifactIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job?: boolean | JobDefaultArgs<ExtArgs>
  }

  export type $ArtifactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Artifact"
    objects: {
      job: Prisma.$JobPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      jobId: string
      type: $Enums.ArtifactType
      version: number
      content: Buffer
      metadata: Prisma.JsonValue | null
      schema: Prisma.JsonValue | null
      validated: boolean
      createdAt: Date
    }, ExtArgs["result"]["artifact"]>
    composites: {}
  }

  type ArtifactGetPayload<S extends boolean | null | undefined | ArtifactDefaultArgs> = $Result.GetResult<Prisma.$ArtifactPayload, S>

  type ArtifactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ArtifactFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ArtifactCountAggregateInputType | true
    }

  export interface ArtifactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Artifact'], meta: { name: 'Artifact' } }
    /**
     * Find zero or one Artifact that matches the filter.
     * @param {ArtifactFindUniqueArgs} args - Arguments to find a Artifact
     * @example
     * // Get one Artifact
     * const artifact = await prisma.artifact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ArtifactFindUniqueArgs>(args: SelectSubset<T, ArtifactFindUniqueArgs<ExtArgs>>): Prisma__ArtifactClient<$Result.GetResult<Prisma.$ArtifactPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Artifact that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ArtifactFindUniqueOrThrowArgs} args - Arguments to find a Artifact
     * @example
     * // Get one Artifact
     * const artifact = await prisma.artifact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ArtifactFindUniqueOrThrowArgs>(args: SelectSubset<T, ArtifactFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ArtifactClient<$Result.GetResult<Prisma.$ArtifactPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Artifact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtifactFindFirstArgs} args - Arguments to find a Artifact
     * @example
     * // Get one Artifact
     * const artifact = await prisma.artifact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ArtifactFindFirstArgs>(args?: SelectSubset<T, ArtifactFindFirstArgs<ExtArgs>>): Prisma__ArtifactClient<$Result.GetResult<Prisma.$ArtifactPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Artifact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtifactFindFirstOrThrowArgs} args - Arguments to find a Artifact
     * @example
     * // Get one Artifact
     * const artifact = await prisma.artifact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ArtifactFindFirstOrThrowArgs>(args?: SelectSubset<T, ArtifactFindFirstOrThrowArgs<ExtArgs>>): Prisma__ArtifactClient<$Result.GetResult<Prisma.$ArtifactPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Artifacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtifactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Artifacts
     * const artifacts = await prisma.artifact.findMany()
     * 
     * // Get first 10 Artifacts
     * const artifacts = await prisma.artifact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const artifactWithIdOnly = await prisma.artifact.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ArtifactFindManyArgs>(args?: SelectSubset<T, ArtifactFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArtifactPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Artifact.
     * @param {ArtifactCreateArgs} args - Arguments to create a Artifact.
     * @example
     * // Create one Artifact
     * const Artifact = await prisma.artifact.create({
     *   data: {
     *     // ... data to create a Artifact
     *   }
     * })
     * 
     */
    create<T extends ArtifactCreateArgs>(args: SelectSubset<T, ArtifactCreateArgs<ExtArgs>>): Prisma__ArtifactClient<$Result.GetResult<Prisma.$ArtifactPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Artifacts.
     * @param {ArtifactCreateManyArgs} args - Arguments to create many Artifacts.
     * @example
     * // Create many Artifacts
     * const artifact = await prisma.artifact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ArtifactCreateManyArgs>(args?: SelectSubset<T, ArtifactCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Artifacts and returns the data saved in the database.
     * @param {ArtifactCreateManyAndReturnArgs} args - Arguments to create many Artifacts.
     * @example
     * // Create many Artifacts
     * const artifact = await prisma.artifact.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Artifacts and only return the `id`
     * const artifactWithIdOnly = await prisma.artifact.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ArtifactCreateManyAndReturnArgs>(args?: SelectSubset<T, ArtifactCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArtifactPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Artifact.
     * @param {ArtifactDeleteArgs} args - Arguments to delete one Artifact.
     * @example
     * // Delete one Artifact
     * const Artifact = await prisma.artifact.delete({
     *   where: {
     *     // ... filter to delete one Artifact
     *   }
     * })
     * 
     */
    delete<T extends ArtifactDeleteArgs>(args: SelectSubset<T, ArtifactDeleteArgs<ExtArgs>>): Prisma__ArtifactClient<$Result.GetResult<Prisma.$ArtifactPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Artifact.
     * @param {ArtifactUpdateArgs} args - Arguments to update one Artifact.
     * @example
     * // Update one Artifact
     * const artifact = await prisma.artifact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ArtifactUpdateArgs>(args: SelectSubset<T, ArtifactUpdateArgs<ExtArgs>>): Prisma__ArtifactClient<$Result.GetResult<Prisma.$ArtifactPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Artifacts.
     * @param {ArtifactDeleteManyArgs} args - Arguments to filter Artifacts to delete.
     * @example
     * // Delete a few Artifacts
     * const { count } = await prisma.artifact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ArtifactDeleteManyArgs>(args?: SelectSubset<T, ArtifactDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Artifacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtifactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Artifacts
     * const artifact = await prisma.artifact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ArtifactUpdateManyArgs>(args: SelectSubset<T, ArtifactUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Artifact.
     * @param {ArtifactUpsertArgs} args - Arguments to update or create a Artifact.
     * @example
     * // Update or create a Artifact
     * const artifact = await prisma.artifact.upsert({
     *   create: {
     *     // ... data to create a Artifact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Artifact we want to update
     *   }
     * })
     */
    upsert<T extends ArtifactUpsertArgs>(args: SelectSubset<T, ArtifactUpsertArgs<ExtArgs>>): Prisma__ArtifactClient<$Result.GetResult<Prisma.$ArtifactPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Artifacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtifactCountArgs} args - Arguments to filter Artifacts to count.
     * @example
     * // Count the number of Artifacts
     * const count = await prisma.artifact.count({
     *   where: {
     *     // ... the filter for the Artifacts we want to count
     *   }
     * })
    **/
    count<T extends ArtifactCountArgs>(
      args?: Subset<T, ArtifactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ArtifactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Artifact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtifactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ArtifactAggregateArgs>(args: Subset<T, ArtifactAggregateArgs>): Prisma.PrismaPromise<GetArtifactAggregateType<T>>

    /**
     * Group by Artifact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtifactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ArtifactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ArtifactGroupByArgs['orderBy'] }
        : { orderBy?: ArtifactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ArtifactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetArtifactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Artifact model
   */
  readonly fields: ArtifactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Artifact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ArtifactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    job<T extends JobDefaultArgs<ExtArgs> = {}>(args?: Subset<T, JobDefaultArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Artifact model
   */ 
  interface ArtifactFieldRefs {
    readonly id: FieldRef<"Artifact", 'String'>
    readonly jobId: FieldRef<"Artifact", 'String'>
    readonly type: FieldRef<"Artifact", 'ArtifactType'>
    readonly version: FieldRef<"Artifact", 'Int'>
    readonly content: FieldRef<"Artifact", 'Bytes'>
    readonly metadata: FieldRef<"Artifact", 'Json'>
    readonly schema: FieldRef<"Artifact", 'Json'>
    readonly validated: FieldRef<"Artifact", 'Boolean'>
    readonly createdAt: FieldRef<"Artifact", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Artifact findUnique
   */
  export type ArtifactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artifact
     */
    select?: ArtifactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactInclude<ExtArgs> | null
    /**
     * Filter, which Artifact to fetch.
     */
    where: ArtifactWhereUniqueInput
  }

  /**
   * Artifact findUniqueOrThrow
   */
  export type ArtifactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artifact
     */
    select?: ArtifactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactInclude<ExtArgs> | null
    /**
     * Filter, which Artifact to fetch.
     */
    where: ArtifactWhereUniqueInput
  }

  /**
   * Artifact findFirst
   */
  export type ArtifactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artifact
     */
    select?: ArtifactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactInclude<ExtArgs> | null
    /**
     * Filter, which Artifact to fetch.
     */
    where?: ArtifactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Artifacts to fetch.
     */
    orderBy?: ArtifactOrderByWithRelationInput | ArtifactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Artifacts.
     */
    cursor?: ArtifactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Artifacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Artifacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Artifacts.
     */
    distinct?: ArtifactScalarFieldEnum | ArtifactScalarFieldEnum[]
  }

  /**
   * Artifact findFirstOrThrow
   */
  export type ArtifactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artifact
     */
    select?: ArtifactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactInclude<ExtArgs> | null
    /**
     * Filter, which Artifact to fetch.
     */
    where?: ArtifactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Artifacts to fetch.
     */
    orderBy?: ArtifactOrderByWithRelationInput | ArtifactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Artifacts.
     */
    cursor?: ArtifactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Artifacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Artifacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Artifacts.
     */
    distinct?: ArtifactScalarFieldEnum | ArtifactScalarFieldEnum[]
  }

  /**
   * Artifact findMany
   */
  export type ArtifactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artifact
     */
    select?: ArtifactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactInclude<ExtArgs> | null
    /**
     * Filter, which Artifacts to fetch.
     */
    where?: ArtifactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Artifacts to fetch.
     */
    orderBy?: ArtifactOrderByWithRelationInput | ArtifactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Artifacts.
     */
    cursor?: ArtifactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Artifacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Artifacts.
     */
    skip?: number
    distinct?: ArtifactScalarFieldEnum | ArtifactScalarFieldEnum[]
  }

  /**
   * Artifact create
   */
  export type ArtifactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artifact
     */
    select?: ArtifactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactInclude<ExtArgs> | null
    /**
     * The data needed to create a Artifact.
     */
    data: XOR<ArtifactCreateInput, ArtifactUncheckedCreateInput>
  }

  /**
   * Artifact createMany
   */
  export type ArtifactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Artifacts.
     */
    data: ArtifactCreateManyInput | ArtifactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Artifact createManyAndReturn
   */
  export type ArtifactCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artifact
     */
    select?: ArtifactSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Artifacts.
     */
    data: ArtifactCreateManyInput | ArtifactCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Artifact update
   */
  export type ArtifactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artifact
     */
    select?: ArtifactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactInclude<ExtArgs> | null
    /**
     * The data needed to update a Artifact.
     */
    data: XOR<ArtifactUpdateInput, ArtifactUncheckedUpdateInput>
    /**
     * Choose, which Artifact to update.
     */
    where: ArtifactWhereUniqueInput
  }

  /**
   * Artifact updateMany
   */
  export type ArtifactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Artifacts.
     */
    data: XOR<ArtifactUpdateManyMutationInput, ArtifactUncheckedUpdateManyInput>
    /**
     * Filter which Artifacts to update
     */
    where?: ArtifactWhereInput
  }

  /**
   * Artifact upsert
   */
  export type ArtifactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artifact
     */
    select?: ArtifactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactInclude<ExtArgs> | null
    /**
     * The filter to search for the Artifact to update in case it exists.
     */
    where: ArtifactWhereUniqueInput
    /**
     * In case the Artifact found by the `where` argument doesn't exist, create a new Artifact with this data.
     */
    create: XOR<ArtifactCreateInput, ArtifactUncheckedCreateInput>
    /**
     * In case the Artifact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ArtifactUpdateInput, ArtifactUncheckedUpdateInput>
  }

  /**
   * Artifact delete
   */
  export type ArtifactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artifact
     */
    select?: ArtifactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactInclude<ExtArgs> | null
    /**
     * Filter which Artifact to delete.
     */
    where: ArtifactWhereUniqueInput
  }

  /**
   * Artifact deleteMany
   */
  export type ArtifactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Artifacts to delete
     */
    where?: ArtifactWhereInput
  }

  /**
   * Artifact without action
   */
  export type ArtifactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artifact
     */
    select?: ArtifactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactInclude<ExtArgs> | null
  }


  /**
   * Model Embedding
   */

  export type AggregateEmbedding = {
    _count: EmbeddingCountAggregateOutputType | null
    _avg: EmbeddingAvgAggregateOutputType | null
    _sum: EmbeddingSumAggregateOutputType | null
    _min: EmbeddingMinAggregateOutputType | null
    _max: EmbeddingMaxAggregateOutputType | null
  }

  export type EmbeddingAvgAggregateOutputType = {
    embedding: number | null
    relevance: number | null
  }

  export type EmbeddingSumAggregateOutputType = {
    embedding: number[]
    relevance: number | null
  }

  export type EmbeddingMinAggregateOutputType = {
    id: string | null
    jobId: string | null
    content: string | null
    contentType: $Enums.EmbeddingType | null
    relevance: number | null
    createdAt: Date | null
  }

  export type EmbeddingMaxAggregateOutputType = {
    id: string | null
    jobId: string | null
    content: string | null
    contentType: $Enums.EmbeddingType | null
    relevance: number | null
    createdAt: Date | null
  }

  export type EmbeddingCountAggregateOutputType = {
    id: number
    jobId: number
    content: number
    contentType: number
    embedding: number
    relevance: number
    createdAt: number
    _all: number
  }


  export type EmbeddingAvgAggregateInputType = {
    embedding?: true
    relevance?: true
  }

  export type EmbeddingSumAggregateInputType = {
    embedding?: true
    relevance?: true
  }

  export type EmbeddingMinAggregateInputType = {
    id?: true
    jobId?: true
    content?: true
    contentType?: true
    relevance?: true
    createdAt?: true
  }

  export type EmbeddingMaxAggregateInputType = {
    id?: true
    jobId?: true
    content?: true
    contentType?: true
    relevance?: true
    createdAt?: true
  }

  export type EmbeddingCountAggregateInputType = {
    id?: true
    jobId?: true
    content?: true
    contentType?: true
    embedding?: true
    relevance?: true
    createdAt?: true
    _all?: true
  }

  export type EmbeddingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Embedding to aggregate.
     */
    where?: EmbeddingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Embeddings to fetch.
     */
    orderBy?: EmbeddingOrderByWithRelationInput | EmbeddingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmbeddingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Embeddings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Embeddings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Embeddings
    **/
    _count?: true | EmbeddingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmbeddingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmbeddingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmbeddingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmbeddingMaxAggregateInputType
  }

  export type GetEmbeddingAggregateType<T extends EmbeddingAggregateArgs> = {
        [P in keyof T & keyof AggregateEmbedding]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmbedding[P]>
      : GetScalarType<T[P], AggregateEmbedding[P]>
  }




  export type EmbeddingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmbeddingWhereInput
    orderBy?: EmbeddingOrderByWithAggregationInput | EmbeddingOrderByWithAggregationInput[]
    by: EmbeddingScalarFieldEnum[] | EmbeddingScalarFieldEnum
    having?: EmbeddingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmbeddingCountAggregateInputType | true
    _avg?: EmbeddingAvgAggregateInputType
    _sum?: EmbeddingSumAggregateInputType
    _min?: EmbeddingMinAggregateInputType
    _max?: EmbeddingMaxAggregateInputType
  }

  export type EmbeddingGroupByOutputType = {
    id: string
    jobId: string
    content: string
    contentType: $Enums.EmbeddingType
    embedding: number[]
    relevance: number | null
    createdAt: Date
    _count: EmbeddingCountAggregateOutputType | null
    _avg: EmbeddingAvgAggregateOutputType | null
    _sum: EmbeddingSumAggregateOutputType | null
    _min: EmbeddingMinAggregateOutputType | null
    _max: EmbeddingMaxAggregateOutputType | null
  }

  type GetEmbeddingGroupByPayload<T extends EmbeddingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmbeddingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmbeddingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmbeddingGroupByOutputType[P]>
            : GetScalarType<T[P], EmbeddingGroupByOutputType[P]>
        }
      >
    >


  export type EmbeddingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobId?: boolean
    content?: boolean
    contentType?: boolean
    embedding?: boolean
    relevance?: boolean
    createdAt?: boolean
    job?: boolean | JobDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["embedding"]>

  export type EmbeddingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobId?: boolean
    content?: boolean
    contentType?: boolean
    embedding?: boolean
    relevance?: boolean
    createdAt?: boolean
    job?: boolean | JobDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["embedding"]>

  export type EmbeddingSelectScalar = {
    id?: boolean
    jobId?: boolean
    content?: boolean
    contentType?: boolean
    embedding?: boolean
    relevance?: boolean
    createdAt?: boolean
  }

  export type EmbeddingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job?: boolean | JobDefaultArgs<ExtArgs>
  }
  export type EmbeddingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job?: boolean | JobDefaultArgs<ExtArgs>
  }

  export type $EmbeddingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Embedding"
    objects: {
      job: Prisma.$JobPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      jobId: string
      content: string
      contentType: $Enums.EmbeddingType
      embedding: number[]
      relevance: number | null
      createdAt: Date
    }, ExtArgs["result"]["embedding"]>
    composites: {}
  }

  type EmbeddingGetPayload<S extends boolean | null | undefined | EmbeddingDefaultArgs> = $Result.GetResult<Prisma.$EmbeddingPayload, S>

  type EmbeddingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmbeddingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmbeddingCountAggregateInputType | true
    }

  export interface EmbeddingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Embedding'], meta: { name: 'Embedding' } }
    /**
     * Find zero or one Embedding that matches the filter.
     * @param {EmbeddingFindUniqueArgs} args - Arguments to find a Embedding
     * @example
     * // Get one Embedding
     * const embedding = await prisma.embedding.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmbeddingFindUniqueArgs>(args: SelectSubset<T, EmbeddingFindUniqueArgs<ExtArgs>>): Prisma__EmbeddingClient<$Result.GetResult<Prisma.$EmbeddingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Embedding that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EmbeddingFindUniqueOrThrowArgs} args - Arguments to find a Embedding
     * @example
     * // Get one Embedding
     * const embedding = await prisma.embedding.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmbeddingFindUniqueOrThrowArgs>(args: SelectSubset<T, EmbeddingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmbeddingClient<$Result.GetResult<Prisma.$EmbeddingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Embedding that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmbeddingFindFirstArgs} args - Arguments to find a Embedding
     * @example
     * // Get one Embedding
     * const embedding = await prisma.embedding.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmbeddingFindFirstArgs>(args?: SelectSubset<T, EmbeddingFindFirstArgs<ExtArgs>>): Prisma__EmbeddingClient<$Result.GetResult<Prisma.$EmbeddingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Embedding that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmbeddingFindFirstOrThrowArgs} args - Arguments to find a Embedding
     * @example
     * // Get one Embedding
     * const embedding = await prisma.embedding.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmbeddingFindFirstOrThrowArgs>(args?: SelectSubset<T, EmbeddingFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmbeddingClient<$Result.GetResult<Prisma.$EmbeddingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Embeddings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmbeddingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Embeddings
     * const embeddings = await prisma.embedding.findMany()
     * 
     * // Get first 10 Embeddings
     * const embeddings = await prisma.embedding.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const embeddingWithIdOnly = await prisma.embedding.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmbeddingFindManyArgs>(args?: SelectSubset<T, EmbeddingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmbeddingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Embedding.
     * @param {EmbeddingCreateArgs} args - Arguments to create a Embedding.
     * @example
     * // Create one Embedding
     * const Embedding = await prisma.embedding.create({
     *   data: {
     *     // ... data to create a Embedding
     *   }
     * })
     * 
     */
    create<T extends EmbeddingCreateArgs>(args: SelectSubset<T, EmbeddingCreateArgs<ExtArgs>>): Prisma__EmbeddingClient<$Result.GetResult<Prisma.$EmbeddingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Embeddings.
     * @param {EmbeddingCreateManyArgs} args - Arguments to create many Embeddings.
     * @example
     * // Create many Embeddings
     * const embedding = await prisma.embedding.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmbeddingCreateManyArgs>(args?: SelectSubset<T, EmbeddingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Embeddings and returns the data saved in the database.
     * @param {EmbeddingCreateManyAndReturnArgs} args - Arguments to create many Embeddings.
     * @example
     * // Create many Embeddings
     * const embedding = await prisma.embedding.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Embeddings and only return the `id`
     * const embeddingWithIdOnly = await prisma.embedding.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmbeddingCreateManyAndReturnArgs>(args?: SelectSubset<T, EmbeddingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmbeddingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Embedding.
     * @param {EmbeddingDeleteArgs} args - Arguments to delete one Embedding.
     * @example
     * // Delete one Embedding
     * const Embedding = await prisma.embedding.delete({
     *   where: {
     *     // ... filter to delete one Embedding
     *   }
     * })
     * 
     */
    delete<T extends EmbeddingDeleteArgs>(args: SelectSubset<T, EmbeddingDeleteArgs<ExtArgs>>): Prisma__EmbeddingClient<$Result.GetResult<Prisma.$EmbeddingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Embedding.
     * @param {EmbeddingUpdateArgs} args - Arguments to update one Embedding.
     * @example
     * // Update one Embedding
     * const embedding = await prisma.embedding.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmbeddingUpdateArgs>(args: SelectSubset<T, EmbeddingUpdateArgs<ExtArgs>>): Prisma__EmbeddingClient<$Result.GetResult<Prisma.$EmbeddingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Embeddings.
     * @param {EmbeddingDeleteManyArgs} args - Arguments to filter Embeddings to delete.
     * @example
     * // Delete a few Embeddings
     * const { count } = await prisma.embedding.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmbeddingDeleteManyArgs>(args?: SelectSubset<T, EmbeddingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Embeddings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmbeddingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Embeddings
     * const embedding = await prisma.embedding.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmbeddingUpdateManyArgs>(args: SelectSubset<T, EmbeddingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Embedding.
     * @param {EmbeddingUpsertArgs} args - Arguments to update or create a Embedding.
     * @example
     * // Update or create a Embedding
     * const embedding = await prisma.embedding.upsert({
     *   create: {
     *     // ... data to create a Embedding
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Embedding we want to update
     *   }
     * })
     */
    upsert<T extends EmbeddingUpsertArgs>(args: SelectSubset<T, EmbeddingUpsertArgs<ExtArgs>>): Prisma__EmbeddingClient<$Result.GetResult<Prisma.$EmbeddingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Embeddings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmbeddingCountArgs} args - Arguments to filter Embeddings to count.
     * @example
     * // Count the number of Embeddings
     * const count = await prisma.embedding.count({
     *   where: {
     *     // ... the filter for the Embeddings we want to count
     *   }
     * })
    **/
    count<T extends EmbeddingCountArgs>(
      args?: Subset<T, EmbeddingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmbeddingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Embedding.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmbeddingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmbeddingAggregateArgs>(args: Subset<T, EmbeddingAggregateArgs>): Prisma.PrismaPromise<GetEmbeddingAggregateType<T>>

    /**
     * Group by Embedding.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmbeddingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmbeddingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmbeddingGroupByArgs['orderBy'] }
        : { orderBy?: EmbeddingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmbeddingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmbeddingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Embedding model
   */
  readonly fields: EmbeddingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Embedding.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmbeddingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    job<T extends JobDefaultArgs<ExtArgs> = {}>(args?: Subset<T, JobDefaultArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Embedding model
   */ 
  interface EmbeddingFieldRefs {
    readonly id: FieldRef<"Embedding", 'String'>
    readonly jobId: FieldRef<"Embedding", 'String'>
    readonly content: FieldRef<"Embedding", 'String'>
    readonly contentType: FieldRef<"Embedding", 'EmbeddingType'>
    readonly embedding: FieldRef<"Embedding", 'Float[]'>
    readonly relevance: FieldRef<"Embedding", 'Float'>
    readonly createdAt: FieldRef<"Embedding", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Embedding findUnique
   */
  export type EmbeddingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Embedding
     */
    select?: EmbeddingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmbeddingInclude<ExtArgs> | null
    /**
     * Filter, which Embedding to fetch.
     */
    where: EmbeddingWhereUniqueInput
  }

  /**
   * Embedding findUniqueOrThrow
   */
  export type EmbeddingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Embedding
     */
    select?: EmbeddingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmbeddingInclude<ExtArgs> | null
    /**
     * Filter, which Embedding to fetch.
     */
    where: EmbeddingWhereUniqueInput
  }

  /**
   * Embedding findFirst
   */
  export type EmbeddingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Embedding
     */
    select?: EmbeddingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmbeddingInclude<ExtArgs> | null
    /**
     * Filter, which Embedding to fetch.
     */
    where?: EmbeddingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Embeddings to fetch.
     */
    orderBy?: EmbeddingOrderByWithRelationInput | EmbeddingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Embeddings.
     */
    cursor?: EmbeddingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Embeddings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Embeddings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Embeddings.
     */
    distinct?: EmbeddingScalarFieldEnum | EmbeddingScalarFieldEnum[]
  }

  /**
   * Embedding findFirstOrThrow
   */
  export type EmbeddingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Embedding
     */
    select?: EmbeddingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmbeddingInclude<ExtArgs> | null
    /**
     * Filter, which Embedding to fetch.
     */
    where?: EmbeddingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Embeddings to fetch.
     */
    orderBy?: EmbeddingOrderByWithRelationInput | EmbeddingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Embeddings.
     */
    cursor?: EmbeddingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Embeddings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Embeddings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Embeddings.
     */
    distinct?: EmbeddingScalarFieldEnum | EmbeddingScalarFieldEnum[]
  }

  /**
   * Embedding findMany
   */
  export type EmbeddingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Embedding
     */
    select?: EmbeddingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmbeddingInclude<ExtArgs> | null
    /**
     * Filter, which Embeddings to fetch.
     */
    where?: EmbeddingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Embeddings to fetch.
     */
    orderBy?: EmbeddingOrderByWithRelationInput | EmbeddingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Embeddings.
     */
    cursor?: EmbeddingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Embeddings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Embeddings.
     */
    skip?: number
    distinct?: EmbeddingScalarFieldEnum | EmbeddingScalarFieldEnum[]
  }

  /**
   * Embedding create
   */
  export type EmbeddingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Embedding
     */
    select?: EmbeddingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmbeddingInclude<ExtArgs> | null
    /**
     * The data needed to create a Embedding.
     */
    data: XOR<EmbeddingCreateInput, EmbeddingUncheckedCreateInput>
  }

  /**
   * Embedding createMany
   */
  export type EmbeddingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Embeddings.
     */
    data: EmbeddingCreateManyInput | EmbeddingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Embedding createManyAndReturn
   */
  export type EmbeddingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Embedding
     */
    select?: EmbeddingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Embeddings.
     */
    data: EmbeddingCreateManyInput | EmbeddingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmbeddingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Embedding update
   */
  export type EmbeddingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Embedding
     */
    select?: EmbeddingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmbeddingInclude<ExtArgs> | null
    /**
     * The data needed to update a Embedding.
     */
    data: XOR<EmbeddingUpdateInput, EmbeddingUncheckedUpdateInput>
    /**
     * Choose, which Embedding to update.
     */
    where: EmbeddingWhereUniqueInput
  }

  /**
   * Embedding updateMany
   */
  export type EmbeddingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Embeddings.
     */
    data: XOR<EmbeddingUpdateManyMutationInput, EmbeddingUncheckedUpdateManyInput>
    /**
     * Filter which Embeddings to update
     */
    where?: EmbeddingWhereInput
  }

  /**
   * Embedding upsert
   */
  export type EmbeddingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Embedding
     */
    select?: EmbeddingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmbeddingInclude<ExtArgs> | null
    /**
     * The filter to search for the Embedding to update in case it exists.
     */
    where: EmbeddingWhereUniqueInput
    /**
     * In case the Embedding found by the `where` argument doesn't exist, create a new Embedding with this data.
     */
    create: XOR<EmbeddingCreateInput, EmbeddingUncheckedCreateInput>
    /**
     * In case the Embedding was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmbeddingUpdateInput, EmbeddingUncheckedUpdateInput>
  }

  /**
   * Embedding delete
   */
  export type EmbeddingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Embedding
     */
    select?: EmbeddingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmbeddingInclude<ExtArgs> | null
    /**
     * Filter which Embedding to delete.
     */
    where: EmbeddingWhereUniqueInput
  }

  /**
   * Embedding deleteMany
   */
  export type EmbeddingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Embeddings to delete
     */
    where?: EmbeddingWhereInput
  }

  /**
   * Embedding without action
   */
  export type EmbeddingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Embedding
     */
    select?: EmbeddingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmbeddingInclude<ExtArgs> | null
  }


  /**
   * Model Subscription
   */

  export type AggregateSubscription = {
    _count: SubscriptionCountAggregateOutputType | null
    _avg: SubscriptionAvgAggregateOutputType | null
    _sum: SubscriptionSumAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  export type SubscriptionAvgAggregateOutputType = {
    userId: number | null
  }

  export type SubscriptionSumAggregateOutputType = {
    userId: number | null
  }

  export type SubscriptionMinAggregateOutputType = {
    id: string | null
    userId: number | null
    stripeCustomerId: string | null
    stripeSubscriptionId: string | null
    tier: $Enums.SubscriptionTier | null
    status: $Enums.SubscriptionStatus | null
    currentPeriodStart: Date | null
    currentPeriodEnd: Date | null
    cancelAtPeriodEnd: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionMaxAggregateOutputType = {
    id: string | null
    userId: number | null
    stripeCustomerId: string | null
    stripeSubscriptionId: string | null
    tier: $Enums.SubscriptionTier | null
    status: $Enums.SubscriptionStatus | null
    currentPeriodStart: Date | null
    currentPeriodEnd: Date | null
    cancelAtPeriodEnd: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionCountAggregateOutputType = {
    id: number
    userId: number
    stripeCustomerId: number
    stripeSubscriptionId: number
    tier: number
    status: number
    currentPeriodStart: number
    currentPeriodEnd: number
    cancelAtPeriodEnd: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubscriptionAvgAggregateInputType = {
    userId?: true
  }

  export type SubscriptionSumAggregateInputType = {
    userId?: true
  }

  export type SubscriptionMinAggregateInputType = {
    id?: true
    userId?: true
    stripeCustomerId?: true
    stripeSubscriptionId?: true
    tier?: true
    status?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    cancelAtPeriodEnd?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionMaxAggregateInputType = {
    id?: true
    userId?: true
    stripeCustomerId?: true
    stripeSubscriptionId?: true
    tier?: true
    status?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    cancelAtPeriodEnd?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionCountAggregateInputType = {
    id?: true
    userId?: true
    stripeCustomerId?: true
    stripeSubscriptionId?: true
    tier?: true
    status?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    cancelAtPeriodEnd?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscription to aggregate.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subscriptions
    **/
    _count?: true | SubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubscriptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubscriptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionMaxAggregateInputType
  }

  export type GetSubscriptionAggregateType<T extends SubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscription[P]>
      : GetScalarType<T[P], AggregateSubscription[P]>
  }




  export type SubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithAggregationInput | SubscriptionOrderByWithAggregationInput[]
    by: SubscriptionScalarFieldEnum[] | SubscriptionScalarFieldEnum
    having?: SubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionCountAggregateInputType | true
    _avg?: SubscriptionAvgAggregateInputType
    _sum?: SubscriptionSumAggregateInputType
    _min?: SubscriptionMinAggregateInputType
    _max?: SubscriptionMaxAggregateInputType
  }

  export type SubscriptionGroupByOutputType = {
    id: string
    userId: number
    stripeCustomerId: string | null
    stripeSubscriptionId: string | null
    tier: $Enums.SubscriptionTier
    status: $Enums.SubscriptionStatus
    currentPeriodStart: Date | null
    currentPeriodEnd: Date | null
    cancelAtPeriodEnd: boolean
    createdAt: Date
    updatedAt: Date
    _count: SubscriptionCountAggregateOutputType | null
    _avg: SubscriptionAvgAggregateOutputType | null
    _sum: SubscriptionSumAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  type GetSubscriptionGroupByPayload<T extends SubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    stripeCustomerId?: boolean
    stripeSubscriptionId?: boolean
    tier?: boolean
    status?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    cancelAtPeriodEnd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    stripeCustomerId?: boolean
    stripeSubscriptionId?: boolean
    tier?: boolean
    status?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    cancelAtPeriodEnd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectScalar = {
    id?: boolean
    userId?: boolean
    stripeCustomerId?: boolean
    stripeSubscriptionId?: boolean
    tier?: boolean
    status?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    cancelAtPeriodEnd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SubscriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subscription"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: number
      stripeCustomerId: string | null
      stripeSubscriptionId: string | null
      tier: $Enums.SubscriptionTier
      status: $Enums.SubscriptionStatus
      currentPeriodStart: Date | null
      currentPeriodEnd: Date | null
      cancelAtPeriodEnd: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["subscription"]>
    composites: {}
  }

  type SubscriptionGetPayload<S extends boolean | null | undefined | SubscriptionDefaultArgs> = $Result.GetResult<Prisma.$SubscriptionPayload, S>

  type SubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SubscriptionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SubscriptionCountAggregateInputType | true
    }

  export interface SubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subscription'], meta: { name: 'Subscription' } }
    /**
     * Find zero or one Subscription that matches the filter.
     * @param {SubscriptionFindUniqueArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriptionFindUniqueArgs>(args: SelectSubset<T, SubscriptionFindUniqueArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Subscription that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SubscriptionFindUniqueOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, SubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Subscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriptionFindFirstArgs>(args?: SelectSubset<T, SubscriptionFindFirstArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Subscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, SubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscriptions
     * const subscriptions = await prisma.subscription.findMany()
     * 
     * // Get first 10 Subscriptions
     * const subscriptions = await prisma.subscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubscriptionFindManyArgs>(args?: SelectSubset<T, SubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Subscription.
     * @param {SubscriptionCreateArgs} args - Arguments to create a Subscription.
     * @example
     * // Create one Subscription
     * const Subscription = await prisma.subscription.create({
     *   data: {
     *     // ... data to create a Subscription
     *   }
     * })
     * 
     */
    create<T extends SubscriptionCreateArgs>(args: SelectSubset<T, SubscriptionCreateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Subscriptions.
     * @param {SubscriptionCreateManyArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubscriptionCreateManyArgs>(args?: SelectSubset<T, SubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subscriptions and returns the data saved in the database.
     * @param {SubscriptionCreateManyAndReturnArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subscriptions and only return the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, SubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Subscription.
     * @param {SubscriptionDeleteArgs} args - Arguments to delete one Subscription.
     * @example
     * // Delete one Subscription
     * const Subscription = await prisma.subscription.delete({
     *   where: {
     *     // ... filter to delete one Subscription
     *   }
     * })
     * 
     */
    delete<T extends SubscriptionDeleteArgs>(args: SelectSubset<T, SubscriptionDeleteArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Subscription.
     * @param {SubscriptionUpdateArgs} args - Arguments to update one Subscription.
     * @example
     * // Update one Subscription
     * const subscription = await prisma.subscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubscriptionUpdateArgs>(args: SelectSubset<T, SubscriptionUpdateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Subscriptions.
     * @param {SubscriptionDeleteManyArgs} args - Arguments to filter Subscriptions to delete.
     * @example
     * // Delete a few Subscriptions
     * const { count } = await prisma.subscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubscriptionDeleteManyArgs>(args?: SelectSubset<T, SubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubscriptionUpdateManyArgs>(args: SelectSubset<T, SubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Subscription.
     * @param {SubscriptionUpsertArgs} args - Arguments to update or create a Subscription.
     * @example
     * // Update or create a Subscription
     * const subscription = await prisma.subscription.upsert({
     *   create: {
     *     // ... data to create a Subscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscription we want to update
     *   }
     * })
     */
    upsert<T extends SubscriptionUpsertArgs>(args: SelectSubset<T, SubscriptionUpsertArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionCountArgs} args - Arguments to filter Subscriptions to count.
     * @example
     * // Count the number of Subscriptions
     * const count = await prisma.subscription.count({
     *   where: {
     *     // ... the filter for the Subscriptions we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionCountArgs>(
      args?: Subset<T, SubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionAggregateArgs>(args: Subset<T, SubscriptionAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionAggregateType<T>>

    /**
     * Group by Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subscription model
   */
  readonly fields: SubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subscription model
   */ 
  interface SubscriptionFieldRefs {
    readonly id: FieldRef<"Subscription", 'String'>
    readonly userId: FieldRef<"Subscription", 'Int'>
    readonly stripeCustomerId: FieldRef<"Subscription", 'String'>
    readonly stripeSubscriptionId: FieldRef<"Subscription", 'String'>
    readonly tier: FieldRef<"Subscription", 'SubscriptionTier'>
    readonly status: FieldRef<"Subscription", 'SubscriptionStatus'>
    readonly currentPeriodStart: FieldRef<"Subscription", 'DateTime'>
    readonly currentPeriodEnd: FieldRef<"Subscription", 'DateTime'>
    readonly cancelAtPeriodEnd: FieldRef<"Subscription", 'Boolean'>
    readonly createdAt: FieldRef<"Subscription", 'DateTime'>
    readonly updatedAt: FieldRef<"Subscription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Subscription findUnique
   */
  export type SubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findUniqueOrThrow
   */
  export type SubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findFirst
   */
  export type SubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findFirstOrThrow
   */
  export type SubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findMany
   */
  export type SubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscriptions to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription create
   */
  export type SubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a Subscription.
     */
    data: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
  }

  /**
   * Subscription createMany
   */
  export type SubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subscription createManyAndReturn
   */
  export type SubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subscription update
   */
  export type SubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a Subscription.
     */
    data: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
    /**
     * Choose, which Subscription to update.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription updateMany
   */
  export type SubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
  }

  /**
   * Subscription upsert
   */
  export type SubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the Subscription to update in case it exists.
     */
    where: SubscriptionWhereUniqueInput
    /**
     * In case the Subscription found by the `where` argument doesn't exist, create a new Subscription with this data.
     */
    create: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
    /**
     * In case the Subscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
  }

  /**
   * Subscription delete
   */
  export type SubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter which Subscription to delete.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription deleteMany
   */
  export type SubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscriptions to delete
     */
    where?: SubscriptionWhereInput
  }

  /**
   * Subscription without action
   */
  export type SubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
  }


  /**
   * Model UsageTracking
   */

  export type AggregateUsageTracking = {
    _count: UsageTrackingCountAggregateOutputType | null
    _avg: UsageTrackingAvgAggregateOutputType | null
    _sum: UsageTrackingSumAggregateOutputType | null
    _min: UsageTrackingMinAggregateOutputType | null
    _max: UsageTrackingMaxAggregateOutputType | null
  }

  export type UsageTrackingAvgAggregateOutputType = {
    userId: number | null
    resumesGenerated: number | null
    dailyLimit: number | null
  }

  export type UsageTrackingSumAggregateOutputType = {
    userId: number | null
    resumesGenerated: number | null
    dailyLimit: number | null
  }

  export type UsageTrackingMinAggregateOutputType = {
    id: string | null
    userId: number | null
    date: Date | null
    resumesGenerated: number | null
    dailyLimit: number | null
    tier: $Enums.SubscriptionTier | null
    resetAt: Date | null
  }

  export type UsageTrackingMaxAggregateOutputType = {
    id: string | null
    userId: number | null
    date: Date | null
    resumesGenerated: number | null
    dailyLimit: number | null
    tier: $Enums.SubscriptionTier | null
    resetAt: Date | null
  }

  export type UsageTrackingCountAggregateOutputType = {
    id: number
    userId: number
    date: number
    resumesGenerated: number
    dailyLimit: number
    tier: number
    resetAt: number
    _all: number
  }


  export type UsageTrackingAvgAggregateInputType = {
    userId?: true
    resumesGenerated?: true
    dailyLimit?: true
  }

  export type UsageTrackingSumAggregateInputType = {
    userId?: true
    resumesGenerated?: true
    dailyLimit?: true
  }

  export type UsageTrackingMinAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    resumesGenerated?: true
    dailyLimit?: true
    tier?: true
    resetAt?: true
  }

  export type UsageTrackingMaxAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    resumesGenerated?: true
    dailyLimit?: true
    tier?: true
    resetAt?: true
  }

  export type UsageTrackingCountAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    resumesGenerated?: true
    dailyLimit?: true
    tier?: true
    resetAt?: true
    _all?: true
  }

  export type UsageTrackingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UsageTracking to aggregate.
     */
    where?: UsageTrackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageTrackings to fetch.
     */
    orderBy?: UsageTrackingOrderByWithRelationInput | UsageTrackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsageTrackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageTrackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageTrackings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UsageTrackings
    **/
    _count?: true | UsageTrackingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsageTrackingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsageTrackingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsageTrackingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsageTrackingMaxAggregateInputType
  }

  export type GetUsageTrackingAggregateType<T extends UsageTrackingAggregateArgs> = {
        [P in keyof T & keyof AggregateUsageTracking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsageTracking[P]>
      : GetScalarType<T[P], AggregateUsageTracking[P]>
  }




  export type UsageTrackingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsageTrackingWhereInput
    orderBy?: UsageTrackingOrderByWithAggregationInput | UsageTrackingOrderByWithAggregationInput[]
    by: UsageTrackingScalarFieldEnum[] | UsageTrackingScalarFieldEnum
    having?: UsageTrackingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsageTrackingCountAggregateInputType | true
    _avg?: UsageTrackingAvgAggregateInputType
    _sum?: UsageTrackingSumAggregateInputType
    _min?: UsageTrackingMinAggregateInputType
    _max?: UsageTrackingMaxAggregateInputType
  }

  export type UsageTrackingGroupByOutputType = {
    id: string
    userId: number
    date: Date
    resumesGenerated: number
    dailyLimit: number
    tier: $Enums.SubscriptionTier
    resetAt: Date
    _count: UsageTrackingCountAggregateOutputType | null
    _avg: UsageTrackingAvgAggregateOutputType | null
    _sum: UsageTrackingSumAggregateOutputType | null
    _min: UsageTrackingMinAggregateOutputType | null
    _max: UsageTrackingMaxAggregateOutputType | null
  }

  type GetUsageTrackingGroupByPayload<T extends UsageTrackingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsageTrackingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsageTrackingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsageTrackingGroupByOutputType[P]>
            : GetScalarType<T[P], UsageTrackingGroupByOutputType[P]>
        }
      >
    >


  export type UsageTrackingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    date?: boolean
    resumesGenerated?: boolean
    dailyLimit?: boolean
    tier?: boolean
    resetAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usageTracking"]>

  export type UsageTrackingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    date?: boolean
    resumesGenerated?: boolean
    dailyLimit?: boolean
    tier?: boolean
    resetAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usageTracking"]>

  export type UsageTrackingSelectScalar = {
    id?: boolean
    userId?: boolean
    date?: boolean
    resumesGenerated?: boolean
    dailyLimit?: boolean
    tier?: boolean
    resetAt?: boolean
  }

  export type UsageTrackingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UsageTrackingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UsageTrackingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UsageTracking"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: number
      date: Date
      resumesGenerated: number
      dailyLimit: number
      tier: $Enums.SubscriptionTier
      resetAt: Date
    }, ExtArgs["result"]["usageTracking"]>
    composites: {}
  }

  type UsageTrackingGetPayload<S extends boolean | null | undefined | UsageTrackingDefaultArgs> = $Result.GetResult<Prisma.$UsageTrackingPayload, S>

  type UsageTrackingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UsageTrackingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsageTrackingCountAggregateInputType | true
    }

  export interface UsageTrackingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UsageTracking'], meta: { name: 'UsageTracking' } }
    /**
     * Find zero or one UsageTracking that matches the filter.
     * @param {UsageTrackingFindUniqueArgs} args - Arguments to find a UsageTracking
     * @example
     * // Get one UsageTracking
     * const usageTracking = await prisma.usageTracking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsageTrackingFindUniqueArgs>(args: SelectSubset<T, UsageTrackingFindUniqueArgs<ExtArgs>>): Prisma__UsageTrackingClient<$Result.GetResult<Prisma.$UsageTrackingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UsageTracking that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UsageTrackingFindUniqueOrThrowArgs} args - Arguments to find a UsageTracking
     * @example
     * // Get one UsageTracking
     * const usageTracking = await prisma.usageTracking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsageTrackingFindUniqueOrThrowArgs>(args: SelectSubset<T, UsageTrackingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsageTrackingClient<$Result.GetResult<Prisma.$UsageTrackingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UsageTracking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageTrackingFindFirstArgs} args - Arguments to find a UsageTracking
     * @example
     * // Get one UsageTracking
     * const usageTracking = await prisma.usageTracking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsageTrackingFindFirstArgs>(args?: SelectSubset<T, UsageTrackingFindFirstArgs<ExtArgs>>): Prisma__UsageTrackingClient<$Result.GetResult<Prisma.$UsageTrackingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UsageTracking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageTrackingFindFirstOrThrowArgs} args - Arguments to find a UsageTracking
     * @example
     * // Get one UsageTracking
     * const usageTracking = await prisma.usageTracking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsageTrackingFindFirstOrThrowArgs>(args?: SelectSubset<T, UsageTrackingFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsageTrackingClient<$Result.GetResult<Prisma.$UsageTrackingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UsageTrackings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageTrackingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UsageTrackings
     * const usageTrackings = await prisma.usageTracking.findMany()
     * 
     * // Get first 10 UsageTrackings
     * const usageTrackings = await prisma.usageTracking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usageTrackingWithIdOnly = await prisma.usageTracking.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UsageTrackingFindManyArgs>(args?: SelectSubset<T, UsageTrackingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsageTrackingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UsageTracking.
     * @param {UsageTrackingCreateArgs} args - Arguments to create a UsageTracking.
     * @example
     * // Create one UsageTracking
     * const UsageTracking = await prisma.usageTracking.create({
     *   data: {
     *     // ... data to create a UsageTracking
     *   }
     * })
     * 
     */
    create<T extends UsageTrackingCreateArgs>(args: SelectSubset<T, UsageTrackingCreateArgs<ExtArgs>>): Prisma__UsageTrackingClient<$Result.GetResult<Prisma.$UsageTrackingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UsageTrackings.
     * @param {UsageTrackingCreateManyArgs} args - Arguments to create many UsageTrackings.
     * @example
     * // Create many UsageTrackings
     * const usageTracking = await prisma.usageTracking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsageTrackingCreateManyArgs>(args?: SelectSubset<T, UsageTrackingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UsageTrackings and returns the data saved in the database.
     * @param {UsageTrackingCreateManyAndReturnArgs} args - Arguments to create many UsageTrackings.
     * @example
     * // Create many UsageTrackings
     * const usageTracking = await prisma.usageTracking.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UsageTrackings and only return the `id`
     * const usageTrackingWithIdOnly = await prisma.usageTracking.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UsageTrackingCreateManyAndReturnArgs>(args?: SelectSubset<T, UsageTrackingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsageTrackingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UsageTracking.
     * @param {UsageTrackingDeleteArgs} args - Arguments to delete one UsageTracking.
     * @example
     * // Delete one UsageTracking
     * const UsageTracking = await prisma.usageTracking.delete({
     *   where: {
     *     // ... filter to delete one UsageTracking
     *   }
     * })
     * 
     */
    delete<T extends UsageTrackingDeleteArgs>(args: SelectSubset<T, UsageTrackingDeleteArgs<ExtArgs>>): Prisma__UsageTrackingClient<$Result.GetResult<Prisma.$UsageTrackingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UsageTracking.
     * @param {UsageTrackingUpdateArgs} args - Arguments to update one UsageTracking.
     * @example
     * // Update one UsageTracking
     * const usageTracking = await prisma.usageTracking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsageTrackingUpdateArgs>(args: SelectSubset<T, UsageTrackingUpdateArgs<ExtArgs>>): Prisma__UsageTrackingClient<$Result.GetResult<Prisma.$UsageTrackingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UsageTrackings.
     * @param {UsageTrackingDeleteManyArgs} args - Arguments to filter UsageTrackings to delete.
     * @example
     * // Delete a few UsageTrackings
     * const { count } = await prisma.usageTracking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsageTrackingDeleteManyArgs>(args?: SelectSubset<T, UsageTrackingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UsageTrackings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageTrackingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UsageTrackings
     * const usageTracking = await prisma.usageTracking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsageTrackingUpdateManyArgs>(args: SelectSubset<T, UsageTrackingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UsageTracking.
     * @param {UsageTrackingUpsertArgs} args - Arguments to update or create a UsageTracking.
     * @example
     * // Update or create a UsageTracking
     * const usageTracking = await prisma.usageTracking.upsert({
     *   create: {
     *     // ... data to create a UsageTracking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UsageTracking we want to update
     *   }
     * })
     */
    upsert<T extends UsageTrackingUpsertArgs>(args: SelectSubset<T, UsageTrackingUpsertArgs<ExtArgs>>): Prisma__UsageTrackingClient<$Result.GetResult<Prisma.$UsageTrackingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UsageTrackings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageTrackingCountArgs} args - Arguments to filter UsageTrackings to count.
     * @example
     * // Count the number of UsageTrackings
     * const count = await prisma.usageTracking.count({
     *   where: {
     *     // ... the filter for the UsageTrackings we want to count
     *   }
     * })
    **/
    count<T extends UsageTrackingCountArgs>(
      args?: Subset<T, UsageTrackingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsageTrackingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UsageTracking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageTrackingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsageTrackingAggregateArgs>(args: Subset<T, UsageTrackingAggregateArgs>): Prisma.PrismaPromise<GetUsageTrackingAggregateType<T>>

    /**
     * Group by UsageTracking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageTrackingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsageTrackingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsageTrackingGroupByArgs['orderBy'] }
        : { orderBy?: UsageTrackingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsageTrackingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsageTrackingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UsageTracking model
   */
  readonly fields: UsageTrackingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UsageTracking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsageTrackingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UsageTracking model
   */ 
  interface UsageTrackingFieldRefs {
    readonly id: FieldRef<"UsageTracking", 'String'>
    readonly userId: FieldRef<"UsageTracking", 'Int'>
    readonly date: FieldRef<"UsageTracking", 'DateTime'>
    readonly resumesGenerated: FieldRef<"UsageTracking", 'Int'>
    readonly dailyLimit: FieldRef<"UsageTracking", 'Int'>
    readonly tier: FieldRef<"UsageTracking", 'SubscriptionTier'>
    readonly resetAt: FieldRef<"UsageTracking", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UsageTracking findUnique
   */
  export type UsageTrackingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageTracking
     */
    select?: UsageTrackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageTrackingInclude<ExtArgs> | null
    /**
     * Filter, which UsageTracking to fetch.
     */
    where: UsageTrackingWhereUniqueInput
  }

  /**
   * UsageTracking findUniqueOrThrow
   */
  export type UsageTrackingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageTracking
     */
    select?: UsageTrackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageTrackingInclude<ExtArgs> | null
    /**
     * Filter, which UsageTracking to fetch.
     */
    where: UsageTrackingWhereUniqueInput
  }

  /**
   * UsageTracking findFirst
   */
  export type UsageTrackingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageTracking
     */
    select?: UsageTrackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageTrackingInclude<ExtArgs> | null
    /**
     * Filter, which UsageTracking to fetch.
     */
    where?: UsageTrackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageTrackings to fetch.
     */
    orderBy?: UsageTrackingOrderByWithRelationInput | UsageTrackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsageTrackings.
     */
    cursor?: UsageTrackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageTrackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageTrackings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsageTrackings.
     */
    distinct?: UsageTrackingScalarFieldEnum | UsageTrackingScalarFieldEnum[]
  }

  /**
   * UsageTracking findFirstOrThrow
   */
  export type UsageTrackingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageTracking
     */
    select?: UsageTrackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageTrackingInclude<ExtArgs> | null
    /**
     * Filter, which UsageTracking to fetch.
     */
    where?: UsageTrackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageTrackings to fetch.
     */
    orderBy?: UsageTrackingOrderByWithRelationInput | UsageTrackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsageTrackings.
     */
    cursor?: UsageTrackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageTrackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageTrackings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsageTrackings.
     */
    distinct?: UsageTrackingScalarFieldEnum | UsageTrackingScalarFieldEnum[]
  }

  /**
   * UsageTracking findMany
   */
  export type UsageTrackingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageTracking
     */
    select?: UsageTrackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageTrackingInclude<ExtArgs> | null
    /**
     * Filter, which UsageTrackings to fetch.
     */
    where?: UsageTrackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageTrackings to fetch.
     */
    orderBy?: UsageTrackingOrderByWithRelationInput | UsageTrackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UsageTrackings.
     */
    cursor?: UsageTrackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageTrackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageTrackings.
     */
    skip?: number
    distinct?: UsageTrackingScalarFieldEnum | UsageTrackingScalarFieldEnum[]
  }

  /**
   * UsageTracking create
   */
  export type UsageTrackingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageTracking
     */
    select?: UsageTrackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageTrackingInclude<ExtArgs> | null
    /**
     * The data needed to create a UsageTracking.
     */
    data: XOR<UsageTrackingCreateInput, UsageTrackingUncheckedCreateInput>
  }

  /**
   * UsageTracking createMany
   */
  export type UsageTrackingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UsageTrackings.
     */
    data: UsageTrackingCreateManyInput | UsageTrackingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UsageTracking createManyAndReturn
   */
  export type UsageTrackingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageTracking
     */
    select?: UsageTrackingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UsageTrackings.
     */
    data: UsageTrackingCreateManyInput | UsageTrackingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageTrackingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UsageTracking update
   */
  export type UsageTrackingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageTracking
     */
    select?: UsageTrackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageTrackingInclude<ExtArgs> | null
    /**
     * The data needed to update a UsageTracking.
     */
    data: XOR<UsageTrackingUpdateInput, UsageTrackingUncheckedUpdateInput>
    /**
     * Choose, which UsageTracking to update.
     */
    where: UsageTrackingWhereUniqueInput
  }

  /**
   * UsageTracking updateMany
   */
  export type UsageTrackingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UsageTrackings.
     */
    data: XOR<UsageTrackingUpdateManyMutationInput, UsageTrackingUncheckedUpdateManyInput>
    /**
     * Filter which UsageTrackings to update
     */
    where?: UsageTrackingWhereInput
  }

  /**
   * UsageTracking upsert
   */
  export type UsageTrackingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageTracking
     */
    select?: UsageTrackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageTrackingInclude<ExtArgs> | null
    /**
     * The filter to search for the UsageTracking to update in case it exists.
     */
    where: UsageTrackingWhereUniqueInput
    /**
     * In case the UsageTracking found by the `where` argument doesn't exist, create a new UsageTracking with this data.
     */
    create: XOR<UsageTrackingCreateInput, UsageTrackingUncheckedCreateInput>
    /**
     * In case the UsageTracking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsageTrackingUpdateInput, UsageTrackingUncheckedUpdateInput>
  }

  /**
   * UsageTracking delete
   */
  export type UsageTrackingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageTracking
     */
    select?: UsageTrackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageTrackingInclude<ExtArgs> | null
    /**
     * Filter which UsageTracking to delete.
     */
    where: UsageTrackingWhereUniqueInput
  }

  /**
   * UsageTracking deleteMany
   */
  export type UsageTrackingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UsageTrackings to delete
     */
    where?: UsageTrackingWhereInput
  }

  /**
   * UsageTracking without action
   */
  export type UsageTrackingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageTracking
     */
    select?: UsageTrackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageTrackingInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    userId: number | null
    amount: number | null
  }

  export type PaymentSumAggregateOutputType = {
    userId: number | null
    amount: number | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    userId: number | null
    stripePaymentId: string | null
    amount: number | null
    currency: string | null
    status: $Enums.PaymentStatus | null
    description: string | null
    createdAt: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    userId: number | null
    stripePaymentId: string | null
    amount: number | null
    currency: string | null
    status: $Enums.PaymentStatus | null
    description: string | null
    createdAt: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    userId: number
    stripePaymentId: number
    amount: number
    currency: number
    status: number
    description: number
    createdAt: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    userId?: true
    amount?: true
  }

  export type PaymentSumAggregateInputType = {
    userId?: true
    amount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    userId?: true
    stripePaymentId?: true
    amount?: true
    currency?: true
    status?: true
    description?: true
    createdAt?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    userId?: true
    stripePaymentId?: true
    amount?: true
    currency?: true
    status?: true
    description?: true
    createdAt?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    userId?: true
    stripePaymentId?: true
    amount?: true
    currency?: true
    status?: true
    description?: true
    createdAt?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: string
    userId: number
    stripePaymentId: string
    amount: number
    currency: string
    status: $Enums.PaymentStatus
    description: string | null
    createdAt: Date
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    stripePaymentId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    description?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    stripePaymentId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    description?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    userId?: boolean
    stripePaymentId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    description?: boolean
    createdAt?: boolean
  }

  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: number
      stripePaymentId: string
      amount: number
      currency: string
      status: $Enums.PaymentStatus
      description: string | null
      createdAt: Date
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */ 
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'String'>
    readonly userId: FieldRef<"Payment", 'Int'>
    readonly stripePaymentId: FieldRef<"Payment", 'String'>
    readonly amount: FieldRef<"Payment", 'Int'>
    readonly currency: FieldRef<"Payment", 'String'>
    readonly status: FieldRef<"Payment", 'PaymentStatus'>
    readonly description: FieldRef<"Payment", 'String'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model AggregatedJob
   */

  export type AggregateAggregatedJob = {
    _count: AggregatedJobCountAggregateOutputType | null
    _avg: AggregatedJobAvgAggregateOutputType | null
    _sum: AggregatedJobSumAggregateOutputType | null
    _min: AggregatedJobMinAggregateOutputType | null
    _max: AggregatedJobMaxAggregateOutputType | null
  }

  export type AggregatedJobAvgAggregateOutputType = {
    atsConfidence: number | null
    extractionConfidence: number | null
  }

  export type AggregatedJobSumAggregateOutputType = {
    atsConfidence: number | null
    extractionConfidence: number | null
  }

  export type AggregatedJobMinAggregateOutputType = {
    id: string | null
    externalId: string | null
    source: string | null
    title: string | null
    company: string | null
    location: string | null
    salary: string | null
    description: string | null
    requirements: string | null
    applyUrl: string | null
    companyUrl: string | null
    atsType: string | null
    atsCompany: string | null
    atsComplexity: string | null
    atsConfidence: number | null
    aiApplyable: boolean | null
    extractedExperience: string | null
    extractedEducation: string | null
    extractedJobLevel: string | null
    lastExtractedAt: Date | null
    extractionConfidence: number | null
    postedDate: Date | null
    expiresAt: Date | null
    firstSeenAt: Date | null
    lastChecked: Date | null
    closedAt: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AggregatedJobMaxAggregateOutputType = {
    id: string | null
    externalId: string | null
    source: string | null
    title: string | null
    company: string | null
    location: string | null
    salary: string | null
    description: string | null
    requirements: string | null
    applyUrl: string | null
    companyUrl: string | null
    atsType: string | null
    atsCompany: string | null
    atsComplexity: string | null
    atsConfidence: number | null
    aiApplyable: boolean | null
    extractedExperience: string | null
    extractedEducation: string | null
    extractedJobLevel: string | null
    lastExtractedAt: Date | null
    extractionConfidence: number | null
    postedDate: Date | null
    expiresAt: Date | null
    firstSeenAt: Date | null
    lastChecked: Date | null
    closedAt: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AggregatedJobCountAggregateOutputType = {
    id: number
    externalId: number
    source: number
    title: number
    company: number
    location: number
    salary: number
    description: number
    requirements: number
    applyUrl: number
    companyUrl: number
    atsType: number
    atsCompany: number
    atsComplexity: number
    atsConfidence: number
    aiApplyable: number
    extractedSkills: number
    extractedExperience: number
    extractedEducation: number
    extractedJobLevel: number
    extractedKeywords: number
    extractedBenefits: number
    lastExtractedAt: number
    extractionConfidence: number
    postedDate: number
    expiresAt: number
    firstSeenAt: number
    lastChecked: number
    closedAt: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AggregatedJobAvgAggregateInputType = {
    atsConfidence?: true
    extractionConfidence?: true
  }

  export type AggregatedJobSumAggregateInputType = {
    atsConfidence?: true
    extractionConfidence?: true
  }

  export type AggregatedJobMinAggregateInputType = {
    id?: true
    externalId?: true
    source?: true
    title?: true
    company?: true
    location?: true
    salary?: true
    description?: true
    requirements?: true
    applyUrl?: true
    companyUrl?: true
    atsType?: true
    atsCompany?: true
    atsComplexity?: true
    atsConfidence?: true
    aiApplyable?: true
    extractedExperience?: true
    extractedEducation?: true
    extractedJobLevel?: true
    lastExtractedAt?: true
    extractionConfidence?: true
    postedDate?: true
    expiresAt?: true
    firstSeenAt?: true
    lastChecked?: true
    closedAt?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AggregatedJobMaxAggregateInputType = {
    id?: true
    externalId?: true
    source?: true
    title?: true
    company?: true
    location?: true
    salary?: true
    description?: true
    requirements?: true
    applyUrl?: true
    companyUrl?: true
    atsType?: true
    atsCompany?: true
    atsComplexity?: true
    atsConfidence?: true
    aiApplyable?: true
    extractedExperience?: true
    extractedEducation?: true
    extractedJobLevel?: true
    lastExtractedAt?: true
    extractionConfidence?: true
    postedDate?: true
    expiresAt?: true
    firstSeenAt?: true
    lastChecked?: true
    closedAt?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AggregatedJobCountAggregateInputType = {
    id?: true
    externalId?: true
    source?: true
    title?: true
    company?: true
    location?: true
    salary?: true
    description?: true
    requirements?: true
    applyUrl?: true
    companyUrl?: true
    atsType?: true
    atsCompany?: true
    atsComplexity?: true
    atsConfidence?: true
    aiApplyable?: true
    extractedSkills?: true
    extractedExperience?: true
    extractedEducation?: true
    extractedJobLevel?: true
    extractedKeywords?: true
    extractedBenefits?: true
    lastExtractedAt?: true
    extractionConfidence?: true
    postedDate?: true
    expiresAt?: true
    firstSeenAt?: true
    lastChecked?: true
    closedAt?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AggregatedJobAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AggregatedJob to aggregate.
     */
    where?: AggregatedJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AggregatedJobs to fetch.
     */
    orderBy?: AggregatedJobOrderByWithRelationInput | AggregatedJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AggregatedJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AggregatedJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AggregatedJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AggregatedJobs
    **/
    _count?: true | AggregatedJobCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AggregatedJobAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AggregatedJobSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AggregatedJobMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AggregatedJobMaxAggregateInputType
  }

  export type GetAggregatedJobAggregateType<T extends AggregatedJobAggregateArgs> = {
        [P in keyof T & keyof AggregateAggregatedJob]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAggregatedJob[P]>
      : GetScalarType<T[P], AggregateAggregatedJob[P]>
  }




  export type AggregatedJobGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AggregatedJobWhereInput
    orderBy?: AggregatedJobOrderByWithAggregationInput | AggregatedJobOrderByWithAggregationInput[]
    by: AggregatedJobScalarFieldEnum[] | AggregatedJobScalarFieldEnum
    having?: AggregatedJobScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AggregatedJobCountAggregateInputType | true
    _avg?: AggregatedJobAvgAggregateInputType
    _sum?: AggregatedJobSumAggregateInputType
    _min?: AggregatedJobMinAggregateInputType
    _max?: AggregatedJobMaxAggregateInputType
  }

  export type AggregatedJobGroupByOutputType = {
    id: string
    externalId: string
    source: string
    title: string
    company: string
    location: string | null
    salary: string | null
    description: string
    requirements: string | null
    applyUrl: string
    companyUrl: string | null
    atsType: string
    atsCompany: string | null
    atsComplexity: string
    atsConfidence: number
    aiApplyable: boolean
    extractedSkills: string[]
    extractedExperience: string | null
    extractedEducation: string | null
    extractedJobLevel: string | null
    extractedKeywords: string[]
    extractedBenefits: string[]
    lastExtractedAt: Date | null
    extractionConfidence: number | null
    postedDate: Date
    expiresAt: Date | null
    firstSeenAt: Date
    lastChecked: Date
    closedAt: Date | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date | null
    _count: AggregatedJobCountAggregateOutputType | null
    _avg: AggregatedJobAvgAggregateOutputType | null
    _sum: AggregatedJobSumAggregateOutputType | null
    _min: AggregatedJobMinAggregateOutputType | null
    _max: AggregatedJobMaxAggregateOutputType | null
  }

  type GetAggregatedJobGroupByPayload<T extends AggregatedJobGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AggregatedJobGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AggregatedJobGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AggregatedJobGroupByOutputType[P]>
            : GetScalarType<T[P], AggregatedJobGroupByOutputType[P]>
        }
      >
    >


  export type AggregatedJobSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    externalId?: boolean
    source?: boolean
    title?: boolean
    company?: boolean
    location?: boolean
    salary?: boolean
    description?: boolean
    requirements?: boolean
    applyUrl?: boolean
    companyUrl?: boolean
    atsType?: boolean
    atsCompany?: boolean
    atsComplexity?: boolean
    atsConfidence?: boolean
    aiApplyable?: boolean
    extractedSkills?: boolean
    extractedExperience?: boolean
    extractedEducation?: boolean
    extractedJobLevel?: boolean
    extractedKeywords?: boolean
    extractedBenefits?: boolean
    lastExtractedAt?: boolean
    extractionConfidence?: boolean
    postedDate?: boolean
    expiresAt?: boolean
    firstSeenAt?: boolean
    lastChecked?: boolean
    closedAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    applications?: boolean | AggregatedJob$applicationsArgs<ExtArgs>
    _count?: boolean | AggregatedJobCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aggregatedJob"]>

  export type AggregatedJobSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    externalId?: boolean
    source?: boolean
    title?: boolean
    company?: boolean
    location?: boolean
    salary?: boolean
    description?: boolean
    requirements?: boolean
    applyUrl?: boolean
    companyUrl?: boolean
    atsType?: boolean
    atsCompany?: boolean
    atsComplexity?: boolean
    atsConfidence?: boolean
    aiApplyable?: boolean
    extractedSkills?: boolean
    extractedExperience?: boolean
    extractedEducation?: boolean
    extractedJobLevel?: boolean
    extractedKeywords?: boolean
    extractedBenefits?: boolean
    lastExtractedAt?: boolean
    extractionConfidence?: boolean
    postedDate?: boolean
    expiresAt?: boolean
    firstSeenAt?: boolean
    lastChecked?: boolean
    closedAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["aggregatedJob"]>

  export type AggregatedJobSelectScalar = {
    id?: boolean
    externalId?: boolean
    source?: boolean
    title?: boolean
    company?: boolean
    location?: boolean
    salary?: boolean
    description?: boolean
    requirements?: boolean
    applyUrl?: boolean
    companyUrl?: boolean
    atsType?: boolean
    atsCompany?: boolean
    atsComplexity?: boolean
    atsConfidence?: boolean
    aiApplyable?: boolean
    extractedSkills?: boolean
    extractedExperience?: boolean
    extractedEducation?: boolean
    extractedJobLevel?: boolean
    extractedKeywords?: boolean
    extractedBenefits?: boolean
    lastExtractedAt?: boolean
    extractionConfidence?: boolean
    postedDate?: boolean
    expiresAt?: boolean
    firstSeenAt?: boolean
    lastChecked?: boolean
    closedAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AggregatedJobInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    applications?: boolean | AggregatedJob$applicationsArgs<ExtArgs>
    _count?: boolean | AggregatedJobCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AggregatedJobIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AggregatedJobPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AggregatedJob"
    objects: {
      applications: Prisma.$AutoApplicationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      externalId: string
      source: string
      title: string
      company: string
      location: string | null
      salary: string | null
      description: string
      requirements: string | null
      applyUrl: string
      companyUrl: string | null
      atsType: string
      atsCompany: string | null
      atsComplexity: string
      atsConfidence: number
      aiApplyable: boolean
      extractedSkills: string[]
      extractedExperience: string | null
      extractedEducation: string | null
      extractedJobLevel: string | null
      extractedKeywords: string[]
      extractedBenefits: string[]
      lastExtractedAt: Date | null
      extractionConfidence: number | null
      postedDate: Date
      expiresAt: Date | null
      firstSeenAt: Date
      lastChecked: Date
      closedAt: Date | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["aggregatedJob"]>
    composites: {}
  }

  type AggregatedJobGetPayload<S extends boolean | null | undefined | AggregatedJobDefaultArgs> = $Result.GetResult<Prisma.$AggregatedJobPayload, S>

  type AggregatedJobCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AggregatedJobFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AggregatedJobCountAggregateInputType | true
    }

  export interface AggregatedJobDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AggregatedJob'], meta: { name: 'AggregatedJob' } }
    /**
     * Find zero or one AggregatedJob that matches the filter.
     * @param {AggregatedJobFindUniqueArgs} args - Arguments to find a AggregatedJob
     * @example
     * // Get one AggregatedJob
     * const aggregatedJob = await prisma.aggregatedJob.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AggregatedJobFindUniqueArgs>(args: SelectSubset<T, AggregatedJobFindUniqueArgs<ExtArgs>>): Prisma__AggregatedJobClient<$Result.GetResult<Prisma.$AggregatedJobPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AggregatedJob that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AggregatedJobFindUniqueOrThrowArgs} args - Arguments to find a AggregatedJob
     * @example
     * // Get one AggregatedJob
     * const aggregatedJob = await prisma.aggregatedJob.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AggregatedJobFindUniqueOrThrowArgs>(args: SelectSubset<T, AggregatedJobFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AggregatedJobClient<$Result.GetResult<Prisma.$AggregatedJobPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AggregatedJob that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AggregatedJobFindFirstArgs} args - Arguments to find a AggregatedJob
     * @example
     * // Get one AggregatedJob
     * const aggregatedJob = await prisma.aggregatedJob.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AggregatedJobFindFirstArgs>(args?: SelectSubset<T, AggregatedJobFindFirstArgs<ExtArgs>>): Prisma__AggregatedJobClient<$Result.GetResult<Prisma.$AggregatedJobPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AggregatedJob that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AggregatedJobFindFirstOrThrowArgs} args - Arguments to find a AggregatedJob
     * @example
     * // Get one AggregatedJob
     * const aggregatedJob = await prisma.aggregatedJob.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AggregatedJobFindFirstOrThrowArgs>(args?: SelectSubset<T, AggregatedJobFindFirstOrThrowArgs<ExtArgs>>): Prisma__AggregatedJobClient<$Result.GetResult<Prisma.$AggregatedJobPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AggregatedJobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AggregatedJobFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AggregatedJobs
     * const aggregatedJobs = await prisma.aggregatedJob.findMany()
     * 
     * // Get first 10 AggregatedJobs
     * const aggregatedJobs = await prisma.aggregatedJob.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aggregatedJobWithIdOnly = await prisma.aggregatedJob.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AggregatedJobFindManyArgs>(args?: SelectSubset<T, AggregatedJobFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AggregatedJobPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AggregatedJob.
     * @param {AggregatedJobCreateArgs} args - Arguments to create a AggregatedJob.
     * @example
     * // Create one AggregatedJob
     * const AggregatedJob = await prisma.aggregatedJob.create({
     *   data: {
     *     // ... data to create a AggregatedJob
     *   }
     * })
     * 
     */
    create<T extends AggregatedJobCreateArgs>(args: SelectSubset<T, AggregatedJobCreateArgs<ExtArgs>>): Prisma__AggregatedJobClient<$Result.GetResult<Prisma.$AggregatedJobPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AggregatedJobs.
     * @param {AggregatedJobCreateManyArgs} args - Arguments to create many AggregatedJobs.
     * @example
     * // Create many AggregatedJobs
     * const aggregatedJob = await prisma.aggregatedJob.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AggregatedJobCreateManyArgs>(args?: SelectSubset<T, AggregatedJobCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AggregatedJobs and returns the data saved in the database.
     * @param {AggregatedJobCreateManyAndReturnArgs} args - Arguments to create many AggregatedJobs.
     * @example
     * // Create many AggregatedJobs
     * const aggregatedJob = await prisma.aggregatedJob.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AggregatedJobs and only return the `id`
     * const aggregatedJobWithIdOnly = await prisma.aggregatedJob.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AggregatedJobCreateManyAndReturnArgs>(args?: SelectSubset<T, AggregatedJobCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AggregatedJobPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AggregatedJob.
     * @param {AggregatedJobDeleteArgs} args - Arguments to delete one AggregatedJob.
     * @example
     * // Delete one AggregatedJob
     * const AggregatedJob = await prisma.aggregatedJob.delete({
     *   where: {
     *     // ... filter to delete one AggregatedJob
     *   }
     * })
     * 
     */
    delete<T extends AggregatedJobDeleteArgs>(args: SelectSubset<T, AggregatedJobDeleteArgs<ExtArgs>>): Prisma__AggregatedJobClient<$Result.GetResult<Prisma.$AggregatedJobPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AggregatedJob.
     * @param {AggregatedJobUpdateArgs} args - Arguments to update one AggregatedJob.
     * @example
     * // Update one AggregatedJob
     * const aggregatedJob = await prisma.aggregatedJob.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AggregatedJobUpdateArgs>(args: SelectSubset<T, AggregatedJobUpdateArgs<ExtArgs>>): Prisma__AggregatedJobClient<$Result.GetResult<Prisma.$AggregatedJobPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AggregatedJobs.
     * @param {AggregatedJobDeleteManyArgs} args - Arguments to filter AggregatedJobs to delete.
     * @example
     * // Delete a few AggregatedJobs
     * const { count } = await prisma.aggregatedJob.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AggregatedJobDeleteManyArgs>(args?: SelectSubset<T, AggregatedJobDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AggregatedJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AggregatedJobUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AggregatedJobs
     * const aggregatedJob = await prisma.aggregatedJob.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AggregatedJobUpdateManyArgs>(args: SelectSubset<T, AggregatedJobUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AggregatedJob.
     * @param {AggregatedJobUpsertArgs} args - Arguments to update or create a AggregatedJob.
     * @example
     * // Update or create a AggregatedJob
     * const aggregatedJob = await prisma.aggregatedJob.upsert({
     *   create: {
     *     // ... data to create a AggregatedJob
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AggregatedJob we want to update
     *   }
     * })
     */
    upsert<T extends AggregatedJobUpsertArgs>(args: SelectSubset<T, AggregatedJobUpsertArgs<ExtArgs>>): Prisma__AggregatedJobClient<$Result.GetResult<Prisma.$AggregatedJobPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AggregatedJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AggregatedJobCountArgs} args - Arguments to filter AggregatedJobs to count.
     * @example
     * // Count the number of AggregatedJobs
     * const count = await prisma.aggregatedJob.count({
     *   where: {
     *     // ... the filter for the AggregatedJobs we want to count
     *   }
     * })
    **/
    count<T extends AggregatedJobCountArgs>(
      args?: Subset<T, AggregatedJobCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AggregatedJobCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AggregatedJob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AggregatedJobAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AggregatedJobAggregateArgs>(args: Subset<T, AggregatedJobAggregateArgs>): Prisma.PrismaPromise<GetAggregatedJobAggregateType<T>>

    /**
     * Group by AggregatedJob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AggregatedJobGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AggregatedJobGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AggregatedJobGroupByArgs['orderBy'] }
        : { orderBy?: AggregatedJobGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AggregatedJobGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAggregatedJobGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AggregatedJob model
   */
  readonly fields: AggregatedJobFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AggregatedJob.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AggregatedJobClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    applications<T extends AggregatedJob$applicationsArgs<ExtArgs> = {}>(args?: Subset<T, AggregatedJob$applicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutoApplicationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AggregatedJob model
   */ 
  interface AggregatedJobFieldRefs {
    readonly id: FieldRef<"AggregatedJob", 'String'>
    readonly externalId: FieldRef<"AggregatedJob", 'String'>
    readonly source: FieldRef<"AggregatedJob", 'String'>
    readonly title: FieldRef<"AggregatedJob", 'String'>
    readonly company: FieldRef<"AggregatedJob", 'String'>
    readonly location: FieldRef<"AggregatedJob", 'String'>
    readonly salary: FieldRef<"AggregatedJob", 'String'>
    readonly description: FieldRef<"AggregatedJob", 'String'>
    readonly requirements: FieldRef<"AggregatedJob", 'String'>
    readonly applyUrl: FieldRef<"AggregatedJob", 'String'>
    readonly companyUrl: FieldRef<"AggregatedJob", 'String'>
    readonly atsType: FieldRef<"AggregatedJob", 'String'>
    readonly atsCompany: FieldRef<"AggregatedJob", 'String'>
    readonly atsComplexity: FieldRef<"AggregatedJob", 'String'>
    readonly atsConfidence: FieldRef<"AggregatedJob", 'Float'>
    readonly aiApplyable: FieldRef<"AggregatedJob", 'Boolean'>
    readonly extractedSkills: FieldRef<"AggregatedJob", 'String[]'>
    readonly extractedExperience: FieldRef<"AggregatedJob", 'String'>
    readonly extractedEducation: FieldRef<"AggregatedJob", 'String'>
    readonly extractedJobLevel: FieldRef<"AggregatedJob", 'String'>
    readonly extractedKeywords: FieldRef<"AggregatedJob", 'String[]'>
    readonly extractedBenefits: FieldRef<"AggregatedJob", 'String[]'>
    readonly lastExtractedAt: FieldRef<"AggregatedJob", 'DateTime'>
    readonly extractionConfidence: FieldRef<"AggregatedJob", 'Float'>
    readonly postedDate: FieldRef<"AggregatedJob", 'DateTime'>
    readonly expiresAt: FieldRef<"AggregatedJob", 'DateTime'>
    readonly firstSeenAt: FieldRef<"AggregatedJob", 'DateTime'>
    readonly lastChecked: FieldRef<"AggregatedJob", 'DateTime'>
    readonly closedAt: FieldRef<"AggregatedJob", 'DateTime'>
    readonly isActive: FieldRef<"AggregatedJob", 'Boolean'>
    readonly createdAt: FieldRef<"AggregatedJob", 'DateTime'>
    readonly updatedAt: FieldRef<"AggregatedJob", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AggregatedJob findUnique
   */
  export type AggregatedJobFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AggregatedJob
     */
    select?: AggregatedJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AggregatedJobInclude<ExtArgs> | null
    /**
     * Filter, which AggregatedJob to fetch.
     */
    where: AggregatedJobWhereUniqueInput
  }

  /**
   * AggregatedJob findUniqueOrThrow
   */
  export type AggregatedJobFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AggregatedJob
     */
    select?: AggregatedJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AggregatedJobInclude<ExtArgs> | null
    /**
     * Filter, which AggregatedJob to fetch.
     */
    where: AggregatedJobWhereUniqueInput
  }

  /**
   * AggregatedJob findFirst
   */
  export type AggregatedJobFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AggregatedJob
     */
    select?: AggregatedJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AggregatedJobInclude<ExtArgs> | null
    /**
     * Filter, which AggregatedJob to fetch.
     */
    where?: AggregatedJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AggregatedJobs to fetch.
     */
    orderBy?: AggregatedJobOrderByWithRelationInput | AggregatedJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AggregatedJobs.
     */
    cursor?: AggregatedJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AggregatedJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AggregatedJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AggregatedJobs.
     */
    distinct?: AggregatedJobScalarFieldEnum | AggregatedJobScalarFieldEnum[]
  }

  /**
   * AggregatedJob findFirstOrThrow
   */
  export type AggregatedJobFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AggregatedJob
     */
    select?: AggregatedJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AggregatedJobInclude<ExtArgs> | null
    /**
     * Filter, which AggregatedJob to fetch.
     */
    where?: AggregatedJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AggregatedJobs to fetch.
     */
    orderBy?: AggregatedJobOrderByWithRelationInput | AggregatedJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AggregatedJobs.
     */
    cursor?: AggregatedJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AggregatedJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AggregatedJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AggregatedJobs.
     */
    distinct?: AggregatedJobScalarFieldEnum | AggregatedJobScalarFieldEnum[]
  }

  /**
   * AggregatedJob findMany
   */
  export type AggregatedJobFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AggregatedJob
     */
    select?: AggregatedJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AggregatedJobInclude<ExtArgs> | null
    /**
     * Filter, which AggregatedJobs to fetch.
     */
    where?: AggregatedJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AggregatedJobs to fetch.
     */
    orderBy?: AggregatedJobOrderByWithRelationInput | AggregatedJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AggregatedJobs.
     */
    cursor?: AggregatedJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AggregatedJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AggregatedJobs.
     */
    skip?: number
    distinct?: AggregatedJobScalarFieldEnum | AggregatedJobScalarFieldEnum[]
  }

  /**
   * AggregatedJob create
   */
  export type AggregatedJobCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AggregatedJob
     */
    select?: AggregatedJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AggregatedJobInclude<ExtArgs> | null
    /**
     * The data needed to create a AggregatedJob.
     */
    data: XOR<AggregatedJobCreateInput, AggregatedJobUncheckedCreateInput>
  }

  /**
   * AggregatedJob createMany
   */
  export type AggregatedJobCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AggregatedJobs.
     */
    data: AggregatedJobCreateManyInput | AggregatedJobCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AggregatedJob createManyAndReturn
   */
  export type AggregatedJobCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AggregatedJob
     */
    select?: AggregatedJobSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AggregatedJobs.
     */
    data: AggregatedJobCreateManyInput | AggregatedJobCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AggregatedJob update
   */
  export type AggregatedJobUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AggregatedJob
     */
    select?: AggregatedJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AggregatedJobInclude<ExtArgs> | null
    /**
     * The data needed to update a AggregatedJob.
     */
    data: XOR<AggregatedJobUpdateInput, AggregatedJobUncheckedUpdateInput>
    /**
     * Choose, which AggregatedJob to update.
     */
    where: AggregatedJobWhereUniqueInput
  }

  /**
   * AggregatedJob updateMany
   */
  export type AggregatedJobUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AggregatedJobs.
     */
    data: XOR<AggregatedJobUpdateManyMutationInput, AggregatedJobUncheckedUpdateManyInput>
    /**
     * Filter which AggregatedJobs to update
     */
    where?: AggregatedJobWhereInput
  }

  /**
   * AggregatedJob upsert
   */
  export type AggregatedJobUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AggregatedJob
     */
    select?: AggregatedJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AggregatedJobInclude<ExtArgs> | null
    /**
     * The filter to search for the AggregatedJob to update in case it exists.
     */
    where: AggregatedJobWhereUniqueInput
    /**
     * In case the AggregatedJob found by the `where` argument doesn't exist, create a new AggregatedJob with this data.
     */
    create: XOR<AggregatedJobCreateInput, AggregatedJobUncheckedCreateInput>
    /**
     * In case the AggregatedJob was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AggregatedJobUpdateInput, AggregatedJobUncheckedUpdateInput>
  }

  /**
   * AggregatedJob delete
   */
  export type AggregatedJobDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AggregatedJob
     */
    select?: AggregatedJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AggregatedJobInclude<ExtArgs> | null
    /**
     * Filter which AggregatedJob to delete.
     */
    where: AggregatedJobWhereUniqueInput
  }

  /**
   * AggregatedJob deleteMany
   */
  export type AggregatedJobDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AggregatedJobs to delete
     */
    where?: AggregatedJobWhereInput
  }

  /**
   * AggregatedJob.applications
   */
  export type AggregatedJob$applicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoApplication
     */
    select?: AutoApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoApplicationInclude<ExtArgs> | null
    where?: AutoApplicationWhereInput
    orderBy?: AutoApplicationOrderByWithRelationInput | AutoApplicationOrderByWithRelationInput[]
    cursor?: AutoApplicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AutoApplicationScalarFieldEnum | AutoApplicationScalarFieldEnum[]
  }

  /**
   * AggregatedJob without action
   */
  export type AggregatedJobDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AggregatedJob
     */
    select?: AggregatedJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AggregatedJobInclude<ExtArgs> | null
  }


  /**
   * Model AutoApplication
   */

  export type AggregateAutoApplication = {
    _count: AutoApplicationCountAggregateOutputType | null
    _avg: AutoApplicationAvgAggregateOutputType | null
    _sum: AutoApplicationSumAggregateOutputType | null
    _min: AutoApplicationMinAggregateOutputType | null
    _max: AutoApplicationMaxAggregateOutputType | null
  }

  export type AutoApplicationAvgAggregateOutputType = {
    userId: number | null
    retryCount: number | null
    maxRetries: number | null
    cost: number | null
  }

  export type AutoApplicationSumAggregateOutputType = {
    userId: number | null
    retryCount: number | null
    maxRetries: number | null
    cost: number | null
  }

  export type AutoApplicationMinAggregateOutputType = {
    id: string | null
    userId: number | null
    jobId: string | null
    status: $Enums.AutoApplicationStatus | null
    method: string | null
    submittedAt: Date | null
    confirmationUrl: string | null
    confirmationId: string | null
    error: string | null
    errorType: string | null
    retryCount: number | null
    maxRetries: number | null
    cost: number | null
    createdAt: Date | null
    startedAt: Date | null
    completedAt: Date | null
  }

  export type AutoApplicationMaxAggregateOutputType = {
    id: string | null
    userId: number | null
    jobId: string | null
    status: $Enums.AutoApplicationStatus | null
    method: string | null
    submittedAt: Date | null
    confirmationUrl: string | null
    confirmationId: string | null
    error: string | null
    errorType: string | null
    retryCount: number | null
    maxRetries: number | null
    cost: number | null
    createdAt: Date | null
    startedAt: Date | null
    completedAt: Date | null
  }

  export type AutoApplicationCountAggregateOutputType = {
    id: number
    userId: number
    jobId: number
    status: number
    method: number
    submittedAt: number
    confirmationUrl: number
    confirmationId: number
    confirmationData: number
    error: number
    errorType: number
    retryCount: number
    maxRetries: number
    cost: number
    createdAt: number
    startedAt: number
    completedAt: number
    _all: number
  }


  export type AutoApplicationAvgAggregateInputType = {
    userId?: true
    retryCount?: true
    maxRetries?: true
    cost?: true
  }

  export type AutoApplicationSumAggregateInputType = {
    userId?: true
    retryCount?: true
    maxRetries?: true
    cost?: true
  }

  export type AutoApplicationMinAggregateInputType = {
    id?: true
    userId?: true
    jobId?: true
    status?: true
    method?: true
    submittedAt?: true
    confirmationUrl?: true
    confirmationId?: true
    error?: true
    errorType?: true
    retryCount?: true
    maxRetries?: true
    cost?: true
    createdAt?: true
    startedAt?: true
    completedAt?: true
  }

  export type AutoApplicationMaxAggregateInputType = {
    id?: true
    userId?: true
    jobId?: true
    status?: true
    method?: true
    submittedAt?: true
    confirmationUrl?: true
    confirmationId?: true
    error?: true
    errorType?: true
    retryCount?: true
    maxRetries?: true
    cost?: true
    createdAt?: true
    startedAt?: true
    completedAt?: true
  }

  export type AutoApplicationCountAggregateInputType = {
    id?: true
    userId?: true
    jobId?: true
    status?: true
    method?: true
    submittedAt?: true
    confirmationUrl?: true
    confirmationId?: true
    confirmationData?: true
    error?: true
    errorType?: true
    retryCount?: true
    maxRetries?: true
    cost?: true
    createdAt?: true
    startedAt?: true
    completedAt?: true
    _all?: true
  }

  export type AutoApplicationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AutoApplication to aggregate.
     */
    where?: AutoApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutoApplications to fetch.
     */
    orderBy?: AutoApplicationOrderByWithRelationInput | AutoApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AutoApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutoApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutoApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AutoApplications
    **/
    _count?: true | AutoApplicationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AutoApplicationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AutoApplicationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AutoApplicationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AutoApplicationMaxAggregateInputType
  }

  export type GetAutoApplicationAggregateType<T extends AutoApplicationAggregateArgs> = {
        [P in keyof T & keyof AggregateAutoApplication]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAutoApplication[P]>
      : GetScalarType<T[P], AggregateAutoApplication[P]>
  }




  export type AutoApplicationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutoApplicationWhereInput
    orderBy?: AutoApplicationOrderByWithAggregationInput | AutoApplicationOrderByWithAggregationInput[]
    by: AutoApplicationScalarFieldEnum[] | AutoApplicationScalarFieldEnum
    having?: AutoApplicationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AutoApplicationCountAggregateInputType | true
    _avg?: AutoApplicationAvgAggregateInputType
    _sum?: AutoApplicationSumAggregateInputType
    _min?: AutoApplicationMinAggregateInputType
    _max?: AutoApplicationMaxAggregateInputType
  }

  export type AutoApplicationGroupByOutputType = {
    id: string
    userId: number
    jobId: string
    status: $Enums.AutoApplicationStatus
    method: string
    submittedAt: Date | null
    confirmationUrl: string | null
    confirmationId: string | null
    confirmationData: JsonValue | null
    error: string | null
    errorType: string | null
    retryCount: number
    maxRetries: number
    cost: number
    createdAt: Date
    startedAt: Date | null
    completedAt: Date | null
    _count: AutoApplicationCountAggregateOutputType | null
    _avg: AutoApplicationAvgAggregateOutputType | null
    _sum: AutoApplicationSumAggregateOutputType | null
    _min: AutoApplicationMinAggregateOutputType | null
    _max: AutoApplicationMaxAggregateOutputType | null
  }

  type GetAutoApplicationGroupByPayload<T extends AutoApplicationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AutoApplicationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AutoApplicationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AutoApplicationGroupByOutputType[P]>
            : GetScalarType<T[P], AutoApplicationGroupByOutputType[P]>
        }
      >
    >


  export type AutoApplicationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    jobId?: boolean
    status?: boolean
    method?: boolean
    submittedAt?: boolean
    confirmationUrl?: boolean
    confirmationId?: boolean
    confirmationData?: boolean
    error?: boolean
    errorType?: boolean
    retryCount?: boolean
    maxRetries?: boolean
    cost?: boolean
    createdAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    job?: boolean | AggregatedJobDefaultArgs<ExtArgs>
    workerSession?: boolean | AutoApplication$workerSessionArgs<ExtArgs>
  }, ExtArgs["result"]["autoApplication"]>

  export type AutoApplicationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    jobId?: boolean
    status?: boolean
    method?: boolean
    submittedAt?: boolean
    confirmationUrl?: boolean
    confirmationId?: boolean
    confirmationData?: boolean
    error?: boolean
    errorType?: boolean
    retryCount?: boolean
    maxRetries?: boolean
    cost?: boolean
    createdAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    job?: boolean | AggregatedJobDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["autoApplication"]>

  export type AutoApplicationSelectScalar = {
    id?: boolean
    userId?: boolean
    jobId?: boolean
    status?: boolean
    method?: boolean
    submittedAt?: boolean
    confirmationUrl?: boolean
    confirmationId?: boolean
    confirmationData?: boolean
    error?: boolean
    errorType?: boolean
    retryCount?: boolean
    maxRetries?: boolean
    cost?: boolean
    createdAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
  }

  export type AutoApplicationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    job?: boolean | AggregatedJobDefaultArgs<ExtArgs>
    workerSession?: boolean | AutoApplication$workerSessionArgs<ExtArgs>
  }
  export type AutoApplicationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    job?: boolean | AggregatedJobDefaultArgs<ExtArgs>
  }

  export type $AutoApplicationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AutoApplication"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      job: Prisma.$AggregatedJobPayload<ExtArgs>
      workerSession: Prisma.$WorkerSessionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: number
      jobId: string
      status: $Enums.AutoApplicationStatus
      method: string
      submittedAt: Date | null
      confirmationUrl: string | null
      confirmationId: string | null
      confirmationData: Prisma.JsonValue | null
      error: string | null
      errorType: string | null
      retryCount: number
      maxRetries: number
      cost: number
      createdAt: Date
      startedAt: Date | null
      completedAt: Date | null
    }, ExtArgs["result"]["autoApplication"]>
    composites: {}
  }

  type AutoApplicationGetPayload<S extends boolean | null | undefined | AutoApplicationDefaultArgs> = $Result.GetResult<Prisma.$AutoApplicationPayload, S>

  type AutoApplicationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AutoApplicationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AutoApplicationCountAggregateInputType | true
    }

  export interface AutoApplicationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AutoApplication'], meta: { name: 'AutoApplication' } }
    /**
     * Find zero or one AutoApplication that matches the filter.
     * @param {AutoApplicationFindUniqueArgs} args - Arguments to find a AutoApplication
     * @example
     * // Get one AutoApplication
     * const autoApplication = await prisma.autoApplication.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AutoApplicationFindUniqueArgs>(args: SelectSubset<T, AutoApplicationFindUniqueArgs<ExtArgs>>): Prisma__AutoApplicationClient<$Result.GetResult<Prisma.$AutoApplicationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AutoApplication that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AutoApplicationFindUniqueOrThrowArgs} args - Arguments to find a AutoApplication
     * @example
     * // Get one AutoApplication
     * const autoApplication = await prisma.autoApplication.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AutoApplicationFindUniqueOrThrowArgs>(args: SelectSubset<T, AutoApplicationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AutoApplicationClient<$Result.GetResult<Prisma.$AutoApplicationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AutoApplication that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoApplicationFindFirstArgs} args - Arguments to find a AutoApplication
     * @example
     * // Get one AutoApplication
     * const autoApplication = await prisma.autoApplication.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AutoApplicationFindFirstArgs>(args?: SelectSubset<T, AutoApplicationFindFirstArgs<ExtArgs>>): Prisma__AutoApplicationClient<$Result.GetResult<Prisma.$AutoApplicationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AutoApplication that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoApplicationFindFirstOrThrowArgs} args - Arguments to find a AutoApplication
     * @example
     * // Get one AutoApplication
     * const autoApplication = await prisma.autoApplication.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AutoApplicationFindFirstOrThrowArgs>(args?: SelectSubset<T, AutoApplicationFindFirstOrThrowArgs<ExtArgs>>): Prisma__AutoApplicationClient<$Result.GetResult<Prisma.$AutoApplicationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AutoApplications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoApplicationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AutoApplications
     * const autoApplications = await prisma.autoApplication.findMany()
     * 
     * // Get first 10 AutoApplications
     * const autoApplications = await prisma.autoApplication.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const autoApplicationWithIdOnly = await prisma.autoApplication.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AutoApplicationFindManyArgs>(args?: SelectSubset<T, AutoApplicationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutoApplicationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AutoApplication.
     * @param {AutoApplicationCreateArgs} args - Arguments to create a AutoApplication.
     * @example
     * // Create one AutoApplication
     * const AutoApplication = await prisma.autoApplication.create({
     *   data: {
     *     // ... data to create a AutoApplication
     *   }
     * })
     * 
     */
    create<T extends AutoApplicationCreateArgs>(args: SelectSubset<T, AutoApplicationCreateArgs<ExtArgs>>): Prisma__AutoApplicationClient<$Result.GetResult<Prisma.$AutoApplicationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AutoApplications.
     * @param {AutoApplicationCreateManyArgs} args - Arguments to create many AutoApplications.
     * @example
     * // Create many AutoApplications
     * const autoApplication = await prisma.autoApplication.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AutoApplicationCreateManyArgs>(args?: SelectSubset<T, AutoApplicationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AutoApplications and returns the data saved in the database.
     * @param {AutoApplicationCreateManyAndReturnArgs} args - Arguments to create many AutoApplications.
     * @example
     * // Create many AutoApplications
     * const autoApplication = await prisma.autoApplication.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AutoApplications and only return the `id`
     * const autoApplicationWithIdOnly = await prisma.autoApplication.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AutoApplicationCreateManyAndReturnArgs>(args?: SelectSubset<T, AutoApplicationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutoApplicationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AutoApplication.
     * @param {AutoApplicationDeleteArgs} args - Arguments to delete one AutoApplication.
     * @example
     * // Delete one AutoApplication
     * const AutoApplication = await prisma.autoApplication.delete({
     *   where: {
     *     // ... filter to delete one AutoApplication
     *   }
     * })
     * 
     */
    delete<T extends AutoApplicationDeleteArgs>(args: SelectSubset<T, AutoApplicationDeleteArgs<ExtArgs>>): Prisma__AutoApplicationClient<$Result.GetResult<Prisma.$AutoApplicationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AutoApplication.
     * @param {AutoApplicationUpdateArgs} args - Arguments to update one AutoApplication.
     * @example
     * // Update one AutoApplication
     * const autoApplication = await prisma.autoApplication.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AutoApplicationUpdateArgs>(args: SelectSubset<T, AutoApplicationUpdateArgs<ExtArgs>>): Prisma__AutoApplicationClient<$Result.GetResult<Prisma.$AutoApplicationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AutoApplications.
     * @param {AutoApplicationDeleteManyArgs} args - Arguments to filter AutoApplications to delete.
     * @example
     * // Delete a few AutoApplications
     * const { count } = await prisma.autoApplication.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AutoApplicationDeleteManyArgs>(args?: SelectSubset<T, AutoApplicationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AutoApplications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoApplicationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AutoApplications
     * const autoApplication = await prisma.autoApplication.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AutoApplicationUpdateManyArgs>(args: SelectSubset<T, AutoApplicationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AutoApplication.
     * @param {AutoApplicationUpsertArgs} args - Arguments to update or create a AutoApplication.
     * @example
     * // Update or create a AutoApplication
     * const autoApplication = await prisma.autoApplication.upsert({
     *   create: {
     *     // ... data to create a AutoApplication
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AutoApplication we want to update
     *   }
     * })
     */
    upsert<T extends AutoApplicationUpsertArgs>(args: SelectSubset<T, AutoApplicationUpsertArgs<ExtArgs>>): Prisma__AutoApplicationClient<$Result.GetResult<Prisma.$AutoApplicationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AutoApplications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoApplicationCountArgs} args - Arguments to filter AutoApplications to count.
     * @example
     * // Count the number of AutoApplications
     * const count = await prisma.autoApplication.count({
     *   where: {
     *     // ... the filter for the AutoApplications we want to count
     *   }
     * })
    **/
    count<T extends AutoApplicationCountArgs>(
      args?: Subset<T, AutoApplicationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AutoApplicationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AutoApplication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoApplicationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AutoApplicationAggregateArgs>(args: Subset<T, AutoApplicationAggregateArgs>): Prisma.PrismaPromise<GetAutoApplicationAggregateType<T>>

    /**
     * Group by AutoApplication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoApplicationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AutoApplicationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AutoApplicationGroupByArgs['orderBy'] }
        : { orderBy?: AutoApplicationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AutoApplicationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAutoApplicationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AutoApplication model
   */
  readonly fields: AutoApplicationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AutoApplication.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AutoApplicationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    job<T extends AggregatedJobDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AggregatedJobDefaultArgs<ExtArgs>>): Prisma__AggregatedJobClient<$Result.GetResult<Prisma.$AggregatedJobPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    workerSession<T extends AutoApplication$workerSessionArgs<ExtArgs> = {}>(args?: Subset<T, AutoApplication$workerSessionArgs<ExtArgs>>): Prisma__WorkerSessionClient<$Result.GetResult<Prisma.$WorkerSessionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AutoApplication model
   */ 
  interface AutoApplicationFieldRefs {
    readonly id: FieldRef<"AutoApplication", 'String'>
    readonly userId: FieldRef<"AutoApplication", 'Int'>
    readonly jobId: FieldRef<"AutoApplication", 'String'>
    readonly status: FieldRef<"AutoApplication", 'AutoApplicationStatus'>
    readonly method: FieldRef<"AutoApplication", 'String'>
    readonly submittedAt: FieldRef<"AutoApplication", 'DateTime'>
    readonly confirmationUrl: FieldRef<"AutoApplication", 'String'>
    readonly confirmationId: FieldRef<"AutoApplication", 'String'>
    readonly confirmationData: FieldRef<"AutoApplication", 'Json'>
    readonly error: FieldRef<"AutoApplication", 'String'>
    readonly errorType: FieldRef<"AutoApplication", 'String'>
    readonly retryCount: FieldRef<"AutoApplication", 'Int'>
    readonly maxRetries: FieldRef<"AutoApplication", 'Int'>
    readonly cost: FieldRef<"AutoApplication", 'Float'>
    readonly createdAt: FieldRef<"AutoApplication", 'DateTime'>
    readonly startedAt: FieldRef<"AutoApplication", 'DateTime'>
    readonly completedAt: FieldRef<"AutoApplication", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AutoApplication findUnique
   */
  export type AutoApplicationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoApplication
     */
    select?: AutoApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoApplicationInclude<ExtArgs> | null
    /**
     * Filter, which AutoApplication to fetch.
     */
    where: AutoApplicationWhereUniqueInput
  }

  /**
   * AutoApplication findUniqueOrThrow
   */
  export type AutoApplicationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoApplication
     */
    select?: AutoApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoApplicationInclude<ExtArgs> | null
    /**
     * Filter, which AutoApplication to fetch.
     */
    where: AutoApplicationWhereUniqueInput
  }

  /**
   * AutoApplication findFirst
   */
  export type AutoApplicationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoApplication
     */
    select?: AutoApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoApplicationInclude<ExtArgs> | null
    /**
     * Filter, which AutoApplication to fetch.
     */
    where?: AutoApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutoApplications to fetch.
     */
    orderBy?: AutoApplicationOrderByWithRelationInput | AutoApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AutoApplications.
     */
    cursor?: AutoApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutoApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutoApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AutoApplications.
     */
    distinct?: AutoApplicationScalarFieldEnum | AutoApplicationScalarFieldEnum[]
  }

  /**
   * AutoApplication findFirstOrThrow
   */
  export type AutoApplicationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoApplication
     */
    select?: AutoApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoApplicationInclude<ExtArgs> | null
    /**
     * Filter, which AutoApplication to fetch.
     */
    where?: AutoApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutoApplications to fetch.
     */
    orderBy?: AutoApplicationOrderByWithRelationInput | AutoApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AutoApplications.
     */
    cursor?: AutoApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutoApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutoApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AutoApplications.
     */
    distinct?: AutoApplicationScalarFieldEnum | AutoApplicationScalarFieldEnum[]
  }

  /**
   * AutoApplication findMany
   */
  export type AutoApplicationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoApplication
     */
    select?: AutoApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoApplicationInclude<ExtArgs> | null
    /**
     * Filter, which AutoApplications to fetch.
     */
    where?: AutoApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutoApplications to fetch.
     */
    orderBy?: AutoApplicationOrderByWithRelationInput | AutoApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AutoApplications.
     */
    cursor?: AutoApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutoApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutoApplications.
     */
    skip?: number
    distinct?: AutoApplicationScalarFieldEnum | AutoApplicationScalarFieldEnum[]
  }

  /**
   * AutoApplication create
   */
  export type AutoApplicationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoApplication
     */
    select?: AutoApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoApplicationInclude<ExtArgs> | null
    /**
     * The data needed to create a AutoApplication.
     */
    data: XOR<AutoApplicationCreateInput, AutoApplicationUncheckedCreateInput>
  }

  /**
   * AutoApplication createMany
   */
  export type AutoApplicationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AutoApplications.
     */
    data: AutoApplicationCreateManyInput | AutoApplicationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AutoApplication createManyAndReturn
   */
  export type AutoApplicationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoApplication
     */
    select?: AutoApplicationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AutoApplications.
     */
    data: AutoApplicationCreateManyInput | AutoApplicationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoApplicationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AutoApplication update
   */
  export type AutoApplicationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoApplication
     */
    select?: AutoApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoApplicationInclude<ExtArgs> | null
    /**
     * The data needed to update a AutoApplication.
     */
    data: XOR<AutoApplicationUpdateInput, AutoApplicationUncheckedUpdateInput>
    /**
     * Choose, which AutoApplication to update.
     */
    where: AutoApplicationWhereUniqueInput
  }

  /**
   * AutoApplication updateMany
   */
  export type AutoApplicationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AutoApplications.
     */
    data: XOR<AutoApplicationUpdateManyMutationInput, AutoApplicationUncheckedUpdateManyInput>
    /**
     * Filter which AutoApplications to update
     */
    where?: AutoApplicationWhereInput
  }

  /**
   * AutoApplication upsert
   */
  export type AutoApplicationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoApplication
     */
    select?: AutoApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoApplicationInclude<ExtArgs> | null
    /**
     * The filter to search for the AutoApplication to update in case it exists.
     */
    where: AutoApplicationWhereUniqueInput
    /**
     * In case the AutoApplication found by the `where` argument doesn't exist, create a new AutoApplication with this data.
     */
    create: XOR<AutoApplicationCreateInput, AutoApplicationUncheckedCreateInput>
    /**
     * In case the AutoApplication was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AutoApplicationUpdateInput, AutoApplicationUncheckedUpdateInput>
  }

  /**
   * AutoApplication delete
   */
  export type AutoApplicationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoApplication
     */
    select?: AutoApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoApplicationInclude<ExtArgs> | null
    /**
     * Filter which AutoApplication to delete.
     */
    where: AutoApplicationWhereUniqueInput
  }

  /**
   * AutoApplication deleteMany
   */
  export type AutoApplicationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AutoApplications to delete
     */
    where?: AutoApplicationWhereInput
  }

  /**
   * AutoApplication.workerSession
   */
  export type AutoApplication$workerSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerSession
     */
    select?: WorkerSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerSessionInclude<ExtArgs> | null
    where?: WorkerSessionWhereInput
  }

  /**
   * AutoApplication without action
   */
  export type AutoApplicationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoApplication
     */
    select?: AutoApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutoApplicationInclude<ExtArgs> | null
  }


  /**
   * Model ApplicationRecipe
   */

  export type AggregateApplicationRecipe = {
    _count: ApplicationRecipeCountAggregateOutputType | null
    _avg: ApplicationRecipeAvgAggregateOutputType | null
    _sum: ApplicationRecipeSumAggregateOutputType | null
    _min: ApplicationRecipeMinAggregateOutputType | null
    _max: ApplicationRecipeMaxAggregateOutputType | null
  }

  export type ApplicationRecipeAvgAggregateOutputType = {
    version: number | null
    successRate: number | null
    timesUsed: number | null
    failureCount: number | null
    recordingCost: number | null
    replayCost: number | null
    totalSaved: number | null
  }

  export type ApplicationRecipeSumAggregateOutputType = {
    version: number | null
    successRate: number | null
    timesUsed: number | null
    failureCount: number | null
    recordingCost: number | null
    replayCost: number | null
    totalSaved: number | null
  }

  export type ApplicationRecipeMinAggregateOutputType = {
    id: string | null
    platform: string | null
    atsType: string | null
    version: number | null
    successRate: number | null
    timesUsed: number | null
    failureCount: number | null
    recordingCost: number | null
    replayCost: number | null
    totalSaved: number | null
    createdAt: Date | null
    updatedAt: Date | null
    lastUsed: Date | null
    lastFailure: Date | null
    recordedBy: string | null
  }

  export type ApplicationRecipeMaxAggregateOutputType = {
    id: string | null
    platform: string | null
    atsType: string | null
    version: number | null
    successRate: number | null
    timesUsed: number | null
    failureCount: number | null
    recordingCost: number | null
    replayCost: number | null
    totalSaved: number | null
    createdAt: Date | null
    updatedAt: Date | null
    lastUsed: Date | null
    lastFailure: Date | null
    recordedBy: string | null
  }

  export type ApplicationRecipeCountAggregateOutputType = {
    id: number
    platform: number
    atsType: number
    version: number
    steps: number
    successRate: number
    timesUsed: number
    failureCount: number
    recordingCost: number
    replayCost: number
    totalSaved: number
    createdAt: number
    updatedAt: number
    lastUsed: number
    lastFailure: number
    recordedBy: number
    _all: number
  }


  export type ApplicationRecipeAvgAggregateInputType = {
    version?: true
    successRate?: true
    timesUsed?: true
    failureCount?: true
    recordingCost?: true
    replayCost?: true
    totalSaved?: true
  }

  export type ApplicationRecipeSumAggregateInputType = {
    version?: true
    successRate?: true
    timesUsed?: true
    failureCount?: true
    recordingCost?: true
    replayCost?: true
    totalSaved?: true
  }

  export type ApplicationRecipeMinAggregateInputType = {
    id?: true
    platform?: true
    atsType?: true
    version?: true
    successRate?: true
    timesUsed?: true
    failureCount?: true
    recordingCost?: true
    replayCost?: true
    totalSaved?: true
    createdAt?: true
    updatedAt?: true
    lastUsed?: true
    lastFailure?: true
    recordedBy?: true
  }

  export type ApplicationRecipeMaxAggregateInputType = {
    id?: true
    platform?: true
    atsType?: true
    version?: true
    successRate?: true
    timesUsed?: true
    failureCount?: true
    recordingCost?: true
    replayCost?: true
    totalSaved?: true
    createdAt?: true
    updatedAt?: true
    lastUsed?: true
    lastFailure?: true
    recordedBy?: true
  }

  export type ApplicationRecipeCountAggregateInputType = {
    id?: true
    platform?: true
    atsType?: true
    version?: true
    steps?: true
    successRate?: true
    timesUsed?: true
    failureCount?: true
    recordingCost?: true
    replayCost?: true
    totalSaved?: true
    createdAt?: true
    updatedAt?: true
    lastUsed?: true
    lastFailure?: true
    recordedBy?: true
    _all?: true
  }

  export type ApplicationRecipeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApplicationRecipe to aggregate.
     */
    where?: ApplicationRecipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApplicationRecipes to fetch.
     */
    orderBy?: ApplicationRecipeOrderByWithRelationInput | ApplicationRecipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApplicationRecipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApplicationRecipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApplicationRecipes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ApplicationRecipes
    **/
    _count?: true | ApplicationRecipeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ApplicationRecipeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ApplicationRecipeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApplicationRecipeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApplicationRecipeMaxAggregateInputType
  }

  export type GetApplicationRecipeAggregateType<T extends ApplicationRecipeAggregateArgs> = {
        [P in keyof T & keyof AggregateApplicationRecipe]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApplicationRecipe[P]>
      : GetScalarType<T[P], AggregateApplicationRecipe[P]>
  }




  export type ApplicationRecipeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApplicationRecipeWhereInput
    orderBy?: ApplicationRecipeOrderByWithAggregationInput | ApplicationRecipeOrderByWithAggregationInput[]
    by: ApplicationRecipeScalarFieldEnum[] | ApplicationRecipeScalarFieldEnum
    having?: ApplicationRecipeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApplicationRecipeCountAggregateInputType | true
    _avg?: ApplicationRecipeAvgAggregateInputType
    _sum?: ApplicationRecipeSumAggregateInputType
    _min?: ApplicationRecipeMinAggregateInputType
    _max?: ApplicationRecipeMaxAggregateInputType
  }

  export type ApplicationRecipeGroupByOutputType = {
    id: string
    platform: string
    atsType: string
    version: number
    steps: JsonValue
    successRate: number
    timesUsed: number
    failureCount: number
    recordingCost: number
    replayCost: number
    totalSaved: number
    createdAt: Date
    updatedAt: Date
    lastUsed: Date | null
    lastFailure: Date | null
    recordedBy: string | null
    _count: ApplicationRecipeCountAggregateOutputType | null
    _avg: ApplicationRecipeAvgAggregateOutputType | null
    _sum: ApplicationRecipeSumAggregateOutputType | null
    _min: ApplicationRecipeMinAggregateOutputType | null
    _max: ApplicationRecipeMaxAggregateOutputType | null
  }

  type GetApplicationRecipeGroupByPayload<T extends ApplicationRecipeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApplicationRecipeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApplicationRecipeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApplicationRecipeGroupByOutputType[P]>
            : GetScalarType<T[P], ApplicationRecipeGroupByOutputType[P]>
        }
      >
    >


  export type ApplicationRecipeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    platform?: boolean
    atsType?: boolean
    version?: boolean
    steps?: boolean
    successRate?: boolean
    timesUsed?: boolean
    failureCount?: boolean
    recordingCost?: boolean
    replayCost?: boolean
    totalSaved?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastUsed?: boolean
    lastFailure?: boolean
    recordedBy?: boolean
    executions?: boolean | ApplicationRecipe$executionsArgs<ExtArgs>
    _count?: boolean | ApplicationRecipeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["applicationRecipe"]>

  export type ApplicationRecipeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    platform?: boolean
    atsType?: boolean
    version?: boolean
    steps?: boolean
    successRate?: boolean
    timesUsed?: boolean
    failureCount?: boolean
    recordingCost?: boolean
    replayCost?: boolean
    totalSaved?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastUsed?: boolean
    lastFailure?: boolean
    recordedBy?: boolean
  }, ExtArgs["result"]["applicationRecipe"]>

  export type ApplicationRecipeSelectScalar = {
    id?: boolean
    platform?: boolean
    atsType?: boolean
    version?: boolean
    steps?: boolean
    successRate?: boolean
    timesUsed?: boolean
    failureCount?: boolean
    recordingCost?: boolean
    replayCost?: boolean
    totalSaved?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastUsed?: boolean
    lastFailure?: boolean
    recordedBy?: boolean
  }

  export type ApplicationRecipeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    executions?: boolean | ApplicationRecipe$executionsArgs<ExtArgs>
    _count?: boolean | ApplicationRecipeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ApplicationRecipeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ApplicationRecipePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ApplicationRecipe"
    objects: {
      executions: Prisma.$RecipeExecutionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      platform: string
      atsType: string
      version: number
      steps: Prisma.JsonValue
      successRate: number
      timesUsed: number
      failureCount: number
      recordingCost: number
      replayCost: number
      totalSaved: number
      createdAt: Date
      updatedAt: Date
      lastUsed: Date | null
      lastFailure: Date | null
      recordedBy: string | null
    }, ExtArgs["result"]["applicationRecipe"]>
    composites: {}
  }

  type ApplicationRecipeGetPayload<S extends boolean | null | undefined | ApplicationRecipeDefaultArgs> = $Result.GetResult<Prisma.$ApplicationRecipePayload, S>

  type ApplicationRecipeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ApplicationRecipeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ApplicationRecipeCountAggregateInputType | true
    }

  export interface ApplicationRecipeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ApplicationRecipe'], meta: { name: 'ApplicationRecipe' } }
    /**
     * Find zero or one ApplicationRecipe that matches the filter.
     * @param {ApplicationRecipeFindUniqueArgs} args - Arguments to find a ApplicationRecipe
     * @example
     * // Get one ApplicationRecipe
     * const applicationRecipe = await prisma.applicationRecipe.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApplicationRecipeFindUniqueArgs>(args: SelectSubset<T, ApplicationRecipeFindUniqueArgs<ExtArgs>>): Prisma__ApplicationRecipeClient<$Result.GetResult<Prisma.$ApplicationRecipePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ApplicationRecipe that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ApplicationRecipeFindUniqueOrThrowArgs} args - Arguments to find a ApplicationRecipe
     * @example
     * // Get one ApplicationRecipe
     * const applicationRecipe = await prisma.applicationRecipe.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApplicationRecipeFindUniqueOrThrowArgs>(args: SelectSubset<T, ApplicationRecipeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApplicationRecipeClient<$Result.GetResult<Prisma.$ApplicationRecipePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ApplicationRecipe that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationRecipeFindFirstArgs} args - Arguments to find a ApplicationRecipe
     * @example
     * // Get one ApplicationRecipe
     * const applicationRecipe = await prisma.applicationRecipe.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApplicationRecipeFindFirstArgs>(args?: SelectSubset<T, ApplicationRecipeFindFirstArgs<ExtArgs>>): Prisma__ApplicationRecipeClient<$Result.GetResult<Prisma.$ApplicationRecipePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ApplicationRecipe that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationRecipeFindFirstOrThrowArgs} args - Arguments to find a ApplicationRecipe
     * @example
     * // Get one ApplicationRecipe
     * const applicationRecipe = await prisma.applicationRecipe.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApplicationRecipeFindFirstOrThrowArgs>(args?: SelectSubset<T, ApplicationRecipeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApplicationRecipeClient<$Result.GetResult<Prisma.$ApplicationRecipePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ApplicationRecipes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationRecipeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ApplicationRecipes
     * const applicationRecipes = await prisma.applicationRecipe.findMany()
     * 
     * // Get first 10 ApplicationRecipes
     * const applicationRecipes = await prisma.applicationRecipe.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const applicationRecipeWithIdOnly = await prisma.applicationRecipe.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApplicationRecipeFindManyArgs>(args?: SelectSubset<T, ApplicationRecipeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApplicationRecipePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ApplicationRecipe.
     * @param {ApplicationRecipeCreateArgs} args - Arguments to create a ApplicationRecipe.
     * @example
     * // Create one ApplicationRecipe
     * const ApplicationRecipe = await prisma.applicationRecipe.create({
     *   data: {
     *     // ... data to create a ApplicationRecipe
     *   }
     * })
     * 
     */
    create<T extends ApplicationRecipeCreateArgs>(args: SelectSubset<T, ApplicationRecipeCreateArgs<ExtArgs>>): Prisma__ApplicationRecipeClient<$Result.GetResult<Prisma.$ApplicationRecipePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ApplicationRecipes.
     * @param {ApplicationRecipeCreateManyArgs} args - Arguments to create many ApplicationRecipes.
     * @example
     * // Create many ApplicationRecipes
     * const applicationRecipe = await prisma.applicationRecipe.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApplicationRecipeCreateManyArgs>(args?: SelectSubset<T, ApplicationRecipeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ApplicationRecipes and returns the data saved in the database.
     * @param {ApplicationRecipeCreateManyAndReturnArgs} args - Arguments to create many ApplicationRecipes.
     * @example
     * // Create many ApplicationRecipes
     * const applicationRecipe = await prisma.applicationRecipe.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ApplicationRecipes and only return the `id`
     * const applicationRecipeWithIdOnly = await prisma.applicationRecipe.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ApplicationRecipeCreateManyAndReturnArgs>(args?: SelectSubset<T, ApplicationRecipeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApplicationRecipePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ApplicationRecipe.
     * @param {ApplicationRecipeDeleteArgs} args - Arguments to delete one ApplicationRecipe.
     * @example
     * // Delete one ApplicationRecipe
     * const ApplicationRecipe = await prisma.applicationRecipe.delete({
     *   where: {
     *     // ... filter to delete one ApplicationRecipe
     *   }
     * })
     * 
     */
    delete<T extends ApplicationRecipeDeleteArgs>(args: SelectSubset<T, ApplicationRecipeDeleteArgs<ExtArgs>>): Prisma__ApplicationRecipeClient<$Result.GetResult<Prisma.$ApplicationRecipePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ApplicationRecipe.
     * @param {ApplicationRecipeUpdateArgs} args - Arguments to update one ApplicationRecipe.
     * @example
     * // Update one ApplicationRecipe
     * const applicationRecipe = await prisma.applicationRecipe.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApplicationRecipeUpdateArgs>(args: SelectSubset<T, ApplicationRecipeUpdateArgs<ExtArgs>>): Prisma__ApplicationRecipeClient<$Result.GetResult<Prisma.$ApplicationRecipePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ApplicationRecipes.
     * @param {ApplicationRecipeDeleteManyArgs} args - Arguments to filter ApplicationRecipes to delete.
     * @example
     * // Delete a few ApplicationRecipes
     * const { count } = await prisma.applicationRecipe.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApplicationRecipeDeleteManyArgs>(args?: SelectSubset<T, ApplicationRecipeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApplicationRecipes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationRecipeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ApplicationRecipes
     * const applicationRecipe = await prisma.applicationRecipe.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApplicationRecipeUpdateManyArgs>(args: SelectSubset<T, ApplicationRecipeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ApplicationRecipe.
     * @param {ApplicationRecipeUpsertArgs} args - Arguments to update or create a ApplicationRecipe.
     * @example
     * // Update or create a ApplicationRecipe
     * const applicationRecipe = await prisma.applicationRecipe.upsert({
     *   create: {
     *     // ... data to create a ApplicationRecipe
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ApplicationRecipe we want to update
     *   }
     * })
     */
    upsert<T extends ApplicationRecipeUpsertArgs>(args: SelectSubset<T, ApplicationRecipeUpsertArgs<ExtArgs>>): Prisma__ApplicationRecipeClient<$Result.GetResult<Prisma.$ApplicationRecipePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ApplicationRecipes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationRecipeCountArgs} args - Arguments to filter ApplicationRecipes to count.
     * @example
     * // Count the number of ApplicationRecipes
     * const count = await prisma.applicationRecipe.count({
     *   where: {
     *     // ... the filter for the ApplicationRecipes we want to count
     *   }
     * })
    **/
    count<T extends ApplicationRecipeCountArgs>(
      args?: Subset<T, ApplicationRecipeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApplicationRecipeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ApplicationRecipe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationRecipeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApplicationRecipeAggregateArgs>(args: Subset<T, ApplicationRecipeAggregateArgs>): Prisma.PrismaPromise<GetApplicationRecipeAggregateType<T>>

    /**
     * Group by ApplicationRecipe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationRecipeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApplicationRecipeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApplicationRecipeGroupByArgs['orderBy'] }
        : { orderBy?: ApplicationRecipeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApplicationRecipeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApplicationRecipeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ApplicationRecipe model
   */
  readonly fields: ApplicationRecipeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ApplicationRecipe.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApplicationRecipeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    executions<T extends ApplicationRecipe$executionsArgs<ExtArgs> = {}>(args?: Subset<T, ApplicationRecipe$executionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipeExecutionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ApplicationRecipe model
   */ 
  interface ApplicationRecipeFieldRefs {
    readonly id: FieldRef<"ApplicationRecipe", 'String'>
    readonly platform: FieldRef<"ApplicationRecipe", 'String'>
    readonly atsType: FieldRef<"ApplicationRecipe", 'String'>
    readonly version: FieldRef<"ApplicationRecipe", 'Int'>
    readonly steps: FieldRef<"ApplicationRecipe", 'Json'>
    readonly successRate: FieldRef<"ApplicationRecipe", 'Float'>
    readonly timesUsed: FieldRef<"ApplicationRecipe", 'Int'>
    readonly failureCount: FieldRef<"ApplicationRecipe", 'Int'>
    readonly recordingCost: FieldRef<"ApplicationRecipe", 'Float'>
    readonly replayCost: FieldRef<"ApplicationRecipe", 'Float'>
    readonly totalSaved: FieldRef<"ApplicationRecipe", 'Float'>
    readonly createdAt: FieldRef<"ApplicationRecipe", 'DateTime'>
    readonly updatedAt: FieldRef<"ApplicationRecipe", 'DateTime'>
    readonly lastUsed: FieldRef<"ApplicationRecipe", 'DateTime'>
    readonly lastFailure: FieldRef<"ApplicationRecipe", 'DateTime'>
    readonly recordedBy: FieldRef<"ApplicationRecipe", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ApplicationRecipe findUnique
   */
  export type ApplicationRecipeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicationRecipe
     */
    select?: ApplicationRecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationRecipeInclude<ExtArgs> | null
    /**
     * Filter, which ApplicationRecipe to fetch.
     */
    where: ApplicationRecipeWhereUniqueInput
  }

  /**
   * ApplicationRecipe findUniqueOrThrow
   */
  export type ApplicationRecipeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicationRecipe
     */
    select?: ApplicationRecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationRecipeInclude<ExtArgs> | null
    /**
     * Filter, which ApplicationRecipe to fetch.
     */
    where: ApplicationRecipeWhereUniqueInput
  }

  /**
   * ApplicationRecipe findFirst
   */
  export type ApplicationRecipeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicationRecipe
     */
    select?: ApplicationRecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationRecipeInclude<ExtArgs> | null
    /**
     * Filter, which ApplicationRecipe to fetch.
     */
    where?: ApplicationRecipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApplicationRecipes to fetch.
     */
    orderBy?: ApplicationRecipeOrderByWithRelationInput | ApplicationRecipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApplicationRecipes.
     */
    cursor?: ApplicationRecipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApplicationRecipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApplicationRecipes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApplicationRecipes.
     */
    distinct?: ApplicationRecipeScalarFieldEnum | ApplicationRecipeScalarFieldEnum[]
  }

  /**
   * ApplicationRecipe findFirstOrThrow
   */
  export type ApplicationRecipeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicationRecipe
     */
    select?: ApplicationRecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationRecipeInclude<ExtArgs> | null
    /**
     * Filter, which ApplicationRecipe to fetch.
     */
    where?: ApplicationRecipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApplicationRecipes to fetch.
     */
    orderBy?: ApplicationRecipeOrderByWithRelationInput | ApplicationRecipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApplicationRecipes.
     */
    cursor?: ApplicationRecipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApplicationRecipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApplicationRecipes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApplicationRecipes.
     */
    distinct?: ApplicationRecipeScalarFieldEnum | ApplicationRecipeScalarFieldEnum[]
  }

  /**
   * ApplicationRecipe findMany
   */
  export type ApplicationRecipeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicationRecipe
     */
    select?: ApplicationRecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationRecipeInclude<ExtArgs> | null
    /**
     * Filter, which ApplicationRecipes to fetch.
     */
    where?: ApplicationRecipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApplicationRecipes to fetch.
     */
    orderBy?: ApplicationRecipeOrderByWithRelationInput | ApplicationRecipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ApplicationRecipes.
     */
    cursor?: ApplicationRecipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApplicationRecipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApplicationRecipes.
     */
    skip?: number
    distinct?: ApplicationRecipeScalarFieldEnum | ApplicationRecipeScalarFieldEnum[]
  }

  /**
   * ApplicationRecipe create
   */
  export type ApplicationRecipeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicationRecipe
     */
    select?: ApplicationRecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationRecipeInclude<ExtArgs> | null
    /**
     * The data needed to create a ApplicationRecipe.
     */
    data: XOR<ApplicationRecipeCreateInput, ApplicationRecipeUncheckedCreateInput>
  }

  /**
   * ApplicationRecipe createMany
   */
  export type ApplicationRecipeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ApplicationRecipes.
     */
    data: ApplicationRecipeCreateManyInput | ApplicationRecipeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ApplicationRecipe createManyAndReturn
   */
  export type ApplicationRecipeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicationRecipe
     */
    select?: ApplicationRecipeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ApplicationRecipes.
     */
    data: ApplicationRecipeCreateManyInput | ApplicationRecipeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ApplicationRecipe update
   */
  export type ApplicationRecipeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicationRecipe
     */
    select?: ApplicationRecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationRecipeInclude<ExtArgs> | null
    /**
     * The data needed to update a ApplicationRecipe.
     */
    data: XOR<ApplicationRecipeUpdateInput, ApplicationRecipeUncheckedUpdateInput>
    /**
     * Choose, which ApplicationRecipe to update.
     */
    where: ApplicationRecipeWhereUniqueInput
  }

  /**
   * ApplicationRecipe updateMany
   */
  export type ApplicationRecipeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ApplicationRecipes.
     */
    data: XOR<ApplicationRecipeUpdateManyMutationInput, ApplicationRecipeUncheckedUpdateManyInput>
    /**
     * Filter which ApplicationRecipes to update
     */
    where?: ApplicationRecipeWhereInput
  }

  /**
   * ApplicationRecipe upsert
   */
  export type ApplicationRecipeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicationRecipe
     */
    select?: ApplicationRecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationRecipeInclude<ExtArgs> | null
    /**
     * The filter to search for the ApplicationRecipe to update in case it exists.
     */
    where: ApplicationRecipeWhereUniqueInput
    /**
     * In case the ApplicationRecipe found by the `where` argument doesn't exist, create a new ApplicationRecipe with this data.
     */
    create: XOR<ApplicationRecipeCreateInput, ApplicationRecipeUncheckedCreateInput>
    /**
     * In case the ApplicationRecipe was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApplicationRecipeUpdateInput, ApplicationRecipeUncheckedUpdateInput>
  }

  /**
   * ApplicationRecipe delete
   */
  export type ApplicationRecipeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicationRecipe
     */
    select?: ApplicationRecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationRecipeInclude<ExtArgs> | null
    /**
     * Filter which ApplicationRecipe to delete.
     */
    where: ApplicationRecipeWhereUniqueInput
  }

  /**
   * ApplicationRecipe deleteMany
   */
  export type ApplicationRecipeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApplicationRecipes to delete
     */
    where?: ApplicationRecipeWhereInput
  }

  /**
   * ApplicationRecipe.executions
   */
  export type ApplicationRecipe$executionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeExecution
     */
    select?: RecipeExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeExecutionInclude<ExtArgs> | null
    where?: RecipeExecutionWhereInput
    orderBy?: RecipeExecutionOrderByWithRelationInput | RecipeExecutionOrderByWithRelationInput[]
    cursor?: RecipeExecutionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecipeExecutionScalarFieldEnum | RecipeExecutionScalarFieldEnum[]
  }

  /**
   * ApplicationRecipe without action
   */
  export type ApplicationRecipeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicationRecipe
     */
    select?: ApplicationRecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationRecipeInclude<ExtArgs> | null
  }


  /**
   * Model RecipeExecution
   */

  export type AggregateRecipeExecution = {
    _count: RecipeExecutionCountAggregateOutputType | null
    _avg: RecipeExecutionAvgAggregateOutputType | null
    _sum: RecipeExecutionSumAggregateOutputType | null
    _min: RecipeExecutionMinAggregateOutputType | null
    _max: RecipeExecutionMaxAggregateOutputType | null
  }

  export type RecipeExecutionAvgAggregateOutputType = {
    duration: number | null
    cost: number | null
  }

  export type RecipeExecutionSumAggregateOutputType = {
    duration: number | null
    cost: number | null
  }

  export type RecipeExecutionMinAggregateOutputType = {
    id: string | null
    recipeId: string | null
    success: boolean | null
    method: string | null
    duration: number | null
    cost: number | null
    error: string | null
    errorType: string | null
    jobUrl: string | null
    executedAt: Date | null
  }

  export type RecipeExecutionMaxAggregateOutputType = {
    id: string | null
    recipeId: string | null
    success: boolean | null
    method: string | null
    duration: number | null
    cost: number | null
    error: string | null
    errorType: string | null
    jobUrl: string | null
    executedAt: Date | null
  }

  export type RecipeExecutionCountAggregateOutputType = {
    id: number
    recipeId: number
    success: number
    method: number
    duration: number
    cost: number
    error: number
    errorType: number
    jobUrl: number
    executedAt: number
    _all: number
  }


  export type RecipeExecutionAvgAggregateInputType = {
    duration?: true
    cost?: true
  }

  export type RecipeExecutionSumAggregateInputType = {
    duration?: true
    cost?: true
  }

  export type RecipeExecutionMinAggregateInputType = {
    id?: true
    recipeId?: true
    success?: true
    method?: true
    duration?: true
    cost?: true
    error?: true
    errorType?: true
    jobUrl?: true
    executedAt?: true
  }

  export type RecipeExecutionMaxAggregateInputType = {
    id?: true
    recipeId?: true
    success?: true
    method?: true
    duration?: true
    cost?: true
    error?: true
    errorType?: true
    jobUrl?: true
    executedAt?: true
  }

  export type RecipeExecutionCountAggregateInputType = {
    id?: true
    recipeId?: true
    success?: true
    method?: true
    duration?: true
    cost?: true
    error?: true
    errorType?: true
    jobUrl?: true
    executedAt?: true
    _all?: true
  }

  export type RecipeExecutionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecipeExecution to aggregate.
     */
    where?: RecipeExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeExecutions to fetch.
     */
    orderBy?: RecipeExecutionOrderByWithRelationInput | RecipeExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RecipeExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RecipeExecutions
    **/
    _count?: true | RecipeExecutionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RecipeExecutionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RecipeExecutionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecipeExecutionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecipeExecutionMaxAggregateInputType
  }

  export type GetRecipeExecutionAggregateType<T extends RecipeExecutionAggregateArgs> = {
        [P in keyof T & keyof AggregateRecipeExecution]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecipeExecution[P]>
      : GetScalarType<T[P], AggregateRecipeExecution[P]>
  }




  export type RecipeExecutionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipeExecutionWhereInput
    orderBy?: RecipeExecutionOrderByWithAggregationInput | RecipeExecutionOrderByWithAggregationInput[]
    by: RecipeExecutionScalarFieldEnum[] | RecipeExecutionScalarFieldEnum
    having?: RecipeExecutionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecipeExecutionCountAggregateInputType | true
    _avg?: RecipeExecutionAvgAggregateInputType
    _sum?: RecipeExecutionSumAggregateInputType
    _min?: RecipeExecutionMinAggregateInputType
    _max?: RecipeExecutionMaxAggregateInputType
  }

  export type RecipeExecutionGroupByOutputType = {
    id: string
    recipeId: string
    success: boolean
    method: string
    duration: number | null
    cost: number
    error: string | null
    errorType: string | null
    jobUrl: string | null
    executedAt: Date
    _count: RecipeExecutionCountAggregateOutputType | null
    _avg: RecipeExecutionAvgAggregateOutputType | null
    _sum: RecipeExecutionSumAggregateOutputType | null
    _min: RecipeExecutionMinAggregateOutputType | null
    _max: RecipeExecutionMaxAggregateOutputType | null
  }

  type GetRecipeExecutionGroupByPayload<T extends RecipeExecutionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecipeExecutionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecipeExecutionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecipeExecutionGroupByOutputType[P]>
            : GetScalarType<T[P], RecipeExecutionGroupByOutputType[P]>
        }
      >
    >


  export type RecipeExecutionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recipeId?: boolean
    success?: boolean
    method?: boolean
    duration?: boolean
    cost?: boolean
    error?: boolean
    errorType?: boolean
    jobUrl?: boolean
    executedAt?: boolean
    recipe?: boolean | ApplicationRecipeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recipeExecution"]>

  export type RecipeExecutionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recipeId?: boolean
    success?: boolean
    method?: boolean
    duration?: boolean
    cost?: boolean
    error?: boolean
    errorType?: boolean
    jobUrl?: boolean
    executedAt?: boolean
    recipe?: boolean | ApplicationRecipeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recipeExecution"]>

  export type RecipeExecutionSelectScalar = {
    id?: boolean
    recipeId?: boolean
    success?: boolean
    method?: boolean
    duration?: boolean
    cost?: boolean
    error?: boolean
    errorType?: boolean
    jobUrl?: boolean
    executedAt?: boolean
  }

  export type RecipeExecutionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipe?: boolean | ApplicationRecipeDefaultArgs<ExtArgs>
  }
  export type RecipeExecutionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipe?: boolean | ApplicationRecipeDefaultArgs<ExtArgs>
  }

  export type $RecipeExecutionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RecipeExecution"
    objects: {
      recipe: Prisma.$ApplicationRecipePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      recipeId: string
      success: boolean
      method: string
      duration: number | null
      cost: number
      error: string | null
      errorType: string | null
      jobUrl: string | null
      executedAt: Date
    }, ExtArgs["result"]["recipeExecution"]>
    composites: {}
  }

  type RecipeExecutionGetPayload<S extends boolean | null | undefined | RecipeExecutionDefaultArgs> = $Result.GetResult<Prisma.$RecipeExecutionPayload, S>

  type RecipeExecutionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RecipeExecutionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RecipeExecutionCountAggregateInputType | true
    }

  export interface RecipeExecutionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RecipeExecution'], meta: { name: 'RecipeExecution' } }
    /**
     * Find zero or one RecipeExecution that matches the filter.
     * @param {RecipeExecutionFindUniqueArgs} args - Arguments to find a RecipeExecution
     * @example
     * // Get one RecipeExecution
     * const recipeExecution = await prisma.recipeExecution.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RecipeExecutionFindUniqueArgs>(args: SelectSubset<T, RecipeExecutionFindUniqueArgs<ExtArgs>>): Prisma__RecipeExecutionClient<$Result.GetResult<Prisma.$RecipeExecutionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RecipeExecution that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RecipeExecutionFindUniqueOrThrowArgs} args - Arguments to find a RecipeExecution
     * @example
     * // Get one RecipeExecution
     * const recipeExecution = await prisma.recipeExecution.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RecipeExecutionFindUniqueOrThrowArgs>(args: SelectSubset<T, RecipeExecutionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RecipeExecutionClient<$Result.GetResult<Prisma.$RecipeExecutionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RecipeExecution that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeExecutionFindFirstArgs} args - Arguments to find a RecipeExecution
     * @example
     * // Get one RecipeExecution
     * const recipeExecution = await prisma.recipeExecution.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RecipeExecutionFindFirstArgs>(args?: SelectSubset<T, RecipeExecutionFindFirstArgs<ExtArgs>>): Prisma__RecipeExecutionClient<$Result.GetResult<Prisma.$RecipeExecutionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RecipeExecution that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeExecutionFindFirstOrThrowArgs} args - Arguments to find a RecipeExecution
     * @example
     * // Get one RecipeExecution
     * const recipeExecution = await prisma.recipeExecution.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RecipeExecutionFindFirstOrThrowArgs>(args?: SelectSubset<T, RecipeExecutionFindFirstOrThrowArgs<ExtArgs>>): Prisma__RecipeExecutionClient<$Result.GetResult<Prisma.$RecipeExecutionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RecipeExecutions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeExecutionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RecipeExecutions
     * const recipeExecutions = await prisma.recipeExecution.findMany()
     * 
     * // Get first 10 RecipeExecutions
     * const recipeExecutions = await prisma.recipeExecution.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const recipeExecutionWithIdOnly = await prisma.recipeExecution.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RecipeExecutionFindManyArgs>(args?: SelectSubset<T, RecipeExecutionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipeExecutionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RecipeExecution.
     * @param {RecipeExecutionCreateArgs} args - Arguments to create a RecipeExecution.
     * @example
     * // Create one RecipeExecution
     * const RecipeExecution = await prisma.recipeExecution.create({
     *   data: {
     *     // ... data to create a RecipeExecution
     *   }
     * })
     * 
     */
    create<T extends RecipeExecutionCreateArgs>(args: SelectSubset<T, RecipeExecutionCreateArgs<ExtArgs>>): Prisma__RecipeExecutionClient<$Result.GetResult<Prisma.$RecipeExecutionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RecipeExecutions.
     * @param {RecipeExecutionCreateManyArgs} args - Arguments to create many RecipeExecutions.
     * @example
     * // Create many RecipeExecutions
     * const recipeExecution = await prisma.recipeExecution.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RecipeExecutionCreateManyArgs>(args?: SelectSubset<T, RecipeExecutionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RecipeExecutions and returns the data saved in the database.
     * @param {RecipeExecutionCreateManyAndReturnArgs} args - Arguments to create many RecipeExecutions.
     * @example
     * // Create many RecipeExecutions
     * const recipeExecution = await prisma.recipeExecution.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RecipeExecutions and only return the `id`
     * const recipeExecutionWithIdOnly = await prisma.recipeExecution.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RecipeExecutionCreateManyAndReturnArgs>(args?: SelectSubset<T, RecipeExecutionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipeExecutionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RecipeExecution.
     * @param {RecipeExecutionDeleteArgs} args - Arguments to delete one RecipeExecution.
     * @example
     * // Delete one RecipeExecution
     * const RecipeExecution = await prisma.recipeExecution.delete({
     *   where: {
     *     // ... filter to delete one RecipeExecution
     *   }
     * })
     * 
     */
    delete<T extends RecipeExecutionDeleteArgs>(args: SelectSubset<T, RecipeExecutionDeleteArgs<ExtArgs>>): Prisma__RecipeExecutionClient<$Result.GetResult<Prisma.$RecipeExecutionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RecipeExecution.
     * @param {RecipeExecutionUpdateArgs} args - Arguments to update one RecipeExecution.
     * @example
     * // Update one RecipeExecution
     * const recipeExecution = await prisma.recipeExecution.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RecipeExecutionUpdateArgs>(args: SelectSubset<T, RecipeExecutionUpdateArgs<ExtArgs>>): Prisma__RecipeExecutionClient<$Result.GetResult<Prisma.$RecipeExecutionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RecipeExecutions.
     * @param {RecipeExecutionDeleteManyArgs} args - Arguments to filter RecipeExecutions to delete.
     * @example
     * // Delete a few RecipeExecutions
     * const { count } = await prisma.recipeExecution.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RecipeExecutionDeleteManyArgs>(args?: SelectSubset<T, RecipeExecutionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecipeExecutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeExecutionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RecipeExecutions
     * const recipeExecution = await prisma.recipeExecution.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RecipeExecutionUpdateManyArgs>(args: SelectSubset<T, RecipeExecutionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RecipeExecution.
     * @param {RecipeExecutionUpsertArgs} args - Arguments to update or create a RecipeExecution.
     * @example
     * // Update or create a RecipeExecution
     * const recipeExecution = await prisma.recipeExecution.upsert({
     *   create: {
     *     // ... data to create a RecipeExecution
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RecipeExecution we want to update
     *   }
     * })
     */
    upsert<T extends RecipeExecutionUpsertArgs>(args: SelectSubset<T, RecipeExecutionUpsertArgs<ExtArgs>>): Prisma__RecipeExecutionClient<$Result.GetResult<Prisma.$RecipeExecutionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RecipeExecutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeExecutionCountArgs} args - Arguments to filter RecipeExecutions to count.
     * @example
     * // Count the number of RecipeExecutions
     * const count = await prisma.recipeExecution.count({
     *   where: {
     *     // ... the filter for the RecipeExecutions we want to count
     *   }
     * })
    **/
    count<T extends RecipeExecutionCountArgs>(
      args?: Subset<T, RecipeExecutionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecipeExecutionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RecipeExecution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeExecutionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecipeExecutionAggregateArgs>(args: Subset<T, RecipeExecutionAggregateArgs>): Prisma.PrismaPromise<GetRecipeExecutionAggregateType<T>>

    /**
     * Group by RecipeExecution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeExecutionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecipeExecutionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecipeExecutionGroupByArgs['orderBy'] }
        : { orderBy?: RecipeExecutionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecipeExecutionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecipeExecutionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RecipeExecution model
   */
  readonly fields: RecipeExecutionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RecipeExecution.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RecipeExecutionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    recipe<T extends ApplicationRecipeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ApplicationRecipeDefaultArgs<ExtArgs>>): Prisma__ApplicationRecipeClient<$Result.GetResult<Prisma.$ApplicationRecipePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RecipeExecution model
   */ 
  interface RecipeExecutionFieldRefs {
    readonly id: FieldRef<"RecipeExecution", 'String'>
    readonly recipeId: FieldRef<"RecipeExecution", 'String'>
    readonly success: FieldRef<"RecipeExecution", 'Boolean'>
    readonly method: FieldRef<"RecipeExecution", 'String'>
    readonly duration: FieldRef<"RecipeExecution", 'Int'>
    readonly cost: FieldRef<"RecipeExecution", 'Float'>
    readonly error: FieldRef<"RecipeExecution", 'String'>
    readonly errorType: FieldRef<"RecipeExecution", 'String'>
    readonly jobUrl: FieldRef<"RecipeExecution", 'String'>
    readonly executedAt: FieldRef<"RecipeExecution", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RecipeExecution findUnique
   */
  export type RecipeExecutionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeExecution
     */
    select?: RecipeExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeExecutionInclude<ExtArgs> | null
    /**
     * Filter, which RecipeExecution to fetch.
     */
    where: RecipeExecutionWhereUniqueInput
  }

  /**
   * RecipeExecution findUniqueOrThrow
   */
  export type RecipeExecutionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeExecution
     */
    select?: RecipeExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeExecutionInclude<ExtArgs> | null
    /**
     * Filter, which RecipeExecution to fetch.
     */
    where: RecipeExecutionWhereUniqueInput
  }

  /**
   * RecipeExecution findFirst
   */
  export type RecipeExecutionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeExecution
     */
    select?: RecipeExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeExecutionInclude<ExtArgs> | null
    /**
     * Filter, which RecipeExecution to fetch.
     */
    where?: RecipeExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeExecutions to fetch.
     */
    orderBy?: RecipeExecutionOrderByWithRelationInput | RecipeExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecipeExecutions.
     */
    cursor?: RecipeExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecipeExecutions.
     */
    distinct?: RecipeExecutionScalarFieldEnum | RecipeExecutionScalarFieldEnum[]
  }

  /**
   * RecipeExecution findFirstOrThrow
   */
  export type RecipeExecutionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeExecution
     */
    select?: RecipeExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeExecutionInclude<ExtArgs> | null
    /**
     * Filter, which RecipeExecution to fetch.
     */
    where?: RecipeExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeExecutions to fetch.
     */
    orderBy?: RecipeExecutionOrderByWithRelationInput | RecipeExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecipeExecutions.
     */
    cursor?: RecipeExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecipeExecutions.
     */
    distinct?: RecipeExecutionScalarFieldEnum | RecipeExecutionScalarFieldEnum[]
  }

  /**
   * RecipeExecution findMany
   */
  export type RecipeExecutionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeExecution
     */
    select?: RecipeExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeExecutionInclude<ExtArgs> | null
    /**
     * Filter, which RecipeExecutions to fetch.
     */
    where?: RecipeExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeExecutions to fetch.
     */
    orderBy?: RecipeExecutionOrderByWithRelationInput | RecipeExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RecipeExecutions.
     */
    cursor?: RecipeExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeExecutions.
     */
    skip?: number
    distinct?: RecipeExecutionScalarFieldEnum | RecipeExecutionScalarFieldEnum[]
  }

  /**
   * RecipeExecution create
   */
  export type RecipeExecutionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeExecution
     */
    select?: RecipeExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeExecutionInclude<ExtArgs> | null
    /**
     * The data needed to create a RecipeExecution.
     */
    data: XOR<RecipeExecutionCreateInput, RecipeExecutionUncheckedCreateInput>
  }

  /**
   * RecipeExecution createMany
   */
  export type RecipeExecutionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RecipeExecutions.
     */
    data: RecipeExecutionCreateManyInput | RecipeExecutionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RecipeExecution createManyAndReturn
   */
  export type RecipeExecutionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeExecution
     */
    select?: RecipeExecutionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RecipeExecutions.
     */
    data: RecipeExecutionCreateManyInput | RecipeExecutionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeExecutionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RecipeExecution update
   */
  export type RecipeExecutionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeExecution
     */
    select?: RecipeExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeExecutionInclude<ExtArgs> | null
    /**
     * The data needed to update a RecipeExecution.
     */
    data: XOR<RecipeExecutionUpdateInput, RecipeExecutionUncheckedUpdateInput>
    /**
     * Choose, which RecipeExecution to update.
     */
    where: RecipeExecutionWhereUniqueInput
  }

  /**
   * RecipeExecution updateMany
   */
  export type RecipeExecutionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RecipeExecutions.
     */
    data: XOR<RecipeExecutionUpdateManyMutationInput, RecipeExecutionUncheckedUpdateManyInput>
    /**
     * Filter which RecipeExecutions to update
     */
    where?: RecipeExecutionWhereInput
  }

  /**
   * RecipeExecution upsert
   */
  export type RecipeExecutionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeExecution
     */
    select?: RecipeExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeExecutionInclude<ExtArgs> | null
    /**
     * The filter to search for the RecipeExecution to update in case it exists.
     */
    where: RecipeExecutionWhereUniqueInput
    /**
     * In case the RecipeExecution found by the `where` argument doesn't exist, create a new RecipeExecution with this data.
     */
    create: XOR<RecipeExecutionCreateInput, RecipeExecutionUncheckedCreateInput>
    /**
     * In case the RecipeExecution was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RecipeExecutionUpdateInput, RecipeExecutionUncheckedUpdateInput>
  }

  /**
   * RecipeExecution delete
   */
  export type RecipeExecutionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeExecution
     */
    select?: RecipeExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeExecutionInclude<ExtArgs> | null
    /**
     * Filter which RecipeExecution to delete.
     */
    where: RecipeExecutionWhereUniqueInput
  }

  /**
   * RecipeExecution deleteMany
   */
  export type RecipeExecutionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecipeExecutions to delete
     */
    where?: RecipeExecutionWhereInput
  }

  /**
   * RecipeExecution without action
   */
  export type RecipeExecutionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeExecution
     */
    select?: RecipeExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeExecutionInclude<ExtArgs> | null
  }


  /**
   * Model DiscoveredCompany
   */

  export type AggregateDiscoveredCompany = {
    _count: DiscoveredCompanyCountAggregateOutputType | null
    _avg: DiscoveredCompanyAvgAggregateOutputType | null
    _sum: DiscoveredCompanySumAggregateOutputType | null
    _min: DiscoveredCompanyMinAggregateOutputType | null
    _max: DiscoveredCompanyMaxAggregateOutputType | null
  }

  export type DiscoveredCompanyAvgAggregateOutputType = {
    totalJobs: number | null
    lastJobCount: number | null
  }

  export type DiscoveredCompanySumAggregateOutputType = {
    totalJobs: number | null
    lastJobCount: number | null
  }

  export type DiscoveredCompanyMinAggregateOutputType = {
    id: string | null
    atsType: string | null
    slug: string | null
    name: string | null
    discoveredAt: Date | null
    discoveredFrom: string | null
    lastFetchedAt: Date | null
    isActive: boolean | null
    totalJobs: number | null
    lastJobCount: number | null
  }

  export type DiscoveredCompanyMaxAggregateOutputType = {
    id: string | null
    atsType: string | null
    slug: string | null
    name: string | null
    discoveredAt: Date | null
    discoveredFrom: string | null
    lastFetchedAt: Date | null
    isActive: boolean | null
    totalJobs: number | null
    lastJobCount: number | null
  }

  export type DiscoveredCompanyCountAggregateOutputType = {
    id: number
    atsType: number
    slug: number
    name: number
    discoveredAt: number
    discoveredFrom: number
    lastFetchedAt: number
    isActive: number
    totalJobs: number
    lastJobCount: number
    _all: number
  }


  export type DiscoveredCompanyAvgAggregateInputType = {
    totalJobs?: true
    lastJobCount?: true
  }

  export type DiscoveredCompanySumAggregateInputType = {
    totalJobs?: true
    lastJobCount?: true
  }

  export type DiscoveredCompanyMinAggregateInputType = {
    id?: true
    atsType?: true
    slug?: true
    name?: true
    discoveredAt?: true
    discoveredFrom?: true
    lastFetchedAt?: true
    isActive?: true
    totalJobs?: true
    lastJobCount?: true
  }

  export type DiscoveredCompanyMaxAggregateInputType = {
    id?: true
    atsType?: true
    slug?: true
    name?: true
    discoveredAt?: true
    discoveredFrom?: true
    lastFetchedAt?: true
    isActive?: true
    totalJobs?: true
    lastJobCount?: true
  }

  export type DiscoveredCompanyCountAggregateInputType = {
    id?: true
    atsType?: true
    slug?: true
    name?: true
    discoveredAt?: true
    discoveredFrom?: true
    lastFetchedAt?: true
    isActive?: true
    totalJobs?: true
    lastJobCount?: true
    _all?: true
  }

  export type DiscoveredCompanyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DiscoveredCompany to aggregate.
     */
    where?: DiscoveredCompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DiscoveredCompanies to fetch.
     */
    orderBy?: DiscoveredCompanyOrderByWithRelationInput | DiscoveredCompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DiscoveredCompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DiscoveredCompanies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DiscoveredCompanies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DiscoveredCompanies
    **/
    _count?: true | DiscoveredCompanyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DiscoveredCompanyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DiscoveredCompanySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DiscoveredCompanyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DiscoveredCompanyMaxAggregateInputType
  }

  export type GetDiscoveredCompanyAggregateType<T extends DiscoveredCompanyAggregateArgs> = {
        [P in keyof T & keyof AggregateDiscoveredCompany]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDiscoveredCompany[P]>
      : GetScalarType<T[P], AggregateDiscoveredCompany[P]>
  }




  export type DiscoveredCompanyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DiscoveredCompanyWhereInput
    orderBy?: DiscoveredCompanyOrderByWithAggregationInput | DiscoveredCompanyOrderByWithAggregationInput[]
    by: DiscoveredCompanyScalarFieldEnum[] | DiscoveredCompanyScalarFieldEnum
    having?: DiscoveredCompanyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DiscoveredCompanyCountAggregateInputType | true
    _avg?: DiscoveredCompanyAvgAggregateInputType
    _sum?: DiscoveredCompanySumAggregateInputType
    _min?: DiscoveredCompanyMinAggregateInputType
    _max?: DiscoveredCompanyMaxAggregateInputType
  }

  export type DiscoveredCompanyGroupByOutputType = {
    id: string
    atsType: string
    slug: string
    name: string | null
    discoveredAt: Date
    discoveredFrom: string | null
    lastFetchedAt: Date
    isActive: boolean
    totalJobs: number
    lastJobCount: number
    _count: DiscoveredCompanyCountAggregateOutputType | null
    _avg: DiscoveredCompanyAvgAggregateOutputType | null
    _sum: DiscoveredCompanySumAggregateOutputType | null
    _min: DiscoveredCompanyMinAggregateOutputType | null
    _max: DiscoveredCompanyMaxAggregateOutputType | null
  }

  type GetDiscoveredCompanyGroupByPayload<T extends DiscoveredCompanyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DiscoveredCompanyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DiscoveredCompanyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DiscoveredCompanyGroupByOutputType[P]>
            : GetScalarType<T[P], DiscoveredCompanyGroupByOutputType[P]>
        }
      >
    >


  export type DiscoveredCompanySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    atsType?: boolean
    slug?: boolean
    name?: boolean
    discoveredAt?: boolean
    discoveredFrom?: boolean
    lastFetchedAt?: boolean
    isActive?: boolean
    totalJobs?: boolean
    lastJobCount?: boolean
  }, ExtArgs["result"]["discoveredCompany"]>

  export type DiscoveredCompanySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    atsType?: boolean
    slug?: boolean
    name?: boolean
    discoveredAt?: boolean
    discoveredFrom?: boolean
    lastFetchedAt?: boolean
    isActive?: boolean
    totalJobs?: boolean
    lastJobCount?: boolean
  }, ExtArgs["result"]["discoveredCompany"]>

  export type DiscoveredCompanySelectScalar = {
    id?: boolean
    atsType?: boolean
    slug?: boolean
    name?: boolean
    discoveredAt?: boolean
    discoveredFrom?: boolean
    lastFetchedAt?: boolean
    isActive?: boolean
    totalJobs?: boolean
    lastJobCount?: boolean
  }


  export type $DiscoveredCompanyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DiscoveredCompany"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      atsType: string
      slug: string
      name: string | null
      discoveredAt: Date
      discoveredFrom: string | null
      lastFetchedAt: Date
      isActive: boolean
      totalJobs: number
      lastJobCount: number
    }, ExtArgs["result"]["discoveredCompany"]>
    composites: {}
  }

  type DiscoveredCompanyGetPayload<S extends boolean | null | undefined | DiscoveredCompanyDefaultArgs> = $Result.GetResult<Prisma.$DiscoveredCompanyPayload, S>

  type DiscoveredCompanyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DiscoveredCompanyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DiscoveredCompanyCountAggregateInputType | true
    }

  export interface DiscoveredCompanyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DiscoveredCompany'], meta: { name: 'DiscoveredCompany' } }
    /**
     * Find zero or one DiscoveredCompany that matches the filter.
     * @param {DiscoveredCompanyFindUniqueArgs} args - Arguments to find a DiscoveredCompany
     * @example
     * // Get one DiscoveredCompany
     * const discoveredCompany = await prisma.discoveredCompany.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DiscoveredCompanyFindUniqueArgs>(args: SelectSubset<T, DiscoveredCompanyFindUniqueArgs<ExtArgs>>): Prisma__DiscoveredCompanyClient<$Result.GetResult<Prisma.$DiscoveredCompanyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DiscoveredCompany that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DiscoveredCompanyFindUniqueOrThrowArgs} args - Arguments to find a DiscoveredCompany
     * @example
     * // Get one DiscoveredCompany
     * const discoveredCompany = await prisma.discoveredCompany.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DiscoveredCompanyFindUniqueOrThrowArgs>(args: SelectSubset<T, DiscoveredCompanyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DiscoveredCompanyClient<$Result.GetResult<Prisma.$DiscoveredCompanyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DiscoveredCompany that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscoveredCompanyFindFirstArgs} args - Arguments to find a DiscoveredCompany
     * @example
     * // Get one DiscoveredCompany
     * const discoveredCompany = await prisma.discoveredCompany.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DiscoveredCompanyFindFirstArgs>(args?: SelectSubset<T, DiscoveredCompanyFindFirstArgs<ExtArgs>>): Prisma__DiscoveredCompanyClient<$Result.GetResult<Prisma.$DiscoveredCompanyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DiscoveredCompany that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscoveredCompanyFindFirstOrThrowArgs} args - Arguments to find a DiscoveredCompany
     * @example
     * // Get one DiscoveredCompany
     * const discoveredCompany = await prisma.discoveredCompany.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DiscoveredCompanyFindFirstOrThrowArgs>(args?: SelectSubset<T, DiscoveredCompanyFindFirstOrThrowArgs<ExtArgs>>): Prisma__DiscoveredCompanyClient<$Result.GetResult<Prisma.$DiscoveredCompanyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DiscoveredCompanies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscoveredCompanyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DiscoveredCompanies
     * const discoveredCompanies = await prisma.discoveredCompany.findMany()
     * 
     * // Get first 10 DiscoveredCompanies
     * const discoveredCompanies = await prisma.discoveredCompany.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const discoveredCompanyWithIdOnly = await prisma.discoveredCompany.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DiscoveredCompanyFindManyArgs>(args?: SelectSubset<T, DiscoveredCompanyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiscoveredCompanyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DiscoveredCompany.
     * @param {DiscoveredCompanyCreateArgs} args - Arguments to create a DiscoveredCompany.
     * @example
     * // Create one DiscoveredCompany
     * const DiscoveredCompany = await prisma.discoveredCompany.create({
     *   data: {
     *     // ... data to create a DiscoveredCompany
     *   }
     * })
     * 
     */
    create<T extends DiscoveredCompanyCreateArgs>(args: SelectSubset<T, DiscoveredCompanyCreateArgs<ExtArgs>>): Prisma__DiscoveredCompanyClient<$Result.GetResult<Prisma.$DiscoveredCompanyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DiscoveredCompanies.
     * @param {DiscoveredCompanyCreateManyArgs} args - Arguments to create many DiscoveredCompanies.
     * @example
     * // Create many DiscoveredCompanies
     * const discoveredCompany = await prisma.discoveredCompany.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DiscoveredCompanyCreateManyArgs>(args?: SelectSubset<T, DiscoveredCompanyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DiscoveredCompanies and returns the data saved in the database.
     * @param {DiscoveredCompanyCreateManyAndReturnArgs} args - Arguments to create many DiscoveredCompanies.
     * @example
     * // Create many DiscoveredCompanies
     * const discoveredCompany = await prisma.discoveredCompany.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DiscoveredCompanies and only return the `id`
     * const discoveredCompanyWithIdOnly = await prisma.discoveredCompany.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DiscoveredCompanyCreateManyAndReturnArgs>(args?: SelectSubset<T, DiscoveredCompanyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiscoveredCompanyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DiscoveredCompany.
     * @param {DiscoveredCompanyDeleteArgs} args - Arguments to delete one DiscoveredCompany.
     * @example
     * // Delete one DiscoveredCompany
     * const DiscoveredCompany = await prisma.discoveredCompany.delete({
     *   where: {
     *     // ... filter to delete one DiscoveredCompany
     *   }
     * })
     * 
     */
    delete<T extends DiscoveredCompanyDeleteArgs>(args: SelectSubset<T, DiscoveredCompanyDeleteArgs<ExtArgs>>): Prisma__DiscoveredCompanyClient<$Result.GetResult<Prisma.$DiscoveredCompanyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DiscoveredCompany.
     * @param {DiscoveredCompanyUpdateArgs} args - Arguments to update one DiscoveredCompany.
     * @example
     * // Update one DiscoveredCompany
     * const discoveredCompany = await prisma.discoveredCompany.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DiscoveredCompanyUpdateArgs>(args: SelectSubset<T, DiscoveredCompanyUpdateArgs<ExtArgs>>): Prisma__DiscoveredCompanyClient<$Result.GetResult<Prisma.$DiscoveredCompanyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DiscoveredCompanies.
     * @param {DiscoveredCompanyDeleteManyArgs} args - Arguments to filter DiscoveredCompanies to delete.
     * @example
     * // Delete a few DiscoveredCompanies
     * const { count } = await prisma.discoveredCompany.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DiscoveredCompanyDeleteManyArgs>(args?: SelectSubset<T, DiscoveredCompanyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DiscoveredCompanies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscoveredCompanyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DiscoveredCompanies
     * const discoveredCompany = await prisma.discoveredCompany.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DiscoveredCompanyUpdateManyArgs>(args: SelectSubset<T, DiscoveredCompanyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DiscoveredCompany.
     * @param {DiscoveredCompanyUpsertArgs} args - Arguments to update or create a DiscoveredCompany.
     * @example
     * // Update or create a DiscoveredCompany
     * const discoveredCompany = await prisma.discoveredCompany.upsert({
     *   create: {
     *     // ... data to create a DiscoveredCompany
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DiscoveredCompany we want to update
     *   }
     * })
     */
    upsert<T extends DiscoveredCompanyUpsertArgs>(args: SelectSubset<T, DiscoveredCompanyUpsertArgs<ExtArgs>>): Prisma__DiscoveredCompanyClient<$Result.GetResult<Prisma.$DiscoveredCompanyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DiscoveredCompanies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscoveredCompanyCountArgs} args - Arguments to filter DiscoveredCompanies to count.
     * @example
     * // Count the number of DiscoveredCompanies
     * const count = await prisma.discoveredCompany.count({
     *   where: {
     *     // ... the filter for the DiscoveredCompanies we want to count
     *   }
     * })
    **/
    count<T extends DiscoveredCompanyCountArgs>(
      args?: Subset<T, DiscoveredCompanyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DiscoveredCompanyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DiscoveredCompany.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscoveredCompanyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DiscoveredCompanyAggregateArgs>(args: Subset<T, DiscoveredCompanyAggregateArgs>): Prisma.PrismaPromise<GetDiscoveredCompanyAggregateType<T>>

    /**
     * Group by DiscoveredCompany.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscoveredCompanyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DiscoveredCompanyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DiscoveredCompanyGroupByArgs['orderBy'] }
        : { orderBy?: DiscoveredCompanyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DiscoveredCompanyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDiscoveredCompanyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DiscoveredCompany model
   */
  readonly fields: DiscoveredCompanyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DiscoveredCompany.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DiscoveredCompanyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DiscoveredCompany model
   */ 
  interface DiscoveredCompanyFieldRefs {
    readonly id: FieldRef<"DiscoveredCompany", 'String'>
    readonly atsType: FieldRef<"DiscoveredCompany", 'String'>
    readonly slug: FieldRef<"DiscoveredCompany", 'String'>
    readonly name: FieldRef<"DiscoveredCompany", 'String'>
    readonly discoveredAt: FieldRef<"DiscoveredCompany", 'DateTime'>
    readonly discoveredFrom: FieldRef<"DiscoveredCompany", 'String'>
    readonly lastFetchedAt: FieldRef<"DiscoveredCompany", 'DateTime'>
    readonly isActive: FieldRef<"DiscoveredCompany", 'Boolean'>
    readonly totalJobs: FieldRef<"DiscoveredCompany", 'Int'>
    readonly lastJobCount: FieldRef<"DiscoveredCompany", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * DiscoveredCompany findUnique
   */
  export type DiscoveredCompanyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscoveredCompany
     */
    select?: DiscoveredCompanySelect<ExtArgs> | null
    /**
     * Filter, which DiscoveredCompany to fetch.
     */
    where: DiscoveredCompanyWhereUniqueInput
  }

  /**
   * DiscoveredCompany findUniqueOrThrow
   */
  export type DiscoveredCompanyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscoveredCompany
     */
    select?: DiscoveredCompanySelect<ExtArgs> | null
    /**
     * Filter, which DiscoveredCompany to fetch.
     */
    where: DiscoveredCompanyWhereUniqueInput
  }

  /**
   * DiscoveredCompany findFirst
   */
  export type DiscoveredCompanyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscoveredCompany
     */
    select?: DiscoveredCompanySelect<ExtArgs> | null
    /**
     * Filter, which DiscoveredCompany to fetch.
     */
    where?: DiscoveredCompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DiscoveredCompanies to fetch.
     */
    orderBy?: DiscoveredCompanyOrderByWithRelationInput | DiscoveredCompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DiscoveredCompanies.
     */
    cursor?: DiscoveredCompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DiscoveredCompanies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DiscoveredCompanies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DiscoveredCompanies.
     */
    distinct?: DiscoveredCompanyScalarFieldEnum | DiscoveredCompanyScalarFieldEnum[]
  }

  /**
   * DiscoveredCompany findFirstOrThrow
   */
  export type DiscoveredCompanyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscoveredCompany
     */
    select?: DiscoveredCompanySelect<ExtArgs> | null
    /**
     * Filter, which DiscoveredCompany to fetch.
     */
    where?: DiscoveredCompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DiscoveredCompanies to fetch.
     */
    orderBy?: DiscoveredCompanyOrderByWithRelationInput | DiscoveredCompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DiscoveredCompanies.
     */
    cursor?: DiscoveredCompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DiscoveredCompanies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DiscoveredCompanies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DiscoveredCompanies.
     */
    distinct?: DiscoveredCompanyScalarFieldEnum | DiscoveredCompanyScalarFieldEnum[]
  }

  /**
   * DiscoveredCompany findMany
   */
  export type DiscoveredCompanyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscoveredCompany
     */
    select?: DiscoveredCompanySelect<ExtArgs> | null
    /**
     * Filter, which DiscoveredCompanies to fetch.
     */
    where?: DiscoveredCompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DiscoveredCompanies to fetch.
     */
    orderBy?: DiscoveredCompanyOrderByWithRelationInput | DiscoveredCompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DiscoveredCompanies.
     */
    cursor?: DiscoveredCompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DiscoveredCompanies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DiscoveredCompanies.
     */
    skip?: number
    distinct?: DiscoveredCompanyScalarFieldEnum | DiscoveredCompanyScalarFieldEnum[]
  }

  /**
   * DiscoveredCompany create
   */
  export type DiscoveredCompanyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscoveredCompany
     */
    select?: DiscoveredCompanySelect<ExtArgs> | null
    /**
     * The data needed to create a DiscoveredCompany.
     */
    data: XOR<DiscoveredCompanyCreateInput, DiscoveredCompanyUncheckedCreateInput>
  }

  /**
   * DiscoveredCompany createMany
   */
  export type DiscoveredCompanyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DiscoveredCompanies.
     */
    data: DiscoveredCompanyCreateManyInput | DiscoveredCompanyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DiscoveredCompany createManyAndReturn
   */
  export type DiscoveredCompanyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscoveredCompany
     */
    select?: DiscoveredCompanySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DiscoveredCompanies.
     */
    data: DiscoveredCompanyCreateManyInput | DiscoveredCompanyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DiscoveredCompany update
   */
  export type DiscoveredCompanyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscoveredCompany
     */
    select?: DiscoveredCompanySelect<ExtArgs> | null
    /**
     * The data needed to update a DiscoveredCompany.
     */
    data: XOR<DiscoveredCompanyUpdateInput, DiscoveredCompanyUncheckedUpdateInput>
    /**
     * Choose, which DiscoveredCompany to update.
     */
    where: DiscoveredCompanyWhereUniqueInput
  }

  /**
   * DiscoveredCompany updateMany
   */
  export type DiscoveredCompanyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DiscoveredCompanies.
     */
    data: XOR<DiscoveredCompanyUpdateManyMutationInput, DiscoveredCompanyUncheckedUpdateManyInput>
    /**
     * Filter which DiscoveredCompanies to update
     */
    where?: DiscoveredCompanyWhereInput
  }

  /**
   * DiscoveredCompany upsert
   */
  export type DiscoveredCompanyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscoveredCompany
     */
    select?: DiscoveredCompanySelect<ExtArgs> | null
    /**
     * The filter to search for the DiscoveredCompany to update in case it exists.
     */
    where: DiscoveredCompanyWhereUniqueInput
    /**
     * In case the DiscoveredCompany found by the `where` argument doesn't exist, create a new DiscoveredCompany with this data.
     */
    create: XOR<DiscoveredCompanyCreateInput, DiscoveredCompanyUncheckedCreateInput>
    /**
     * In case the DiscoveredCompany was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DiscoveredCompanyUpdateInput, DiscoveredCompanyUncheckedUpdateInput>
  }

  /**
   * DiscoveredCompany delete
   */
  export type DiscoveredCompanyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscoveredCompany
     */
    select?: DiscoveredCompanySelect<ExtArgs> | null
    /**
     * Filter which DiscoveredCompany to delete.
     */
    where: DiscoveredCompanyWhereUniqueInput
  }

  /**
   * DiscoveredCompany deleteMany
   */
  export type DiscoveredCompanyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DiscoveredCompanies to delete
     */
    where?: DiscoveredCompanyWhereInput
  }

  /**
   * DiscoveredCompany without action
   */
  export type DiscoveredCompanyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscoveredCompany
     */
    select?: DiscoveredCompanySelect<ExtArgs> | null
  }


  /**
   * Model Conversation
   */

  export type AggregateConversation = {
    _count: ConversationCountAggregateOutputType | null
    _avg: ConversationAvgAggregateOutputType | null
    _sum: ConversationSumAggregateOutputType | null
    _min: ConversationMinAggregateOutputType | null
    _max: ConversationMaxAggregateOutputType | null
  }

  export type ConversationAvgAggregateOutputType = {
    userId: number | null
  }

  export type ConversationSumAggregateOutputType = {
    userId: number | null
  }

  export type ConversationMinAggregateOutputType = {
    id: string | null
    userId: number | null
    title: string | null
    createdAt: Date | null
    updatedAt: Date | null
    lastMessageAt: Date | null
  }

  export type ConversationMaxAggregateOutputType = {
    id: string | null
    userId: number | null
    title: string | null
    createdAt: Date | null
    updatedAt: Date | null
    lastMessageAt: Date | null
  }

  export type ConversationCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    createdAt: number
    updatedAt: number
    lastMessageAt: number
    _all: number
  }


  export type ConversationAvgAggregateInputType = {
    userId?: true
  }

  export type ConversationSumAggregateInputType = {
    userId?: true
  }

  export type ConversationMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    createdAt?: true
    updatedAt?: true
    lastMessageAt?: true
  }

  export type ConversationMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    createdAt?: true
    updatedAt?: true
    lastMessageAt?: true
  }

  export type ConversationCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    createdAt?: true
    updatedAt?: true
    lastMessageAt?: true
    _all?: true
  }

  export type ConversationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conversation to aggregate.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Conversations
    **/
    _count?: true | ConversationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConversationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConversationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConversationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConversationMaxAggregateInputType
  }

  export type GetConversationAggregateType<T extends ConversationAggregateArgs> = {
        [P in keyof T & keyof AggregateConversation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConversation[P]>
      : GetScalarType<T[P], AggregateConversation[P]>
  }




  export type ConversationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationWhereInput
    orderBy?: ConversationOrderByWithAggregationInput | ConversationOrderByWithAggregationInput[]
    by: ConversationScalarFieldEnum[] | ConversationScalarFieldEnum
    having?: ConversationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConversationCountAggregateInputType | true
    _avg?: ConversationAvgAggregateInputType
    _sum?: ConversationSumAggregateInputType
    _min?: ConversationMinAggregateInputType
    _max?: ConversationMaxAggregateInputType
  }

  export type ConversationGroupByOutputType = {
    id: string
    userId: number | null
    title: string | null
    createdAt: Date
    updatedAt: Date
    lastMessageAt: Date
    _count: ConversationCountAggregateOutputType | null
    _avg: ConversationAvgAggregateOutputType | null
    _sum: ConversationSumAggregateOutputType | null
    _min: ConversationMinAggregateOutputType | null
    _max: ConversationMaxAggregateOutputType | null
  }

  type GetConversationGroupByPayload<T extends ConversationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConversationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConversationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConversationGroupByOutputType[P]>
            : GetScalarType<T[P], ConversationGroupByOutputType[P]>
        }
      >
    >


  export type ConversationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastMessageAt?: boolean
    messages?: boolean | Conversation$messagesArgs<ExtArgs>
    goals?: boolean | Conversation$goalsArgs<ExtArgs>
    user?: boolean | Conversation$userArgs<ExtArgs>
    _count?: boolean | ConversationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversation"]>

  export type ConversationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastMessageAt?: boolean
    user?: boolean | Conversation$userArgs<ExtArgs>
  }, ExtArgs["result"]["conversation"]>

  export type ConversationSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastMessageAt?: boolean
  }

  export type ConversationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | Conversation$messagesArgs<ExtArgs>
    goals?: boolean | Conversation$goalsArgs<ExtArgs>
    user?: boolean | Conversation$userArgs<ExtArgs>
    _count?: boolean | ConversationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ConversationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Conversation$userArgs<ExtArgs>
  }

  export type $ConversationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Conversation"
    objects: {
      messages: Prisma.$MessagePayload<ExtArgs>[]
      goals: Prisma.$GoalPayload<ExtArgs>[]
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: number | null
      title: string | null
      createdAt: Date
      updatedAt: Date
      lastMessageAt: Date
    }, ExtArgs["result"]["conversation"]>
    composites: {}
  }

  type ConversationGetPayload<S extends boolean | null | undefined | ConversationDefaultArgs> = $Result.GetResult<Prisma.$ConversationPayload, S>

  type ConversationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ConversationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ConversationCountAggregateInputType | true
    }

  export interface ConversationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Conversation'], meta: { name: 'Conversation' } }
    /**
     * Find zero or one Conversation that matches the filter.
     * @param {ConversationFindUniqueArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConversationFindUniqueArgs>(args: SelectSubset<T, ConversationFindUniqueArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Conversation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ConversationFindUniqueOrThrowArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConversationFindUniqueOrThrowArgs>(args: SelectSubset<T, ConversationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Conversation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindFirstArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConversationFindFirstArgs>(args?: SelectSubset<T, ConversationFindFirstArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Conversation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindFirstOrThrowArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConversationFindFirstOrThrowArgs>(args?: SelectSubset<T, ConversationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Conversations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Conversations
     * const conversations = await prisma.conversation.findMany()
     * 
     * // Get first 10 Conversations
     * const conversations = await prisma.conversation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conversationWithIdOnly = await prisma.conversation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConversationFindManyArgs>(args?: SelectSubset<T, ConversationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Conversation.
     * @param {ConversationCreateArgs} args - Arguments to create a Conversation.
     * @example
     * // Create one Conversation
     * const Conversation = await prisma.conversation.create({
     *   data: {
     *     // ... data to create a Conversation
     *   }
     * })
     * 
     */
    create<T extends ConversationCreateArgs>(args: SelectSubset<T, ConversationCreateArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Conversations.
     * @param {ConversationCreateManyArgs} args - Arguments to create many Conversations.
     * @example
     * // Create many Conversations
     * const conversation = await prisma.conversation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConversationCreateManyArgs>(args?: SelectSubset<T, ConversationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Conversations and returns the data saved in the database.
     * @param {ConversationCreateManyAndReturnArgs} args - Arguments to create many Conversations.
     * @example
     * // Create many Conversations
     * const conversation = await prisma.conversation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Conversations and only return the `id`
     * const conversationWithIdOnly = await prisma.conversation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConversationCreateManyAndReturnArgs>(args?: SelectSubset<T, ConversationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Conversation.
     * @param {ConversationDeleteArgs} args - Arguments to delete one Conversation.
     * @example
     * // Delete one Conversation
     * const Conversation = await prisma.conversation.delete({
     *   where: {
     *     // ... filter to delete one Conversation
     *   }
     * })
     * 
     */
    delete<T extends ConversationDeleteArgs>(args: SelectSubset<T, ConversationDeleteArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Conversation.
     * @param {ConversationUpdateArgs} args - Arguments to update one Conversation.
     * @example
     * // Update one Conversation
     * const conversation = await prisma.conversation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConversationUpdateArgs>(args: SelectSubset<T, ConversationUpdateArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Conversations.
     * @param {ConversationDeleteManyArgs} args - Arguments to filter Conversations to delete.
     * @example
     * // Delete a few Conversations
     * const { count } = await prisma.conversation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConversationDeleteManyArgs>(args?: SelectSubset<T, ConversationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Conversations
     * const conversation = await prisma.conversation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConversationUpdateManyArgs>(args: SelectSubset<T, ConversationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Conversation.
     * @param {ConversationUpsertArgs} args - Arguments to update or create a Conversation.
     * @example
     * // Update or create a Conversation
     * const conversation = await prisma.conversation.upsert({
     *   create: {
     *     // ... data to create a Conversation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Conversation we want to update
     *   }
     * })
     */
    upsert<T extends ConversationUpsertArgs>(args: SelectSubset<T, ConversationUpsertArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationCountArgs} args - Arguments to filter Conversations to count.
     * @example
     * // Count the number of Conversations
     * const count = await prisma.conversation.count({
     *   where: {
     *     // ... the filter for the Conversations we want to count
     *   }
     * })
    **/
    count<T extends ConversationCountArgs>(
      args?: Subset<T, ConversationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConversationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Conversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConversationAggregateArgs>(args: Subset<T, ConversationAggregateArgs>): Prisma.PrismaPromise<GetConversationAggregateType<T>>

    /**
     * Group by Conversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConversationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConversationGroupByArgs['orderBy'] }
        : { orderBy?: ConversationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConversationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConversationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Conversation model
   */
  readonly fields: ConversationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Conversation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConversationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    messages<T extends Conversation$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Conversation$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany"> | Null>
    goals<T extends Conversation$goalsArgs<ExtArgs> = {}>(args?: Subset<T, Conversation$goalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "findMany"> | Null>
    user<T extends Conversation$userArgs<ExtArgs> = {}>(args?: Subset<T, Conversation$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Conversation model
   */ 
  interface ConversationFieldRefs {
    readonly id: FieldRef<"Conversation", 'String'>
    readonly userId: FieldRef<"Conversation", 'Int'>
    readonly title: FieldRef<"Conversation", 'String'>
    readonly createdAt: FieldRef<"Conversation", 'DateTime'>
    readonly updatedAt: FieldRef<"Conversation", 'DateTime'>
    readonly lastMessageAt: FieldRef<"Conversation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Conversation findUnique
   */
  export type ConversationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation findUniqueOrThrow
   */
  export type ConversationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation findFirst
   */
  export type ConversationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conversations.
     */
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Conversation findFirstOrThrow
   */
  export type ConversationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conversations.
     */
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Conversation findMany
   */
  export type ConversationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversations to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Conversation create
   */
  export type ConversationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The data needed to create a Conversation.
     */
    data: XOR<ConversationCreateInput, ConversationUncheckedCreateInput>
  }

  /**
   * Conversation createMany
   */
  export type ConversationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Conversations.
     */
    data: ConversationCreateManyInput | ConversationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Conversation createManyAndReturn
   */
  export type ConversationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Conversations.
     */
    data: ConversationCreateManyInput | ConversationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Conversation update
   */
  export type ConversationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The data needed to update a Conversation.
     */
    data: XOR<ConversationUpdateInput, ConversationUncheckedUpdateInput>
    /**
     * Choose, which Conversation to update.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation updateMany
   */
  export type ConversationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Conversations.
     */
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyInput>
    /**
     * Filter which Conversations to update
     */
    where?: ConversationWhereInput
  }

  /**
   * Conversation upsert
   */
  export type ConversationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The filter to search for the Conversation to update in case it exists.
     */
    where: ConversationWhereUniqueInput
    /**
     * In case the Conversation found by the `where` argument doesn't exist, create a new Conversation with this data.
     */
    create: XOR<ConversationCreateInput, ConversationUncheckedCreateInput>
    /**
     * In case the Conversation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConversationUpdateInput, ConversationUncheckedUpdateInput>
  }

  /**
   * Conversation delete
   */
  export type ConversationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter which Conversation to delete.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation deleteMany
   */
  export type ConversationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conversations to delete
     */
    where?: ConversationWhereInput
  }

  /**
   * Conversation.messages
   */
  export type Conversation$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Conversation.goals
   */
  export type Conversation$goalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
    where?: GoalWhereInput
    orderBy?: GoalOrderByWithRelationInput | GoalOrderByWithRelationInput[]
    cursor?: GoalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GoalScalarFieldEnum | GoalScalarFieldEnum[]
  }

  /**
   * Conversation.user
   */
  export type Conversation$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Conversation without action
   */
  export type ConversationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
  }


  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _avg: MessageAvgAggregateOutputType | null
    _sum: MessageSumAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageAvgAggregateOutputType = {
    tokenCount: number | null
    cost: number | null
  }

  export type MessageSumAggregateOutputType = {
    tokenCount: number | null
    cost: number | null
  }

  export type MessageMinAggregateOutputType = {
    id: string | null
    conversationId: string | null
    role: $Enums.MessageRole | null
    content: string | null
    tokenCount: number | null
    cost: number | null
    createdAt: Date | null
  }

  export type MessageMaxAggregateOutputType = {
    id: string | null
    conversationId: string | null
    role: $Enums.MessageRole | null
    content: string | null
    tokenCount: number | null
    cost: number | null
    createdAt: Date | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    conversationId: number
    role: number
    content: number
    metadata: number
    tokenCount: number
    cost: number
    createdAt: number
    _all: number
  }


  export type MessageAvgAggregateInputType = {
    tokenCount?: true
    cost?: true
  }

  export type MessageSumAggregateInputType = {
    tokenCount?: true
    cost?: true
  }

  export type MessageMinAggregateInputType = {
    id?: true
    conversationId?: true
    role?: true
    content?: true
    tokenCount?: true
    cost?: true
    createdAt?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    conversationId?: true
    role?: true
    content?: true
    tokenCount?: true
    cost?: true
    createdAt?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    conversationId?: true
    role?: true
    content?: true
    metadata?: true
    tokenCount?: true
    cost?: true
    createdAt?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MessageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MessageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _avg?: MessageAvgAggregateInputType
    _sum?: MessageSumAggregateInputType
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: string
    conversationId: string
    role: $Enums.MessageRole
    content: string
    metadata: JsonValue | null
    tokenCount: number | null
    cost: number | null
    createdAt: Date
    _count: MessageCountAggregateOutputType | null
    _avg: MessageAvgAggregateOutputType | null
    _sum: MessageSumAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    role?: boolean
    content?: boolean
    metadata?: boolean
    tokenCount?: boolean
    cost?: boolean
    createdAt?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    role?: boolean
    content?: boolean
    metadata?: boolean
    tokenCount?: boolean
    cost?: boolean
    createdAt?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectScalar = {
    id?: boolean
    conversationId?: boolean
    role?: boolean
    content?: boolean
    metadata?: boolean
    tokenCount?: boolean
    cost?: boolean
    createdAt?: boolean
  }

  export type MessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }
  export type MessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }

  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {
      conversation: Prisma.$ConversationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      conversationId: string
      role: $Enums.MessageRole
      content: string
      metadata: Prisma.JsonValue | null
      tokenCount: number | null
      cost: number | null
      createdAt: Date
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageFindUniqueArgs>(args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageFindFirstArgs>(args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageFindManyArgs>(args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends MessageCreateArgs>(args: SelectSubset<T, MessageCreateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageCreateManyArgs>(args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Messages and returns the data saved in the database.
     * @param {MessageCreateManyAndReturnArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends MessageDeleteArgs>(args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageUpdateArgs>(args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageDeleteManyArgs>(args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageUpdateManyArgs>(args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpsertArgs>(args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conversation<T extends ConversationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConversationDefaultArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Message model
   */ 
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'String'>
    readonly conversationId: FieldRef<"Message", 'String'>
    readonly role: FieldRef<"Message", 'MessageRole'>
    readonly content: FieldRef<"Message", 'String'>
    readonly metadata: FieldRef<"Message", 'Json'>
    readonly tokenCount: FieldRef<"Message", 'Int'>
    readonly cost: FieldRef<"Message", 'Float'>
    readonly createdAt: FieldRef<"Message", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Message createManyAndReturn
   */
  export type MessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
  }

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }

  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
  }

  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
  }


  /**
   * Model Goal
   */

  export type AggregateGoal = {
    _count: GoalCountAggregateOutputType | null
    _avg: GoalAvgAggregateOutputType | null
    _sum: GoalSumAggregateOutputType | null
    _min: GoalMinAggregateOutputType | null
    _max: GoalMaxAggregateOutputType | null
  }

  export type GoalAvgAggregateOutputType = {
    userId: number | null
  }

  export type GoalSumAggregateOutputType = {
    userId: number | null
  }

  export type GoalMinAggregateOutputType = {
    id: string | null
    conversationId: string | null
    userId: number | null
    title: string | null
    description: string | null
    type: $Enums.GoalType | null
    status: $Enums.GoalStatus | null
    targetDate: Date | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GoalMaxAggregateOutputType = {
    id: string | null
    conversationId: string | null
    userId: number | null
    title: string | null
    description: string | null
    type: $Enums.GoalType | null
    status: $Enums.GoalStatus | null
    targetDate: Date | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GoalCountAggregateOutputType = {
    id: number
    conversationId: number
    userId: number
    title: number
    description: number
    type: number
    status: number
    targetDate: number
    completedAt: number
    createdAt: number
    updatedAt: number
    metadata: number
    _all: number
  }


  export type GoalAvgAggregateInputType = {
    userId?: true
  }

  export type GoalSumAggregateInputType = {
    userId?: true
  }

  export type GoalMinAggregateInputType = {
    id?: true
    conversationId?: true
    userId?: true
    title?: true
    description?: true
    type?: true
    status?: true
    targetDate?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GoalMaxAggregateInputType = {
    id?: true
    conversationId?: true
    userId?: true
    title?: true
    description?: true
    type?: true
    status?: true
    targetDate?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GoalCountAggregateInputType = {
    id?: true
    conversationId?: true
    userId?: true
    title?: true
    description?: true
    type?: true
    status?: true
    targetDate?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
    metadata?: true
    _all?: true
  }

  export type GoalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Goal to aggregate.
     */
    where?: GoalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Goals to fetch.
     */
    orderBy?: GoalOrderByWithRelationInput | GoalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GoalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Goals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Goals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Goals
    **/
    _count?: true | GoalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GoalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GoalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GoalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GoalMaxAggregateInputType
  }

  export type GetGoalAggregateType<T extends GoalAggregateArgs> = {
        [P in keyof T & keyof AggregateGoal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGoal[P]>
      : GetScalarType<T[P], AggregateGoal[P]>
  }




  export type GoalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GoalWhereInput
    orderBy?: GoalOrderByWithAggregationInput | GoalOrderByWithAggregationInput[]
    by: GoalScalarFieldEnum[] | GoalScalarFieldEnum
    having?: GoalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GoalCountAggregateInputType | true
    _avg?: GoalAvgAggregateInputType
    _sum?: GoalSumAggregateInputType
    _min?: GoalMinAggregateInputType
    _max?: GoalMaxAggregateInputType
  }

  export type GoalGroupByOutputType = {
    id: string
    conversationId: string | null
    userId: number
    title: string
    description: string | null
    type: $Enums.GoalType
    status: $Enums.GoalStatus
    targetDate: Date | null
    completedAt: Date | null
    createdAt: Date
    updatedAt: Date
    metadata: JsonValue | null
    _count: GoalCountAggregateOutputType | null
    _avg: GoalAvgAggregateOutputType | null
    _sum: GoalSumAggregateOutputType | null
    _min: GoalMinAggregateOutputType | null
    _max: GoalMaxAggregateOutputType | null
  }

  type GetGoalGroupByPayload<T extends GoalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GoalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GoalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GoalGroupByOutputType[P]>
            : GetScalarType<T[P], GoalGroupByOutputType[P]>
        }
      >
    >


  export type GoalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    status?: boolean
    targetDate?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    metadata?: boolean
    conversation?: boolean | Goal$conversationArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["goal"]>

  export type GoalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    status?: boolean
    targetDate?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    metadata?: boolean
    conversation?: boolean | Goal$conversationArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["goal"]>

  export type GoalSelectScalar = {
    id?: boolean
    conversationId?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    status?: boolean
    targetDate?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    metadata?: boolean
  }

  export type GoalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | Goal$conversationArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type GoalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | Goal$conversationArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $GoalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Goal"
    objects: {
      conversation: Prisma.$ConversationPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      conversationId: string | null
      userId: number
      title: string
      description: string | null
      type: $Enums.GoalType
      status: $Enums.GoalStatus
      targetDate: Date | null
      completedAt: Date | null
      createdAt: Date
      updatedAt: Date
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["goal"]>
    composites: {}
  }

  type GoalGetPayload<S extends boolean | null | undefined | GoalDefaultArgs> = $Result.GetResult<Prisma.$GoalPayload, S>

  type GoalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GoalFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GoalCountAggregateInputType | true
    }

  export interface GoalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Goal'], meta: { name: 'Goal' } }
    /**
     * Find zero or one Goal that matches the filter.
     * @param {GoalFindUniqueArgs} args - Arguments to find a Goal
     * @example
     * // Get one Goal
     * const goal = await prisma.goal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GoalFindUniqueArgs>(args: SelectSubset<T, GoalFindUniqueArgs<ExtArgs>>): Prisma__GoalClient<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Goal that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {GoalFindUniqueOrThrowArgs} args - Arguments to find a Goal
     * @example
     * // Get one Goal
     * const goal = await prisma.goal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GoalFindUniqueOrThrowArgs>(args: SelectSubset<T, GoalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GoalClient<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Goal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalFindFirstArgs} args - Arguments to find a Goal
     * @example
     * // Get one Goal
     * const goal = await prisma.goal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GoalFindFirstArgs>(args?: SelectSubset<T, GoalFindFirstArgs<ExtArgs>>): Prisma__GoalClient<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Goal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalFindFirstOrThrowArgs} args - Arguments to find a Goal
     * @example
     * // Get one Goal
     * const goal = await prisma.goal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GoalFindFirstOrThrowArgs>(args?: SelectSubset<T, GoalFindFirstOrThrowArgs<ExtArgs>>): Prisma__GoalClient<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Goals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Goals
     * const goals = await prisma.goal.findMany()
     * 
     * // Get first 10 Goals
     * const goals = await prisma.goal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const goalWithIdOnly = await prisma.goal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GoalFindManyArgs>(args?: SelectSubset<T, GoalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Goal.
     * @param {GoalCreateArgs} args - Arguments to create a Goal.
     * @example
     * // Create one Goal
     * const Goal = await prisma.goal.create({
     *   data: {
     *     // ... data to create a Goal
     *   }
     * })
     * 
     */
    create<T extends GoalCreateArgs>(args: SelectSubset<T, GoalCreateArgs<ExtArgs>>): Prisma__GoalClient<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Goals.
     * @param {GoalCreateManyArgs} args - Arguments to create many Goals.
     * @example
     * // Create many Goals
     * const goal = await prisma.goal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GoalCreateManyArgs>(args?: SelectSubset<T, GoalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Goals and returns the data saved in the database.
     * @param {GoalCreateManyAndReturnArgs} args - Arguments to create many Goals.
     * @example
     * // Create many Goals
     * const goal = await prisma.goal.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Goals and only return the `id`
     * const goalWithIdOnly = await prisma.goal.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GoalCreateManyAndReturnArgs>(args?: SelectSubset<T, GoalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Goal.
     * @param {GoalDeleteArgs} args - Arguments to delete one Goal.
     * @example
     * // Delete one Goal
     * const Goal = await prisma.goal.delete({
     *   where: {
     *     // ... filter to delete one Goal
     *   }
     * })
     * 
     */
    delete<T extends GoalDeleteArgs>(args: SelectSubset<T, GoalDeleteArgs<ExtArgs>>): Prisma__GoalClient<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Goal.
     * @param {GoalUpdateArgs} args - Arguments to update one Goal.
     * @example
     * // Update one Goal
     * const goal = await prisma.goal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GoalUpdateArgs>(args: SelectSubset<T, GoalUpdateArgs<ExtArgs>>): Prisma__GoalClient<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Goals.
     * @param {GoalDeleteManyArgs} args - Arguments to filter Goals to delete.
     * @example
     * // Delete a few Goals
     * const { count } = await prisma.goal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GoalDeleteManyArgs>(args?: SelectSubset<T, GoalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Goals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Goals
     * const goal = await prisma.goal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GoalUpdateManyArgs>(args: SelectSubset<T, GoalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Goal.
     * @param {GoalUpsertArgs} args - Arguments to update or create a Goal.
     * @example
     * // Update or create a Goal
     * const goal = await prisma.goal.upsert({
     *   create: {
     *     // ... data to create a Goal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Goal we want to update
     *   }
     * })
     */
    upsert<T extends GoalUpsertArgs>(args: SelectSubset<T, GoalUpsertArgs<ExtArgs>>): Prisma__GoalClient<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Goals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalCountArgs} args - Arguments to filter Goals to count.
     * @example
     * // Count the number of Goals
     * const count = await prisma.goal.count({
     *   where: {
     *     // ... the filter for the Goals we want to count
     *   }
     * })
    **/
    count<T extends GoalCountArgs>(
      args?: Subset<T, GoalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GoalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Goal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GoalAggregateArgs>(args: Subset<T, GoalAggregateArgs>): Prisma.PrismaPromise<GetGoalAggregateType<T>>

    /**
     * Group by Goal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GoalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GoalGroupByArgs['orderBy'] }
        : { orderBy?: GoalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GoalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGoalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Goal model
   */
  readonly fields: GoalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Goal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GoalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conversation<T extends Goal$conversationArgs<ExtArgs> = {}>(args?: Subset<T, Goal$conversationArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Goal model
   */ 
  interface GoalFieldRefs {
    readonly id: FieldRef<"Goal", 'String'>
    readonly conversationId: FieldRef<"Goal", 'String'>
    readonly userId: FieldRef<"Goal", 'Int'>
    readonly title: FieldRef<"Goal", 'String'>
    readonly description: FieldRef<"Goal", 'String'>
    readonly type: FieldRef<"Goal", 'GoalType'>
    readonly status: FieldRef<"Goal", 'GoalStatus'>
    readonly targetDate: FieldRef<"Goal", 'DateTime'>
    readonly completedAt: FieldRef<"Goal", 'DateTime'>
    readonly createdAt: FieldRef<"Goal", 'DateTime'>
    readonly updatedAt: FieldRef<"Goal", 'DateTime'>
    readonly metadata: FieldRef<"Goal", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Goal findUnique
   */
  export type GoalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
    /**
     * Filter, which Goal to fetch.
     */
    where: GoalWhereUniqueInput
  }

  /**
   * Goal findUniqueOrThrow
   */
  export type GoalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
    /**
     * Filter, which Goal to fetch.
     */
    where: GoalWhereUniqueInput
  }

  /**
   * Goal findFirst
   */
  export type GoalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
    /**
     * Filter, which Goal to fetch.
     */
    where?: GoalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Goals to fetch.
     */
    orderBy?: GoalOrderByWithRelationInput | GoalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Goals.
     */
    cursor?: GoalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Goals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Goals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Goals.
     */
    distinct?: GoalScalarFieldEnum | GoalScalarFieldEnum[]
  }

  /**
   * Goal findFirstOrThrow
   */
  export type GoalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
    /**
     * Filter, which Goal to fetch.
     */
    where?: GoalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Goals to fetch.
     */
    orderBy?: GoalOrderByWithRelationInput | GoalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Goals.
     */
    cursor?: GoalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Goals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Goals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Goals.
     */
    distinct?: GoalScalarFieldEnum | GoalScalarFieldEnum[]
  }

  /**
   * Goal findMany
   */
  export type GoalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
    /**
     * Filter, which Goals to fetch.
     */
    where?: GoalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Goals to fetch.
     */
    orderBy?: GoalOrderByWithRelationInput | GoalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Goals.
     */
    cursor?: GoalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Goals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Goals.
     */
    skip?: number
    distinct?: GoalScalarFieldEnum | GoalScalarFieldEnum[]
  }

  /**
   * Goal create
   */
  export type GoalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
    /**
     * The data needed to create a Goal.
     */
    data: XOR<GoalCreateInput, GoalUncheckedCreateInput>
  }

  /**
   * Goal createMany
   */
  export type GoalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Goals.
     */
    data: GoalCreateManyInput | GoalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Goal createManyAndReturn
   */
  export type GoalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Goals.
     */
    data: GoalCreateManyInput | GoalCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Goal update
   */
  export type GoalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
    /**
     * The data needed to update a Goal.
     */
    data: XOR<GoalUpdateInput, GoalUncheckedUpdateInput>
    /**
     * Choose, which Goal to update.
     */
    where: GoalWhereUniqueInput
  }

  /**
   * Goal updateMany
   */
  export type GoalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Goals.
     */
    data: XOR<GoalUpdateManyMutationInput, GoalUncheckedUpdateManyInput>
    /**
     * Filter which Goals to update
     */
    where?: GoalWhereInput
  }

  /**
   * Goal upsert
   */
  export type GoalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
    /**
     * The filter to search for the Goal to update in case it exists.
     */
    where: GoalWhereUniqueInput
    /**
     * In case the Goal found by the `where` argument doesn't exist, create a new Goal with this data.
     */
    create: XOR<GoalCreateInput, GoalUncheckedCreateInput>
    /**
     * In case the Goal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GoalUpdateInput, GoalUncheckedUpdateInput>
  }

  /**
   * Goal delete
   */
  export type GoalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
    /**
     * Filter which Goal to delete.
     */
    where: GoalWhereUniqueInput
  }

  /**
   * Goal deleteMany
   */
  export type GoalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Goals to delete
     */
    where?: GoalWhereInput
  }

  /**
   * Goal.conversation
   */
  export type Goal$conversationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    where?: ConversationWhereInput
  }

  /**
   * Goal without action
   */
  export type GoalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
  }


  /**
   * Model MessageUsage
   */

  export type AggregateMessageUsage = {
    _count: MessageUsageCountAggregateOutputType | null
    _avg: MessageUsageAvgAggregateOutputType | null
    _sum: MessageUsageSumAggregateOutputType | null
    _min: MessageUsageMinAggregateOutputType | null
    _max: MessageUsageMaxAggregateOutputType | null
  }

  export type MessageUsageAvgAggregateOutputType = {
    userId: number | null
    count: number | null
  }

  export type MessageUsageSumAggregateOutputType = {
    userId: number | null
    count: number | null
  }

  export type MessageUsageMinAggregateOutputType = {
    id: string | null
    userId: number | null
    ip: string | null
    date: Date | null
    count: number | null
    resetAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MessageUsageMaxAggregateOutputType = {
    id: string | null
    userId: number | null
    ip: string | null
    date: Date | null
    count: number | null
    resetAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MessageUsageCountAggregateOutputType = {
    id: number
    userId: number
    ip: number
    date: number
    count: number
    resetAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MessageUsageAvgAggregateInputType = {
    userId?: true
    count?: true
  }

  export type MessageUsageSumAggregateInputType = {
    userId?: true
    count?: true
  }

  export type MessageUsageMinAggregateInputType = {
    id?: true
    userId?: true
    ip?: true
    date?: true
    count?: true
    resetAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MessageUsageMaxAggregateInputType = {
    id?: true
    userId?: true
    ip?: true
    date?: true
    count?: true
    resetAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MessageUsageCountAggregateInputType = {
    id?: true
    userId?: true
    ip?: true
    date?: true
    count?: true
    resetAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MessageUsageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageUsage to aggregate.
     */
    where?: MessageUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageUsages to fetch.
     */
    orderBy?: MessageUsageOrderByWithRelationInput | MessageUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MessageUsages
    **/
    _count?: true | MessageUsageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MessageUsageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MessageUsageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageUsageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageUsageMaxAggregateInputType
  }

  export type GetMessageUsageAggregateType<T extends MessageUsageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessageUsage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessageUsage[P]>
      : GetScalarType<T[P], AggregateMessageUsage[P]>
  }




  export type MessageUsageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageUsageWhereInput
    orderBy?: MessageUsageOrderByWithAggregationInput | MessageUsageOrderByWithAggregationInput[]
    by: MessageUsageScalarFieldEnum[] | MessageUsageScalarFieldEnum
    having?: MessageUsageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageUsageCountAggregateInputType | true
    _avg?: MessageUsageAvgAggregateInputType
    _sum?: MessageUsageSumAggregateInputType
    _min?: MessageUsageMinAggregateInputType
    _max?: MessageUsageMaxAggregateInputType
  }

  export type MessageUsageGroupByOutputType = {
    id: string
    userId: number | null
    ip: string | null
    date: Date
    count: number
    resetAt: Date
    createdAt: Date
    updatedAt: Date
    _count: MessageUsageCountAggregateOutputType | null
    _avg: MessageUsageAvgAggregateOutputType | null
    _sum: MessageUsageSumAggregateOutputType | null
    _min: MessageUsageMinAggregateOutputType | null
    _max: MessageUsageMaxAggregateOutputType | null
  }

  type GetMessageUsageGroupByPayload<T extends MessageUsageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageUsageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageUsageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageUsageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageUsageGroupByOutputType[P]>
        }
      >
    >


  export type MessageUsageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    ip?: boolean
    date?: boolean
    count?: boolean
    resetAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["messageUsage"]>

  export type MessageUsageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    ip?: boolean
    date?: boolean
    count?: boolean
    resetAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["messageUsage"]>

  export type MessageUsageSelectScalar = {
    id?: boolean
    userId?: boolean
    ip?: boolean
    date?: boolean
    count?: boolean
    resetAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $MessageUsagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MessageUsage"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: number | null
      ip: string | null
      date: Date
      count: number
      resetAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["messageUsage"]>
    composites: {}
  }

  type MessageUsageGetPayload<S extends boolean | null | undefined | MessageUsageDefaultArgs> = $Result.GetResult<Prisma.$MessageUsagePayload, S>

  type MessageUsageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MessageUsageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MessageUsageCountAggregateInputType | true
    }

  export interface MessageUsageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MessageUsage'], meta: { name: 'MessageUsage' } }
    /**
     * Find zero or one MessageUsage that matches the filter.
     * @param {MessageUsageFindUniqueArgs} args - Arguments to find a MessageUsage
     * @example
     * // Get one MessageUsage
     * const messageUsage = await prisma.messageUsage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageUsageFindUniqueArgs>(args: SelectSubset<T, MessageUsageFindUniqueArgs<ExtArgs>>): Prisma__MessageUsageClient<$Result.GetResult<Prisma.$MessageUsagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MessageUsage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MessageUsageFindUniqueOrThrowArgs} args - Arguments to find a MessageUsage
     * @example
     * // Get one MessageUsage
     * const messageUsage = await prisma.messageUsage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageUsageFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageUsageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageUsageClient<$Result.GetResult<Prisma.$MessageUsagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MessageUsage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUsageFindFirstArgs} args - Arguments to find a MessageUsage
     * @example
     * // Get one MessageUsage
     * const messageUsage = await prisma.messageUsage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageUsageFindFirstArgs>(args?: SelectSubset<T, MessageUsageFindFirstArgs<ExtArgs>>): Prisma__MessageUsageClient<$Result.GetResult<Prisma.$MessageUsagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MessageUsage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUsageFindFirstOrThrowArgs} args - Arguments to find a MessageUsage
     * @example
     * // Get one MessageUsage
     * const messageUsage = await prisma.messageUsage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageUsageFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageUsageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageUsageClient<$Result.GetResult<Prisma.$MessageUsagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MessageUsages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUsageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MessageUsages
     * const messageUsages = await prisma.messageUsage.findMany()
     * 
     * // Get first 10 MessageUsages
     * const messageUsages = await prisma.messageUsage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageUsageWithIdOnly = await prisma.messageUsage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageUsageFindManyArgs>(args?: SelectSubset<T, MessageUsageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageUsagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MessageUsage.
     * @param {MessageUsageCreateArgs} args - Arguments to create a MessageUsage.
     * @example
     * // Create one MessageUsage
     * const MessageUsage = await prisma.messageUsage.create({
     *   data: {
     *     // ... data to create a MessageUsage
     *   }
     * })
     * 
     */
    create<T extends MessageUsageCreateArgs>(args: SelectSubset<T, MessageUsageCreateArgs<ExtArgs>>): Prisma__MessageUsageClient<$Result.GetResult<Prisma.$MessageUsagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MessageUsages.
     * @param {MessageUsageCreateManyArgs} args - Arguments to create many MessageUsages.
     * @example
     * // Create many MessageUsages
     * const messageUsage = await prisma.messageUsage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageUsageCreateManyArgs>(args?: SelectSubset<T, MessageUsageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MessageUsages and returns the data saved in the database.
     * @param {MessageUsageCreateManyAndReturnArgs} args - Arguments to create many MessageUsages.
     * @example
     * // Create many MessageUsages
     * const messageUsage = await prisma.messageUsage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MessageUsages and only return the `id`
     * const messageUsageWithIdOnly = await prisma.messageUsage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageUsageCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageUsageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageUsagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MessageUsage.
     * @param {MessageUsageDeleteArgs} args - Arguments to delete one MessageUsage.
     * @example
     * // Delete one MessageUsage
     * const MessageUsage = await prisma.messageUsage.delete({
     *   where: {
     *     // ... filter to delete one MessageUsage
     *   }
     * })
     * 
     */
    delete<T extends MessageUsageDeleteArgs>(args: SelectSubset<T, MessageUsageDeleteArgs<ExtArgs>>): Prisma__MessageUsageClient<$Result.GetResult<Prisma.$MessageUsagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MessageUsage.
     * @param {MessageUsageUpdateArgs} args - Arguments to update one MessageUsage.
     * @example
     * // Update one MessageUsage
     * const messageUsage = await prisma.messageUsage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageUsageUpdateArgs>(args: SelectSubset<T, MessageUsageUpdateArgs<ExtArgs>>): Prisma__MessageUsageClient<$Result.GetResult<Prisma.$MessageUsagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MessageUsages.
     * @param {MessageUsageDeleteManyArgs} args - Arguments to filter MessageUsages to delete.
     * @example
     * // Delete a few MessageUsages
     * const { count } = await prisma.messageUsage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageUsageDeleteManyArgs>(args?: SelectSubset<T, MessageUsageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MessageUsages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUsageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MessageUsages
     * const messageUsage = await prisma.messageUsage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageUsageUpdateManyArgs>(args: SelectSubset<T, MessageUsageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MessageUsage.
     * @param {MessageUsageUpsertArgs} args - Arguments to update or create a MessageUsage.
     * @example
     * // Update or create a MessageUsage
     * const messageUsage = await prisma.messageUsage.upsert({
     *   create: {
     *     // ... data to create a MessageUsage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MessageUsage we want to update
     *   }
     * })
     */
    upsert<T extends MessageUsageUpsertArgs>(args: SelectSubset<T, MessageUsageUpsertArgs<ExtArgs>>): Prisma__MessageUsageClient<$Result.GetResult<Prisma.$MessageUsagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MessageUsages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUsageCountArgs} args - Arguments to filter MessageUsages to count.
     * @example
     * // Count the number of MessageUsages
     * const count = await prisma.messageUsage.count({
     *   where: {
     *     // ... the filter for the MessageUsages we want to count
     *   }
     * })
    **/
    count<T extends MessageUsageCountArgs>(
      args?: Subset<T, MessageUsageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageUsageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MessageUsage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUsageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageUsageAggregateArgs>(args: Subset<T, MessageUsageAggregateArgs>): Prisma.PrismaPromise<GetMessageUsageAggregateType<T>>

    /**
     * Group by MessageUsage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUsageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageUsageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageUsageGroupByArgs['orderBy'] }
        : { orderBy?: MessageUsageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageUsageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageUsageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MessageUsage model
   */
  readonly fields: MessageUsageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MessageUsage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageUsageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MessageUsage model
   */ 
  interface MessageUsageFieldRefs {
    readonly id: FieldRef<"MessageUsage", 'String'>
    readonly userId: FieldRef<"MessageUsage", 'Int'>
    readonly ip: FieldRef<"MessageUsage", 'String'>
    readonly date: FieldRef<"MessageUsage", 'DateTime'>
    readonly count: FieldRef<"MessageUsage", 'Int'>
    readonly resetAt: FieldRef<"MessageUsage", 'DateTime'>
    readonly createdAt: FieldRef<"MessageUsage", 'DateTime'>
    readonly updatedAt: FieldRef<"MessageUsage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MessageUsage findUnique
   */
  export type MessageUsageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageUsage
     */
    select?: MessageUsageSelect<ExtArgs> | null
    /**
     * Filter, which MessageUsage to fetch.
     */
    where: MessageUsageWhereUniqueInput
  }

  /**
   * MessageUsage findUniqueOrThrow
   */
  export type MessageUsageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageUsage
     */
    select?: MessageUsageSelect<ExtArgs> | null
    /**
     * Filter, which MessageUsage to fetch.
     */
    where: MessageUsageWhereUniqueInput
  }

  /**
   * MessageUsage findFirst
   */
  export type MessageUsageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageUsage
     */
    select?: MessageUsageSelect<ExtArgs> | null
    /**
     * Filter, which MessageUsage to fetch.
     */
    where?: MessageUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageUsages to fetch.
     */
    orderBy?: MessageUsageOrderByWithRelationInput | MessageUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageUsages.
     */
    cursor?: MessageUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageUsages.
     */
    distinct?: MessageUsageScalarFieldEnum | MessageUsageScalarFieldEnum[]
  }

  /**
   * MessageUsage findFirstOrThrow
   */
  export type MessageUsageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageUsage
     */
    select?: MessageUsageSelect<ExtArgs> | null
    /**
     * Filter, which MessageUsage to fetch.
     */
    where?: MessageUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageUsages to fetch.
     */
    orderBy?: MessageUsageOrderByWithRelationInput | MessageUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageUsages.
     */
    cursor?: MessageUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageUsages.
     */
    distinct?: MessageUsageScalarFieldEnum | MessageUsageScalarFieldEnum[]
  }

  /**
   * MessageUsage findMany
   */
  export type MessageUsageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageUsage
     */
    select?: MessageUsageSelect<ExtArgs> | null
    /**
     * Filter, which MessageUsages to fetch.
     */
    where?: MessageUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageUsages to fetch.
     */
    orderBy?: MessageUsageOrderByWithRelationInput | MessageUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MessageUsages.
     */
    cursor?: MessageUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageUsages.
     */
    skip?: number
    distinct?: MessageUsageScalarFieldEnum | MessageUsageScalarFieldEnum[]
  }

  /**
   * MessageUsage create
   */
  export type MessageUsageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageUsage
     */
    select?: MessageUsageSelect<ExtArgs> | null
    /**
     * The data needed to create a MessageUsage.
     */
    data: XOR<MessageUsageCreateInput, MessageUsageUncheckedCreateInput>
  }

  /**
   * MessageUsage createMany
   */
  export type MessageUsageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MessageUsages.
     */
    data: MessageUsageCreateManyInput | MessageUsageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MessageUsage createManyAndReturn
   */
  export type MessageUsageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageUsage
     */
    select?: MessageUsageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MessageUsages.
     */
    data: MessageUsageCreateManyInput | MessageUsageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MessageUsage update
   */
  export type MessageUsageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageUsage
     */
    select?: MessageUsageSelect<ExtArgs> | null
    /**
     * The data needed to update a MessageUsage.
     */
    data: XOR<MessageUsageUpdateInput, MessageUsageUncheckedUpdateInput>
    /**
     * Choose, which MessageUsage to update.
     */
    where: MessageUsageWhereUniqueInput
  }

  /**
   * MessageUsage updateMany
   */
  export type MessageUsageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MessageUsages.
     */
    data: XOR<MessageUsageUpdateManyMutationInput, MessageUsageUncheckedUpdateManyInput>
    /**
     * Filter which MessageUsages to update
     */
    where?: MessageUsageWhereInput
  }

  /**
   * MessageUsage upsert
   */
  export type MessageUsageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageUsage
     */
    select?: MessageUsageSelect<ExtArgs> | null
    /**
     * The filter to search for the MessageUsage to update in case it exists.
     */
    where: MessageUsageWhereUniqueInput
    /**
     * In case the MessageUsage found by the `where` argument doesn't exist, create a new MessageUsage with this data.
     */
    create: XOR<MessageUsageCreateInput, MessageUsageUncheckedCreateInput>
    /**
     * In case the MessageUsage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUsageUpdateInput, MessageUsageUncheckedUpdateInput>
  }

  /**
   * MessageUsage delete
   */
  export type MessageUsageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageUsage
     */
    select?: MessageUsageSelect<ExtArgs> | null
    /**
     * Filter which MessageUsage to delete.
     */
    where: MessageUsageWhereUniqueInput
  }

  /**
   * MessageUsage deleteMany
   */
  export type MessageUsageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageUsages to delete
     */
    where?: MessageUsageWhereInput
  }

  /**
   * MessageUsage without action
   */
  export type MessageUsageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageUsage
     */
    select?: MessageUsageSelect<ExtArgs> | null
  }


  /**
   * Model Routine
   */

  export type AggregateRoutine = {
    _count: RoutineCountAggregateOutputType | null
    _avg: RoutineAvgAggregateOutputType | null
    _sum: RoutineSumAggregateOutputType | null
    _min: RoutineMinAggregateOutputType | null
    _max: RoutineMaxAggregateOutputType | null
  }

  export type RoutineAvgAggregateOutputType = {
    userId: number | null
    runCount: number | null
  }

  export type RoutineSumAggregateOutputType = {
    userId: number | null
    runCount: number | null
  }

  export type RoutineMinAggregateOutputType = {
    id: string | null
    userId: number | null
    title: string | null
    description: string | null
    type: $Enums.RoutineType | null
    frequency: string | null
    schedule: string | null
    isActive: boolean | null
    lastRun: Date | null
    nextRun: Date | null
    runCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoutineMaxAggregateOutputType = {
    id: string | null
    userId: number | null
    title: string | null
    description: string | null
    type: $Enums.RoutineType | null
    frequency: string | null
    schedule: string | null
    isActive: boolean | null
    lastRun: Date | null
    nextRun: Date | null
    runCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoutineCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    description: number
    type: number
    frequency: number
    schedule: number
    config: number
    isActive: number
    lastRun: number
    nextRun: number
    runCount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RoutineAvgAggregateInputType = {
    userId?: true
    runCount?: true
  }

  export type RoutineSumAggregateInputType = {
    userId?: true
    runCount?: true
  }

  export type RoutineMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    description?: true
    type?: true
    frequency?: true
    schedule?: true
    isActive?: true
    lastRun?: true
    nextRun?: true
    runCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoutineMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    description?: true
    type?: true
    frequency?: true
    schedule?: true
    isActive?: true
    lastRun?: true
    nextRun?: true
    runCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoutineCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    description?: true
    type?: true
    frequency?: true
    schedule?: true
    config?: true
    isActive?: true
    lastRun?: true
    nextRun?: true
    runCount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RoutineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Routine to aggregate.
     */
    where?: RoutineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Routines to fetch.
     */
    orderBy?: RoutineOrderByWithRelationInput | RoutineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoutineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Routines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Routines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Routines
    **/
    _count?: true | RoutineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoutineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoutineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoutineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoutineMaxAggregateInputType
  }

  export type GetRoutineAggregateType<T extends RoutineAggregateArgs> = {
        [P in keyof T & keyof AggregateRoutine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoutine[P]>
      : GetScalarType<T[P], AggregateRoutine[P]>
  }




  export type RoutineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoutineWhereInput
    orderBy?: RoutineOrderByWithAggregationInput | RoutineOrderByWithAggregationInput[]
    by: RoutineScalarFieldEnum[] | RoutineScalarFieldEnum
    having?: RoutineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoutineCountAggregateInputType | true
    _avg?: RoutineAvgAggregateInputType
    _sum?: RoutineSumAggregateInputType
    _min?: RoutineMinAggregateInputType
    _max?: RoutineMaxAggregateInputType
  }

  export type RoutineGroupByOutputType = {
    id: string
    userId: number
    title: string
    description: string | null
    type: $Enums.RoutineType
    frequency: string
    schedule: string
    config: JsonValue | null
    isActive: boolean
    lastRun: Date | null
    nextRun: Date | null
    runCount: number
    createdAt: Date
    updatedAt: Date
    _count: RoutineCountAggregateOutputType | null
    _avg: RoutineAvgAggregateOutputType | null
    _sum: RoutineSumAggregateOutputType | null
    _min: RoutineMinAggregateOutputType | null
    _max: RoutineMaxAggregateOutputType | null
  }

  type GetRoutineGroupByPayload<T extends RoutineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoutineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoutineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoutineGroupByOutputType[P]>
            : GetScalarType<T[P], RoutineGroupByOutputType[P]>
        }
      >
    >


  export type RoutineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    frequency?: boolean
    schedule?: boolean
    config?: boolean
    isActive?: boolean
    lastRun?: boolean
    nextRun?: boolean
    runCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    executions?: boolean | Routine$executionsArgs<ExtArgs>
    _count?: boolean | RoutineCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["routine"]>

  export type RoutineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    frequency?: boolean
    schedule?: boolean
    config?: boolean
    isActive?: boolean
    lastRun?: boolean
    nextRun?: boolean
    runCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["routine"]>

  export type RoutineSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    frequency?: boolean
    schedule?: boolean
    config?: boolean
    isActive?: boolean
    lastRun?: boolean
    nextRun?: boolean
    runCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RoutineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    executions?: boolean | Routine$executionsArgs<ExtArgs>
    _count?: boolean | RoutineCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoutineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RoutinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Routine"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      executions: Prisma.$RoutineExecutionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: number
      title: string
      description: string | null
      type: $Enums.RoutineType
      frequency: string
      schedule: string
      config: Prisma.JsonValue | null
      isActive: boolean
      lastRun: Date | null
      nextRun: Date | null
      runCount: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["routine"]>
    composites: {}
  }

  type RoutineGetPayload<S extends boolean | null | undefined | RoutineDefaultArgs> = $Result.GetResult<Prisma.$RoutinePayload, S>

  type RoutineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RoutineFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RoutineCountAggregateInputType | true
    }

  export interface RoutineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Routine'], meta: { name: 'Routine' } }
    /**
     * Find zero or one Routine that matches the filter.
     * @param {RoutineFindUniqueArgs} args - Arguments to find a Routine
     * @example
     * // Get one Routine
     * const routine = await prisma.routine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoutineFindUniqueArgs>(args: SelectSubset<T, RoutineFindUniqueArgs<ExtArgs>>): Prisma__RoutineClient<$Result.GetResult<Prisma.$RoutinePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Routine that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RoutineFindUniqueOrThrowArgs} args - Arguments to find a Routine
     * @example
     * // Get one Routine
     * const routine = await prisma.routine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoutineFindUniqueOrThrowArgs>(args: SelectSubset<T, RoutineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoutineClient<$Result.GetResult<Prisma.$RoutinePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Routine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoutineFindFirstArgs} args - Arguments to find a Routine
     * @example
     * // Get one Routine
     * const routine = await prisma.routine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoutineFindFirstArgs>(args?: SelectSubset<T, RoutineFindFirstArgs<ExtArgs>>): Prisma__RoutineClient<$Result.GetResult<Prisma.$RoutinePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Routine that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoutineFindFirstOrThrowArgs} args - Arguments to find a Routine
     * @example
     * // Get one Routine
     * const routine = await prisma.routine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoutineFindFirstOrThrowArgs>(args?: SelectSubset<T, RoutineFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoutineClient<$Result.GetResult<Prisma.$RoutinePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Routines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoutineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Routines
     * const routines = await prisma.routine.findMany()
     * 
     * // Get first 10 Routines
     * const routines = await prisma.routine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const routineWithIdOnly = await prisma.routine.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoutineFindManyArgs>(args?: SelectSubset<T, RoutineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoutinePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Routine.
     * @param {RoutineCreateArgs} args - Arguments to create a Routine.
     * @example
     * // Create one Routine
     * const Routine = await prisma.routine.create({
     *   data: {
     *     // ... data to create a Routine
     *   }
     * })
     * 
     */
    create<T extends RoutineCreateArgs>(args: SelectSubset<T, RoutineCreateArgs<ExtArgs>>): Prisma__RoutineClient<$Result.GetResult<Prisma.$RoutinePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Routines.
     * @param {RoutineCreateManyArgs} args - Arguments to create many Routines.
     * @example
     * // Create many Routines
     * const routine = await prisma.routine.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoutineCreateManyArgs>(args?: SelectSubset<T, RoutineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Routines and returns the data saved in the database.
     * @param {RoutineCreateManyAndReturnArgs} args - Arguments to create many Routines.
     * @example
     * // Create many Routines
     * const routine = await prisma.routine.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Routines and only return the `id`
     * const routineWithIdOnly = await prisma.routine.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoutineCreateManyAndReturnArgs>(args?: SelectSubset<T, RoutineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoutinePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Routine.
     * @param {RoutineDeleteArgs} args - Arguments to delete one Routine.
     * @example
     * // Delete one Routine
     * const Routine = await prisma.routine.delete({
     *   where: {
     *     // ... filter to delete one Routine
     *   }
     * })
     * 
     */
    delete<T extends RoutineDeleteArgs>(args: SelectSubset<T, RoutineDeleteArgs<ExtArgs>>): Prisma__RoutineClient<$Result.GetResult<Prisma.$RoutinePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Routine.
     * @param {RoutineUpdateArgs} args - Arguments to update one Routine.
     * @example
     * // Update one Routine
     * const routine = await prisma.routine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoutineUpdateArgs>(args: SelectSubset<T, RoutineUpdateArgs<ExtArgs>>): Prisma__RoutineClient<$Result.GetResult<Prisma.$RoutinePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Routines.
     * @param {RoutineDeleteManyArgs} args - Arguments to filter Routines to delete.
     * @example
     * // Delete a few Routines
     * const { count } = await prisma.routine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoutineDeleteManyArgs>(args?: SelectSubset<T, RoutineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Routines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoutineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Routines
     * const routine = await prisma.routine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoutineUpdateManyArgs>(args: SelectSubset<T, RoutineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Routine.
     * @param {RoutineUpsertArgs} args - Arguments to update or create a Routine.
     * @example
     * // Update or create a Routine
     * const routine = await prisma.routine.upsert({
     *   create: {
     *     // ... data to create a Routine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Routine we want to update
     *   }
     * })
     */
    upsert<T extends RoutineUpsertArgs>(args: SelectSubset<T, RoutineUpsertArgs<ExtArgs>>): Prisma__RoutineClient<$Result.GetResult<Prisma.$RoutinePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Routines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoutineCountArgs} args - Arguments to filter Routines to count.
     * @example
     * // Count the number of Routines
     * const count = await prisma.routine.count({
     *   where: {
     *     // ... the filter for the Routines we want to count
     *   }
     * })
    **/
    count<T extends RoutineCountArgs>(
      args?: Subset<T, RoutineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoutineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Routine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoutineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoutineAggregateArgs>(args: Subset<T, RoutineAggregateArgs>): Prisma.PrismaPromise<GetRoutineAggregateType<T>>

    /**
     * Group by Routine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoutineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoutineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoutineGroupByArgs['orderBy'] }
        : { orderBy?: RoutineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoutineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoutineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Routine model
   */
  readonly fields: RoutineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Routine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoutineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    executions<T extends Routine$executionsArgs<ExtArgs> = {}>(args?: Subset<T, Routine$executionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoutineExecutionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Routine model
   */ 
  interface RoutineFieldRefs {
    readonly id: FieldRef<"Routine", 'String'>
    readonly userId: FieldRef<"Routine", 'Int'>
    readonly title: FieldRef<"Routine", 'String'>
    readonly description: FieldRef<"Routine", 'String'>
    readonly type: FieldRef<"Routine", 'RoutineType'>
    readonly frequency: FieldRef<"Routine", 'String'>
    readonly schedule: FieldRef<"Routine", 'String'>
    readonly config: FieldRef<"Routine", 'Json'>
    readonly isActive: FieldRef<"Routine", 'Boolean'>
    readonly lastRun: FieldRef<"Routine", 'DateTime'>
    readonly nextRun: FieldRef<"Routine", 'DateTime'>
    readonly runCount: FieldRef<"Routine", 'Int'>
    readonly createdAt: FieldRef<"Routine", 'DateTime'>
    readonly updatedAt: FieldRef<"Routine", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Routine findUnique
   */
  export type RoutineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Routine
     */
    select?: RoutineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutineInclude<ExtArgs> | null
    /**
     * Filter, which Routine to fetch.
     */
    where: RoutineWhereUniqueInput
  }

  /**
   * Routine findUniqueOrThrow
   */
  export type RoutineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Routine
     */
    select?: RoutineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutineInclude<ExtArgs> | null
    /**
     * Filter, which Routine to fetch.
     */
    where: RoutineWhereUniqueInput
  }

  /**
   * Routine findFirst
   */
  export type RoutineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Routine
     */
    select?: RoutineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutineInclude<ExtArgs> | null
    /**
     * Filter, which Routine to fetch.
     */
    where?: RoutineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Routines to fetch.
     */
    orderBy?: RoutineOrderByWithRelationInput | RoutineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Routines.
     */
    cursor?: RoutineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Routines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Routines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Routines.
     */
    distinct?: RoutineScalarFieldEnum | RoutineScalarFieldEnum[]
  }

  /**
   * Routine findFirstOrThrow
   */
  export type RoutineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Routine
     */
    select?: RoutineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutineInclude<ExtArgs> | null
    /**
     * Filter, which Routine to fetch.
     */
    where?: RoutineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Routines to fetch.
     */
    orderBy?: RoutineOrderByWithRelationInput | RoutineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Routines.
     */
    cursor?: RoutineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Routines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Routines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Routines.
     */
    distinct?: RoutineScalarFieldEnum | RoutineScalarFieldEnum[]
  }

  /**
   * Routine findMany
   */
  export type RoutineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Routine
     */
    select?: RoutineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutineInclude<ExtArgs> | null
    /**
     * Filter, which Routines to fetch.
     */
    where?: RoutineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Routines to fetch.
     */
    orderBy?: RoutineOrderByWithRelationInput | RoutineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Routines.
     */
    cursor?: RoutineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Routines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Routines.
     */
    skip?: number
    distinct?: RoutineScalarFieldEnum | RoutineScalarFieldEnum[]
  }

  /**
   * Routine create
   */
  export type RoutineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Routine
     */
    select?: RoutineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutineInclude<ExtArgs> | null
    /**
     * The data needed to create a Routine.
     */
    data: XOR<RoutineCreateInput, RoutineUncheckedCreateInput>
  }

  /**
   * Routine createMany
   */
  export type RoutineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Routines.
     */
    data: RoutineCreateManyInput | RoutineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Routine createManyAndReturn
   */
  export type RoutineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Routine
     */
    select?: RoutineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Routines.
     */
    data: RoutineCreateManyInput | RoutineCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutineIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Routine update
   */
  export type RoutineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Routine
     */
    select?: RoutineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutineInclude<ExtArgs> | null
    /**
     * The data needed to update a Routine.
     */
    data: XOR<RoutineUpdateInput, RoutineUncheckedUpdateInput>
    /**
     * Choose, which Routine to update.
     */
    where: RoutineWhereUniqueInput
  }

  /**
   * Routine updateMany
   */
  export type RoutineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Routines.
     */
    data: XOR<RoutineUpdateManyMutationInput, RoutineUncheckedUpdateManyInput>
    /**
     * Filter which Routines to update
     */
    where?: RoutineWhereInput
  }

  /**
   * Routine upsert
   */
  export type RoutineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Routine
     */
    select?: RoutineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutineInclude<ExtArgs> | null
    /**
     * The filter to search for the Routine to update in case it exists.
     */
    where: RoutineWhereUniqueInput
    /**
     * In case the Routine found by the `where` argument doesn't exist, create a new Routine with this data.
     */
    create: XOR<RoutineCreateInput, RoutineUncheckedCreateInput>
    /**
     * In case the Routine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoutineUpdateInput, RoutineUncheckedUpdateInput>
  }

  /**
   * Routine delete
   */
  export type RoutineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Routine
     */
    select?: RoutineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutineInclude<ExtArgs> | null
    /**
     * Filter which Routine to delete.
     */
    where: RoutineWhereUniqueInput
  }

  /**
   * Routine deleteMany
   */
  export type RoutineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Routines to delete
     */
    where?: RoutineWhereInput
  }

  /**
   * Routine.executions
   */
  export type Routine$executionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoutineExecution
     */
    select?: RoutineExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutineExecutionInclude<ExtArgs> | null
    where?: RoutineExecutionWhereInput
    orderBy?: RoutineExecutionOrderByWithRelationInput | RoutineExecutionOrderByWithRelationInput[]
    cursor?: RoutineExecutionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoutineExecutionScalarFieldEnum | RoutineExecutionScalarFieldEnum[]
  }

  /**
   * Routine without action
   */
  export type RoutineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Routine
     */
    select?: RoutineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutineInclude<ExtArgs> | null
  }


  /**
   * Model RoutineExecution
   */

  export type AggregateRoutineExecution = {
    _count: RoutineExecutionCountAggregateOutputType | null
    _avg: RoutineExecutionAvgAggregateOutputType | null
    _sum: RoutineExecutionSumAggregateOutputType | null
    _min: RoutineExecutionMinAggregateOutputType | null
    _max: RoutineExecutionMaxAggregateOutputType | null
  }

  export type RoutineExecutionAvgAggregateOutputType = {
    duration: number | null
  }

  export type RoutineExecutionSumAggregateOutputType = {
    duration: number | null
  }

  export type RoutineExecutionMinAggregateOutputType = {
    id: string | null
    routineId: string | null
    status: string | null
    summary: string | null
    duration: number | null
    error: string | null
    createdAt: Date | null
  }

  export type RoutineExecutionMaxAggregateOutputType = {
    id: string | null
    routineId: string | null
    status: string | null
    summary: string | null
    duration: number | null
    error: string | null
    createdAt: Date | null
  }

  export type RoutineExecutionCountAggregateOutputType = {
    id: number
    routineId: number
    status: number
    summary: number
    results: number
    duration: number
    error: number
    createdAt: number
    _all: number
  }


  export type RoutineExecutionAvgAggregateInputType = {
    duration?: true
  }

  export type RoutineExecutionSumAggregateInputType = {
    duration?: true
  }

  export type RoutineExecutionMinAggregateInputType = {
    id?: true
    routineId?: true
    status?: true
    summary?: true
    duration?: true
    error?: true
    createdAt?: true
  }

  export type RoutineExecutionMaxAggregateInputType = {
    id?: true
    routineId?: true
    status?: true
    summary?: true
    duration?: true
    error?: true
    createdAt?: true
  }

  export type RoutineExecutionCountAggregateInputType = {
    id?: true
    routineId?: true
    status?: true
    summary?: true
    results?: true
    duration?: true
    error?: true
    createdAt?: true
    _all?: true
  }

  export type RoutineExecutionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoutineExecution to aggregate.
     */
    where?: RoutineExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoutineExecutions to fetch.
     */
    orderBy?: RoutineExecutionOrderByWithRelationInput | RoutineExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoutineExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoutineExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoutineExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RoutineExecutions
    **/
    _count?: true | RoutineExecutionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoutineExecutionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoutineExecutionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoutineExecutionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoutineExecutionMaxAggregateInputType
  }

  export type GetRoutineExecutionAggregateType<T extends RoutineExecutionAggregateArgs> = {
        [P in keyof T & keyof AggregateRoutineExecution]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoutineExecution[P]>
      : GetScalarType<T[P], AggregateRoutineExecution[P]>
  }




  export type RoutineExecutionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoutineExecutionWhereInput
    orderBy?: RoutineExecutionOrderByWithAggregationInput | RoutineExecutionOrderByWithAggregationInput[]
    by: RoutineExecutionScalarFieldEnum[] | RoutineExecutionScalarFieldEnum
    having?: RoutineExecutionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoutineExecutionCountAggregateInputType | true
    _avg?: RoutineExecutionAvgAggregateInputType
    _sum?: RoutineExecutionSumAggregateInputType
    _min?: RoutineExecutionMinAggregateInputType
    _max?: RoutineExecutionMaxAggregateInputType
  }

  export type RoutineExecutionGroupByOutputType = {
    id: string
    routineId: string
    status: string
    summary: string | null
    results: JsonValue | null
    duration: number | null
    error: string | null
    createdAt: Date
    _count: RoutineExecutionCountAggregateOutputType | null
    _avg: RoutineExecutionAvgAggregateOutputType | null
    _sum: RoutineExecutionSumAggregateOutputType | null
    _min: RoutineExecutionMinAggregateOutputType | null
    _max: RoutineExecutionMaxAggregateOutputType | null
  }

  type GetRoutineExecutionGroupByPayload<T extends RoutineExecutionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoutineExecutionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoutineExecutionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoutineExecutionGroupByOutputType[P]>
            : GetScalarType<T[P], RoutineExecutionGroupByOutputType[P]>
        }
      >
    >


  export type RoutineExecutionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    routineId?: boolean
    status?: boolean
    summary?: boolean
    results?: boolean
    duration?: boolean
    error?: boolean
    createdAt?: boolean
    routine?: boolean | RoutineDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["routineExecution"]>

  export type RoutineExecutionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    routineId?: boolean
    status?: boolean
    summary?: boolean
    results?: boolean
    duration?: boolean
    error?: boolean
    createdAt?: boolean
    routine?: boolean | RoutineDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["routineExecution"]>

  export type RoutineExecutionSelectScalar = {
    id?: boolean
    routineId?: boolean
    status?: boolean
    summary?: boolean
    results?: boolean
    duration?: boolean
    error?: boolean
    createdAt?: boolean
  }

  export type RoutineExecutionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    routine?: boolean | RoutineDefaultArgs<ExtArgs>
  }
  export type RoutineExecutionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    routine?: boolean | RoutineDefaultArgs<ExtArgs>
  }

  export type $RoutineExecutionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RoutineExecution"
    objects: {
      routine: Prisma.$RoutinePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      routineId: string
      status: string
      summary: string | null
      results: Prisma.JsonValue | null
      duration: number | null
      error: string | null
      createdAt: Date
    }, ExtArgs["result"]["routineExecution"]>
    composites: {}
  }

  type RoutineExecutionGetPayload<S extends boolean | null | undefined | RoutineExecutionDefaultArgs> = $Result.GetResult<Prisma.$RoutineExecutionPayload, S>

  type RoutineExecutionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RoutineExecutionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RoutineExecutionCountAggregateInputType | true
    }

  export interface RoutineExecutionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RoutineExecution'], meta: { name: 'RoutineExecution' } }
    /**
     * Find zero or one RoutineExecution that matches the filter.
     * @param {RoutineExecutionFindUniqueArgs} args - Arguments to find a RoutineExecution
     * @example
     * // Get one RoutineExecution
     * const routineExecution = await prisma.routineExecution.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoutineExecutionFindUniqueArgs>(args: SelectSubset<T, RoutineExecutionFindUniqueArgs<ExtArgs>>): Prisma__RoutineExecutionClient<$Result.GetResult<Prisma.$RoutineExecutionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RoutineExecution that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RoutineExecutionFindUniqueOrThrowArgs} args - Arguments to find a RoutineExecution
     * @example
     * // Get one RoutineExecution
     * const routineExecution = await prisma.routineExecution.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoutineExecutionFindUniqueOrThrowArgs>(args: SelectSubset<T, RoutineExecutionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoutineExecutionClient<$Result.GetResult<Prisma.$RoutineExecutionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RoutineExecution that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoutineExecutionFindFirstArgs} args - Arguments to find a RoutineExecution
     * @example
     * // Get one RoutineExecution
     * const routineExecution = await prisma.routineExecution.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoutineExecutionFindFirstArgs>(args?: SelectSubset<T, RoutineExecutionFindFirstArgs<ExtArgs>>): Prisma__RoutineExecutionClient<$Result.GetResult<Prisma.$RoutineExecutionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RoutineExecution that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoutineExecutionFindFirstOrThrowArgs} args - Arguments to find a RoutineExecution
     * @example
     * // Get one RoutineExecution
     * const routineExecution = await prisma.routineExecution.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoutineExecutionFindFirstOrThrowArgs>(args?: SelectSubset<T, RoutineExecutionFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoutineExecutionClient<$Result.GetResult<Prisma.$RoutineExecutionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RoutineExecutions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoutineExecutionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RoutineExecutions
     * const routineExecutions = await prisma.routineExecution.findMany()
     * 
     * // Get first 10 RoutineExecutions
     * const routineExecutions = await prisma.routineExecution.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const routineExecutionWithIdOnly = await prisma.routineExecution.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoutineExecutionFindManyArgs>(args?: SelectSubset<T, RoutineExecutionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoutineExecutionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RoutineExecution.
     * @param {RoutineExecutionCreateArgs} args - Arguments to create a RoutineExecution.
     * @example
     * // Create one RoutineExecution
     * const RoutineExecution = await prisma.routineExecution.create({
     *   data: {
     *     // ... data to create a RoutineExecution
     *   }
     * })
     * 
     */
    create<T extends RoutineExecutionCreateArgs>(args: SelectSubset<T, RoutineExecutionCreateArgs<ExtArgs>>): Prisma__RoutineExecutionClient<$Result.GetResult<Prisma.$RoutineExecutionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RoutineExecutions.
     * @param {RoutineExecutionCreateManyArgs} args - Arguments to create many RoutineExecutions.
     * @example
     * // Create many RoutineExecutions
     * const routineExecution = await prisma.routineExecution.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoutineExecutionCreateManyArgs>(args?: SelectSubset<T, RoutineExecutionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RoutineExecutions and returns the data saved in the database.
     * @param {RoutineExecutionCreateManyAndReturnArgs} args - Arguments to create many RoutineExecutions.
     * @example
     * // Create many RoutineExecutions
     * const routineExecution = await prisma.routineExecution.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RoutineExecutions and only return the `id`
     * const routineExecutionWithIdOnly = await prisma.routineExecution.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoutineExecutionCreateManyAndReturnArgs>(args?: SelectSubset<T, RoutineExecutionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoutineExecutionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RoutineExecution.
     * @param {RoutineExecutionDeleteArgs} args - Arguments to delete one RoutineExecution.
     * @example
     * // Delete one RoutineExecution
     * const RoutineExecution = await prisma.routineExecution.delete({
     *   where: {
     *     // ... filter to delete one RoutineExecution
     *   }
     * })
     * 
     */
    delete<T extends RoutineExecutionDeleteArgs>(args: SelectSubset<T, RoutineExecutionDeleteArgs<ExtArgs>>): Prisma__RoutineExecutionClient<$Result.GetResult<Prisma.$RoutineExecutionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RoutineExecution.
     * @param {RoutineExecutionUpdateArgs} args - Arguments to update one RoutineExecution.
     * @example
     * // Update one RoutineExecution
     * const routineExecution = await prisma.routineExecution.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoutineExecutionUpdateArgs>(args: SelectSubset<T, RoutineExecutionUpdateArgs<ExtArgs>>): Prisma__RoutineExecutionClient<$Result.GetResult<Prisma.$RoutineExecutionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RoutineExecutions.
     * @param {RoutineExecutionDeleteManyArgs} args - Arguments to filter RoutineExecutions to delete.
     * @example
     * // Delete a few RoutineExecutions
     * const { count } = await prisma.routineExecution.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoutineExecutionDeleteManyArgs>(args?: SelectSubset<T, RoutineExecutionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoutineExecutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoutineExecutionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RoutineExecutions
     * const routineExecution = await prisma.routineExecution.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoutineExecutionUpdateManyArgs>(args: SelectSubset<T, RoutineExecutionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RoutineExecution.
     * @param {RoutineExecutionUpsertArgs} args - Arguments to update or create a RoutineExecution.
     * @example
     * // Update or create a RoutineExecution
     * const routineExecution = await prisma.routineExecution.upsert({
     *   create: {
     *     // ... data to create a RoutineExecution
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RoutineExecution we want to update
     *   }
     * })
     */
    upsert<T extends RoutineExecutionUpsertArgs>(args: SelectSubset<T, RoutineExecutionUpsertArgs<ExtArgs>>): Prisma__RoutineExecutionClient<$Result.GetResult<Prisma.$RoutineExecutionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RoutineExecutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoutineExecutionCountArgs} args - Arguments to filter RoutineExecutions to count.
     * @example
     * // Count the number of RoutineExecutions
     * const count = await prisma.routineExecution.count({
     *   where: {
     *     // ... the filter for the RoutineExecutions we want to count
     *   }
     * })
    **/
    count<T extends RoutineExecutionCountArgs>(
      args?: Subset<T, RoutineExecutionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoutineExecutionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RoutineExecution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoutineExecutionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoutineExecutionAggregateArgs>(args: Subset<T, RoutineExecutionAggregateArgs>): Prisma.PrismaPromise<GetRoutineExecutionAggregateType<T>>

    /**
     * Group by RoutineExecution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoutineExecutionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoutineExecutionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoutineExecutionGroupByArgs['orderBy'] }
        : { orderBy?: RoutineExecutionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoutineExecutionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoutineExecutionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RoutineExecution model
   */
  readonly fields: RoutineExecutionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RoutineExecution.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoutineExecutionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    routine<T extends RoutineDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoutineDefaultArgs<ExtArgs>>): Prisma__RoutineClient<$Result.GetResult<Prisma.$RoutinePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RoutineExecution model
   */ 
  interface RoutineExecutionFieldRefs {
    readonly id: FieldRef<"RoutineExecution", 'String'>
    readonly routineId: FieldRef<"RoutineExecution", 'String'>
    readonly status: FieldRef<"RoutineExecution", 'String'>
    readonly summary: FieldRef<"RoutineExecution", 'String'>
    readonly results: FieldRef<"RoutineExecution", 'Json'>
    readonly duration: FieldRef<"RoutineExecution", 'Int'>
    readonly error: FieldRef<"RoutineExecution", 'String'>
    readonly createdAt: FieldRef<"RoutineExecution", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RoutineExecution findUnique
   */
  export type RoutineExecutionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoutineExecution
     */
    select?: RoutineExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutineExecutionInclude<ExtArgs> | null
    /**
     * Filter, which RoutineExecution to fetch.
     */
    where: RoutineExecutionWhereUniqueInput
  }

  /**
   * RoutineExecution findUniqueOrThrow
   */
  export type RoutineExecutionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoutineExecution
     */
    select?: RoutineExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutineExecutionInclude<ExtArgs> | null
    /**
     * Filter, which RoutineExecution to fetch.
     */
    where: RoutineExecutionWhereUniqueInput
  }

  /**
   * RoutineExecution findFirst
   */
  export type RoutineExecutionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoutineExecution
     */
    select?: RoutineExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutineExecutionInclude<ExtArgs> | null
    /**
     * Filter, which RoutineExecution to fetch.
     */
    where?: RoutineExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoutineExecutions to fetch.
     */
    orderBy?: RoutineExecutionOrderByWithRelationInput | RoutineExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoutineExecutions.
     */
    cursor?: RoutineExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoutineExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoutineExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoutineExecutions.
     */
    distinct?: RoutineExecutionScalarFieldEnum | RoutineExecutionScalarFieldEnum[]
  }

  /**
   * RoutineExecution findFirstOrThrow
   */
  export type RoutineExecutionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoutineExecution
     */
    select?: RoutineExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutineExecutionInclude<ExtArgs> | null
    /**
     * Filter, which RoutineExecution to fetch.
     */
    where?: RoutineExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoutineExecutions to fetch.
     */
    orderBy?: RoutineExecutionOrderByWithRelationInput | RoutineExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoutineExecutions.
     */
    cursor?: RoutineExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoutineExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoutineExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoutineExecutions.
     */
    distinct?: RoutineExecutionScalarFieldEnum | RoutineExecutionScalarFieldEnum[]
  }

  /**
   * RoutineExecution findMany
   */
  export type RoutineExecutionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoutineExecution
     */
    select?: RoutineExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutineExecutionInclude<ExtArgs> | null
    /**
     * Filter, which RoutineExecutions to fetch.
     */
    where?: RoutineExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoutineExecutions to fetch.
     */
    orderBy?: RoutineExecutionOrderByWithRelationInput | RoutineExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RoutineExecutions.
     */
    cursor?: RoutineExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoutineExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoutineExecutions.
     */
    skip?: number
    distinct?: RoutineExecutionScalarFieldEnum | RoutineExecutionScalarFieldEnum[]
  }

  /**
   * RoutineExecution create
   */
  export type RoutineExecutionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoutineExecution
     */
    select?: RoutineExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutineExecutionInclude<ExtArgs> | null
    /**
     * The data needed to create a RoutineExecution.
     */
    data: XOR<RoutineExecutionCreateInput, RoutineExecutionUncheckedCreateInput>
  }

  /**
   * RoutineExecution createMany
   */
  export type RoutineExecutionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RoutineExecutions.
     */
    data: RoutineExecutionCreateManyInput | RoutineExecutionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RoutineExecution createManyAndReturn
   */
  export type RoutineExecutionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoutineExecution
     */
    select?: RoutineExecutionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RoutineExecutions.
     */
    data: RoutineExecutionCreateManyInput | RoutineExecutionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutineExecutionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RoutineExecution update
   */
  export type RoutineExecutionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoutineExecution
     */
    select?: RoutineExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutineExecutionInclude<ExtArgs> | null
    /**
     * The data needed to update a RoutineExecution.
     */
    data: XOR<RoutineExecutionUpdateInput, RoutineExecutionUncheckedUpdateInput>
    /**
     * Choose, which RoutineExecution to update.
     */
    where: RoutineExecutionWhereUniqueInput
  }

  /**
   * RoutineExecution updateMany
   */
  export type RoutineExecutionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RoutineExecutions.
     */
    data: XOR<RoutineExecutionUpdateManyMutationInput, RoutineExecutionUncheckedUpdateManyInput>
    /**
     * Filter which RoutineExecutions to update
     */
    where?: RoutineExecutionWhereInput
  }

  /**
   * RoutineExecution upsert
   */
  export type RoutineExecutionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoutineExecution
     */
    select?: RoutineExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutineExecutionInclude<ExtArgs> | null
    /**
     * The filter to search for the RoutineExecution to update in case it exists.
     */
    where: RoutineExecutionWhereUniqueInput
    /**
     * In case the RoutineExecution found by the `where` argument doesn't exist, create a new RoutineExecution with this data.
     */
    create: XOR<RoutineExecutionCreateInput, RoutineExecutionUncheckedCreateInput>
    /**
     * In case the RoutineExecution was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoutineExecutionUpdateInput, RoutineExecutionUncheckedUpdateInput>
  }

  /**
   * RoutineExecution delete
   */
  export type RoutineExecutionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoutineExecution
     */
    select?: RoutineExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutineExecutionInclude<ExtArgs> | null
    /**
     * Filter which RoutineExecution to delete.
     */
    where: RoutineExecutionWhereUniqueInput
  }

  /**
   * RoutineExecution deleteMany
   */
  export type RoutineExecutionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoutineExecutions to delete
     */
    where?: RoutineExecutionWhereInput
  }

  /**
   * RoutineExecution without action
   */
  export type RoutineExecutionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoutineExecution
     */
    select?: RoutineExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutineExecutionInclude<ExtArgs> | null
  }


  /**
   * Model Worker
   */

  export type AggregateWorker = {
    _count: WorkerCountAggregateOutputType | null
    _avg: WorkerAvgAggregateOutputType | null
    _sum: WorkerSumAggregateOutputType | null
    _min: WorkerMinAggregateOutputType | null
    _max: WorkerMaxAggregateOutputType | null
  }

  export type WorkerAvgAggregateOutputType = {
    id: number | null
    totalCompleted: number | null
    totalFailed: number | null
    totalSkipped: number | null
    avgTimeSeconds: number | null
  }

  export type WorkerSumAggregateOutputType = {
    id: number | null
    totalCompleted: number | null
    totalFailed: number | null
    totalSkipped: number | null
    avgTimeSeconds: number | null
  }

  export type WorkerMinAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    name: string | null
    isActive: boolean | null
    role: $Enums.WorkerRole | null
    totalCompleted: number | null
    totalFailed: number | null
    totalSkipped: number | null
    avgTimeSeconds: number | null
    lastActiveAt: Date | null
    currentSessionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkerMaxAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    name: string | null
    isActive: boolean | null
    role: $Enums.WorkerRole | null
    totalCompleted: number | null
    totalFailed: number | null
    totalSkipped: number | null
    avgTimeSeconds: number | null
    lastActiveAt: Date | null
    currentSessionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkerCountAggregateOutputType = {
    id: number
    email: number
    password: number
    name: number
    isActive: number
    role: number
    totalCompleted: number
    totalFailed: number
    totalSkipped: number
    avgTimeSeconds: number
    lastActiveAt: number
    currentSessionId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WorkerAvgAggregateInputType = {
    id?: true
    totalCompleted?: true
    totalFailed?: true
    totalSkipped?: true
    avgTimeSeconds?: true
  }

  export type WorkerSumAggregateInputType = {
    id?: true
    totalCompleted?: true
    totalFailed?: true
    totalSkipped?: true
    avgTimeSeconds?: true
  }

  export type WorkerMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    isActive?: true
    role?: true
    totalCompleted?: true
    totalFailed?: true
    totalSkipped?: true
    avgTimeSeconds?: true
    lastActiveAt?: true
    currentSessionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkerMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    isActive?: true
    role?: true
    totalCompleted?: true
    totalFailed?: true
    totalSkipped?: true
    avgTimeSeconds?: true
    lastActiveAt?: true
    currentSessionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkerCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    isActive?: true
    role?: true
    totalCompleted?: true
    totalFailed?: true
    totalSkipped?: true
    avgTimeSeconds?: true
    lastActiveAt?: true
    currentSessionId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WorkerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Worker to aggregate.
     */
    where?: WorkerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workers to fetch.
     */
    orderBy?: WorkerOrderByWithRelationInput | WorkerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Workers
    **/
    _count?: true | WorkerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkerMaxAggregateInputType
  }

  export type GetWorkerAggregateType<T extends WorkerAggregateArgs> = {
        [P in keyof T & keyof AggregateWorker]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorker[P]>
      : GetScalarType<T[P], AggregateWorker[P]>
  }




  export type WorkerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkerWhereInput
    orderBy?: WorkerOrderByWithAggregationInput | WorkerOrderByWithAggregationInput[]
    by: WorkerScalarFieldEnum[] | WorkerScalarFieldEnum
    having?: WorkerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkerCountAggregateInputType | true
    _avg?: WorkerAvgAggregateInputType
    _sum?: WorkerSumAggregateInputType
    _min?: WorkerMinAggregateInputType
    _max?: WorkerMaxAggregateInputType
  }

  export type WorkerGroupByOutputType = {
    id: number
    email: string
    password: string
    name: string
    isActive: boolean
    role: $Enums.WorkerRole
    totalCompleted: number
    totalFailed: number
    totalSkipped: number
    avgTimeSeconds: number | null
    lastActiveAt: Date | null
    currentSessionId: string | null
    createdAt: Date
    updatedAt: Date
    _count: WorkerCountAggregateOutputType | null
    _avg: WorkerAvgAggregateOutputType | null
    _sum: WorkerSumAggregateOutputType | null
    _min: WorkerMinAggregateOutputType | null
    _max: WorkerMaxAggregateOutputType | null
  }

  type GetWorkerGroupByPayload<T extends WorkerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkerGroupByOutputType[P]>
            : GetScalarType<T[P], WorkerGroupByOutputType[P]>
        }
      >
    >


  export type WorkerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    isActive?: boolean
    role?: boolean
    totalCompleted?: boolean
    totalFailed?: boolean
    totalSkipped?: boolean
    avgTimeSeconds?: boolean
    lastActiveAt?: boolean
    currentSessionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sessions?: boolean | Worker$sessionsArgs<ExtArgs>
    _count?: boolean | WorkerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["worker"]>

  export type WorkerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    isActive?: boolean
    role?: boolean
    totalCompleted?: boolean
    totalFailed?: boolean
    totalSkipped?: boolean
    avgTimeSeconds?: boolean
    lastActiveAt?: boolean
    currentSessionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["worker"]>

  export type WorkerSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    isActive?: boolean
    role?: boolean
    totalCompleted?: boolean
    totalFailed?: boolean
    totalSkipped?: boolean
    avgTimeSeconds?: boolean
    lastActiveAt?: boolean
    currentSessionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WorkerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | Worker$sessionsArgs<ExtArgs>
    _count?: boolean | WorkerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WorkerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $WorkerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Worker"
    objects: {
      sessions: Prisma.$WorkerSessionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      password: string
      name: string
      isActive: boolean
      role: $Enums.WorkerRole
      totalCompleted: number
      totalFailed: number
      totalSkipped: number
      avgTimeSeconds: number | null
      lastActiveAt: Date | null
      currentSessionId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["worker"]>
    composites: {}
  }

  type WorkerGetPayload<S extends boolean | null | undefined | WorkerDefaultArgs> = $Result.GetResult<Prisma.$WorkerPayload, S>

  type WorkerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WorkerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WorkerCountAggregateInputType | true
    }

  export interface WorkerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Worker'], meta: { name: 'Worker' } }
    /**
     * Find zero or one Worker that matches the filter.
     * @param {WorkerFindUniqueArgs} args - Arguments to find a Worker
     * @example
     * // Get one Worker
     * const worker = await prisma.worker.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkerFindUniqueArgs>(args: SelectSubset<T, WorkerFindUniqueArgs<ExtArgs>>): Prisma__WorkerClient<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Worker that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WorkerFindUniqueOrThrowArgs} args - Arguments to find a Worker
     * @example
     * // Get one Worker
     * const worker = await prisma.worker.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkerFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkerClient<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Worker that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerFindFirstArgs} args - Arguments to find a Worker
     * @example
     * // Get one Worker
     * const worker = await prisma.worker.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkerFindFirstArgs>(args?: SelectSubset<T, WorkerFindFirstArgs<ExtArgs>>): Prisma__WorkerClient<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Worker that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerFindFirstOrThrowArgs} args - Arguments to find a Worker
     * @example
     * // Get one Worker
     * const worker = await prisma.worker.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkerFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkerFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkerClient<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Workers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Workers
     * const workers = await prisma.worker.findMany()
     * 
     * // Get first 10 Workers
     * const workers = await prisma.worker.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workerWithIdOnly = await prisma.worker.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkerFindManyArgs>(args?: SelectSubset<T, WorkerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Worker.
     * @param {WorkerCreateArgs} args - Arguments to create a Worker.
     * @example
     * // Create one Worker
     * const Worker = await prisma.worker.create({
     *   data: {
     *     // ... data to create a Worker
     *   }
     * })
     * 
     */
    create<T extends WorkerCreateArgs>(args: SelectSubset<T, WorkerCreateArgs<ExtArgs>>): Prisma__WorkerClient<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Workers.
     * @param {WorkerCreateManyArgs} args - Arguments to create many Workers.
     * @example
     * // Create many Workers
     * const worker = await prisma.worker.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkerCreateManyArgs>(args?: SelectSubset<T, WorkerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Workers and returns the data saved in the database.
     * @param {WorkerCreateManyAndReturnArgs} args - Arguments to create many Workers.
     * @example
     * // Create many Workers
     * const worker = await prisma.worker.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Workers and only return the `id`
     * const workerWithIdOnly = await prisma.worker.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkerCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Worker.
     * @param {WorkerDeleteArgs} args - Arguments to delete one Worker.
     * @example
     * // Delete one Worker
     * const Worker = await prisma.worker.delete({
     *   where: {
     *     // ... filter to delete one Worker
     *   }
     * })
     * 
     */
    delete<T extends WorkerDeleteArgs>(args: SelectSubset<T, WorkerDeleteArgs<ExtArgs>>): Prisma__WorkerClient<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Worker.
     * @param {WorkerUpdateArgs} args - Arguments to update one Worker.
     * @example
     * // Update one Worker
     * const worker = await prisma.worker.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkerUpdateArgs>(args: SelectSubset<T, WorkerUpdateArgs<ExtArgs>>): Prisma__WorkerClient<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Workers.
     * @param {WorkerDeleteManyArgs} args - Arguments to filter Workers to delete.
     * @example
     * // Delete a few Workers
     * const { count } = await prisma.worker.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkerDeleteManyArgs>(args?: SelectSubset<T, WorkerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Workers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Workers
     * const worker = await prisma.worker.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkerUpdateManyArgs>(args: SelectSubset<T, WorkerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Worker.
     * @param {WorkerUpsertArgs} args - Arguments to update or create a Worker.
     * @example
     * // Update or create a Worker
     * const worker = await prisma.worker.upsert({
     *   create: {
     *     // ... data to create a Worker
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Worker we want to update
     *   }
     * })
     */
    upsert<T extends WorkerUpsertArgs>(args: SelectSubset<T, WorkerUpsertArgs<ExtArgs>>): Prisma__WorkerClient<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Workers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerCountArgs} args - Arguments to filter Workers to count.
     * @example
     * // Count the number of Workers
     * const count = await prisma.worker.count({
     *   where: {
     *     // ... the filter for the Workers we want to count
     *   }
     * })
    **/
    count<T extends WorkerCountArgs>(
      args?: Subset<T, WorkerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Worker.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkerAggregateArgs>(args: Subset<T, WorkerAggregateArgs>): Prisma.PrismaPromise<GetWorkerAggregateType<T>>

    /**
     * Group by Worker.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkerGroupByArgs['orderBy'] }
        : { orderBy?: WorkerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Worker model
   */
  readonly fields: WorkerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Worker.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sessions<T extends Worker$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, Worker$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkerSessionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Worker model
   */ 
  interface WorkerFieldRefs {
    readonly id: FieldRef<"Worker", 'Int'>
    readonly email: FieldRef<"Worker", 'String'>
    readonly password: FieldRef<"Worker", 'String'>
    readonly name: FieldRef<"Worker", 'String'>
    readonly isActive: FieldRef<"Worker", 'Boolean'>
    readonly role: FieldRef<"Worker", 'WorkerRole'>
    readonly totalCompleted: FieldRef<"Worker", 'Int'>
    readonly totalFailed: FieldRef<"Worker", 'Int'>
    readonly totalSkipped: FieldRef<"Worker", 'Int'>
    readonly avgTimeSeconds: FieldRef<"Worker", 'Int'>
    readonly lastActiveAt: FieldRef<"Worker", 'DateTime'>
    readonly currentSessionId: FieldRef<"Worker", 'String'>
    readonly createdAt: FieldRef<"Worker", 'DateTime'>
    readonly updatedAt: FieldRef<"Worker", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Worker findUnique
   */
  export type WorkerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
    /**
     * Filter, which Worker to fetch.
     */
    where: WorkerWhereUniqueInput
  }

  /**
   * Worker findUniqueOrThrow
   */
  export type WorkerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
    /**
     * Filter, which Worker to fetch.
     */
    where: WorkerWhereUniqueInput
  }

  /**
   * Worker findFirst
   */
  export type WorkerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
    /**
     * Filter, which Worker to fetch.
     */
    where?: WorkerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workers to fetch.
     */
    orderBy?: WorkerOrderByWithRelationInput | WorkerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Workers.
     */
    cursor?: WorkerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Workers.
     */
    distinct?: WorkerScalarFieldEnum | WorkerScalarFieldEnum[]
  }

  /**
   * Worker findFirstOrThrow
   */
  export type WorkerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
    /**
     * Filter, which Worker to fetch.
     */
    where?: WorkerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workers to fetch.
     */
    orderBy?: WorkerOrderByWithRelationInput | WorkerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Workers.
     */
    cursor?: WorkerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Workers.
     */
    distinct?: WorkerScalarFieldEnum | WorkerScalarFieldEnum[]
  }

  /**
   * Worker findMany
   */
  export type WorkerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
    /**
     * Filter, which Workers to fetch.
     */
    where?: WorkerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workers to fetch.
     */
    orderBy?: WorkerOrderByWithRelationInput | WorkerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Workers.
     */
    cursor?: WorkerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workers.
     */
    skip?: number
    distinct?: WorkerScalarFieldEnum | WorkerScalarFieldEnum[]
  }

  /**
   * Worker create
   */
  export type WorkerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
    /**
     * The data needed to create a Worker.
     */
    data: XOR<WorkerCreateInput, WorkerUncheckedCreateInput>
  }

  /**
   * Worker createMany
   */
  export type WorkerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Workers.
     */
    data: WorkerCreateManyInput | WorkerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Worker createManyAndReturn
   */
  export type WorkerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Workers.
     */
    data: WorkerCreateManyInput | WorkerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Worker update
   */
  export type WorkerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
    /**
     * The data needed to update a Worker.
     */
    data: XOR<WorkerUpdateInput, WorkerUncheckedUpdateInput>
    /**
     * Choose, which Worker to update.
     */
    where: WorkerWhereUniqueInput
  }

  /**
   * Worker updateMany
   */
  export type WorkerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Workers.
     */
    data: XOR<WorkerUpdateManyMutationInput, WorkerUncheckedUpdateManyInput>
    /**
     * Filter which Workers to update
     */
    where?: WorkerWhereInput
  }

  /**
   * Worker upsert
   */
  export type WorkerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
    /**
     * The filter to search for the Worker to update in case it exists.
     */
    where: WorkerWhereUniqueInput
    /**
     * In case the Worker found by the `where` argument doesn't exist, create a new Worker with this data.
     */
    create: XOR<WorkerCreateInput, WorkerUncheckedCreateInput>
    /**
     * In case the Worker was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkerUpdateInput, WorkerUncheckedUpdateInput>
  }

  /**
   * Worker delete
   */
  export type WorkerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
    /**
     * Filter which Worker to delete.
     */
    where: WorkerWhereUniqueInput
  }

  /**
   * Worker deleteMany
   */
  export type WorkerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Workers to delete
     */
    where?: WorkerWhereInput
  }

  /**
   * Worker.sessions
   */
  export type Worker$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerSession
     */
    select?: WorkerSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerSessionInclude<ExtArgs> | null
    where?: WorkerSessionWhereInput
    orderBy?: WorkerSessionOrderByWithRelationInput | WorkerSessionOrderByWithRelationInput[]
    cursor?: WorkerSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkerSessionScalarFieldEnum | WorkerSessionScalarFieldEnum[]
  }

  /**
   * Worker without action
   */
  export type WorkerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
  }


  /**
   * Model WorkerSession
   */

  export type AggregateWorkerSession = {
    _count: WorkerSessionCountAggregateOutputType | null
    _avg: WorkerSessionAvgAggregateOutputType | null
    _sum: WorkerSessionSumAggregateOutputType | null
    _min: WorkerSessionMinAggregateOutputType | null
    _max: WorkerSessionMaxAggregateOutputType | null
  }

  export type WorkerSessionAvgAggregateOutputType = {
    workerId: number | null
  }

  export type WorkerSessionSumAggregateOutputType = {
    workerId: number | null
  }

  export type WorkerSessionMinAggregateOutputType = {
    id: string | null
    workerId: number | null
    autoApplicationId: string | null
    status: $Enums.WorkerSessionStatus | null
    browserSessionId: string | null
    vncUrl: string | null
    queuedAt: Date | null
    assignedAt: Date | null
    aiStartedAt: Date | null
    aiCompletedAt: Date | null
    submittedAt: Date | null
    completedAt: Date | null
    screenshotUrl: string | null
    workerNotes: string | null
    failReason: string | null
    skipReason: string | null
  }

  export type WorkerSessionMaxAggregateOutputType = {
    id: string | null
    workerId: number | null
    autoApplicationId: string | null
    status: $Enums.WorkerSessionStatus | null
    browserSessionId: string | null
    vncUrl: string | null
    queuedAt: Date | null
    assignedAt: Date | null
    aiStartedAt: Date | null
    aiCompletedAt: Date | null
    submittedAt: Date | null
    completedAt: Date | null
    screenshotUrl: string | null
    workerNotes: string | null
    failReason: string | null
    skipReason: string | null
  }

  export type WorkerSessionCountAggregateOutputType = {
    id: number
    workerId: number
    autoApplicationId: number
    status: number
    browserSessionId: number
    vncUrl: number
    queuedAt: number
    assignedAt: number
    aiStartedAt: number
    aiCompletedAt: number
    submittedAt: number
    completedAt: number
    formData: number
    screenshotUrl: number
    workerNotes: number
    failReason: number
    skipReason: number
    _all: number
  }


  export type WorkerSessionAvgAggregateInputType = {
    workerId?: true
  }

  export type WorkerSessionSumAggregateInputType = {
    workerId?: true
  }

  export type WorkerSessionMinAggregateInputType = {
    id?: true
    workerId?: true
    autoApplicationId?: true
    status?: true
    browserSessionId?: true
    vncUrl?: true
    queuedAt?: true
    assignedAt?: true
    aiStartedAt?: true
    aiCompletedAt?: true
    submittedAt?: true
    completedAt?: true
    screenshotUrl?: true
    workerNotes?: true
    failReason?: true
    skipReason?: true
  }

  export type WorkerSessionMaxAggregateInputType = {
    id?: true
    workerId?: true
    autoApplicationId?: true
    status?: true
    browserSessionId?: true
    vncUrl?: true
    queuedAt?: true
    assignedAt?: true
    aiStartedAt?: true
    aiCompletedAt?: true
    submittedAt?: true
    completedAt?: true
    screenshotUrl?: true
    workerNotes?: true
    failReason?: true
    skipReason?: true
  }

  export type WorkerSessionCountAggregateInputType = {
    id?: true
    workerId?: true
    autoApplicationId?: true
    status?: true
    browserSessionId?: true
    vncUrl?: true
    queuedAt?: true
    assignedAt?: true
    aiStartedAt?: true
    aiCompletedAt?: true
    submittedAt?: true
    completedAt?: true
    formData?: true
    screenshotUrl?: true
    workerNotes?: true
    failReason?: true
    skipReason?: true
    _all?: true
  }

  export type WorkerSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkerSession to aggregate.
     */
    where?: WorkerSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkerSessions to fetch.
     */
    orderBy?: WorkerSessionOrderByWithRelationInput | WorkerSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkerSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkerSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkerSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkerSessions
    **/
    _count?: true | WorkerSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkerSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkerSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkerSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkerSessionMaxAggregateInputType
  }

  export type GetWorkerSessionAggregateType<T extends WorkerSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkerSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkerSession[P]>
      : GetScalarType<T[P], AggregateWorkerSession[P]>
  }




  export type WorkerSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkerSessionWhereInput
    orderBy?: WorkerSessionOrderByWithAggregationInput | WorkerSessionOrderByWithAggregationInput[]
    by: WorkerSessionScalarFieldEnum[] | WorkerSessionScalarFieldEnum
    having?: WorkerSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkerSessionCountAggregateInputType | true
    _avg?: WorkerSessionAvgAggregateInputType
    _sum?: WorkerSessionSumAggregateInputType
    _min?: WorkerSessionMinAggregateInputType
    _max?: WorkerSessionMaxAggregateInputType
  }

  export type WorkerSessionGroupByOutputType = {
    id: string
    workerId: number | null
    autoApplicationId: string
    status: $Enums.WorkerSessionStatus
    browserSessionId: string | null
    vncUrl: string | null
    queuedAt: Date
    assignedAt: Date | null
    aiStartedAt: Date | null
    aiCompletedAt: Date | null
    submittedAt: Date | null
    completedAt: Date | null
    formData: JsonValue | null
    screenshotUrl: string | null
    workerNotes: string | null
    failReason: string | null
    skipReason: string | null
    _count: WorkerSessionCountAggregateOutputType | null
    _avg: WorkerSessionAvgAggregateOutputType | null
    _sum: WorkerSessionSumAggregateOutputType | null
    _min: WorkerSessionMinAggregateOutputType | null
    _max: WorkerSessionMaxAggregateOutputType | null
  }

  type GetWorkerSessionGroupByPayload<T extends WorkerSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkerSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkerSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkerSessionGroupByOutputType[P]>
            : GetScalarType<T[P], WorkerSessionGroupByOutputType[P]>
        }
      >
    >


  export type WorkerSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workerId?: boolean
    autoApplicationId?: boolean
    status?: boolean
    browserSessionId?: boolean
    vncUrl?: boolean
    queuedAt?: boolean
    assignedAt?: boolean
    aiStartedAt?: boolean
    aiCompletedAt?: boolean
    submittedAt?: boolean
    completedAt?: boolean
    formData?: boolean
    screenshotUrl?: boolean
    workerNotes?: boolean
    failReason?: boolean
    skipReason?: boolean
    worker?: boolean | WorkerSession$workerArgs<ExtArgs>
    autoApplication?: boolean | AutoApplicationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workerSession"]>

  export type WorkerSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workerId?: boolean
    autoApplicationId?: boolean
    status?: boolean
    browserSessionId?: boolean
    vncUrl?: boolean
    queuedAt?: boolean
    assignedAt?: boolean
    aiStartedAt?: boolean
    aiCompletedAt?: boolean
    submittedAt?: boolean
    completedAt?: boolean
    formData?: boolean
    screenshotUrl?: boolean
    workerNotes?: boolean
    failReason?: boolean
    skipReason?: boolean
    worker?: boolean | WorkerSession$workerArgs<ExtArgs>
    autoApplication?: boolean | AutoApplicationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workerSession"]>

  export type WorkerSessionSelectScalar = {
    id?: boolean
    workerId?: boolean
    autoApplicationId?: boolean
    status?: boolean
    browserSessionId?: boolean
    vncUrl?: boolean
    queuedAt?: boolean
    assignedAt?: boolean
    aiStartedAt?: boolean
    aiCompletedAt?: boolean
    submittedAt?: boolean
    completedAt?: boolean
    formData?: boolean
    screenshotUrl?: boolean
    workerNotes?: boolean
    failReason?: boolean
    skipReason?: boolean
  }

  export type WorkerSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    worker?: boolean | WorkerSession$workerArgs<ExtArgs>
    autoApplication?: boolean | AutoApplicationDefaultArgs<ExtArgs>
  }
  export type WorkerSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    worker?: boolean | WorkerSession$workerArgs<ExtArgs>
    autoApplication?: boolean | AutoApplicationDefaultArgs<ExtArgs>
  }

  export type $WorkerSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkerSession"
    objects: {
      worker: Prisma.$WorkerPayload<ExtArgs> | null
      autoApplication: Prisma.$AutoApplicationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workerId: number | null
      autoApplicationId: string
      status: $Enums.WorkerSessionStatus
      browserSessionId: string | null
      vncUrl: string | null
      queuedAt: Date
      assignedAt: Date | null
      aiStartedAt: Date | null
      aiCompletedAt: Date | null
      submittedAt: Date | null
      completedAt: Date | null
      formData: Prisma.JsonValue | null
      screenshotUrl: string | null
      workerNotes: string | null
      failReason: string | null
      skipReason: string | null
    }, ExtArgs["result"]["workerSession"]>
    composites: {}
  }

  type WorkerSessionGetPayload<S extends boolean | null | undefined | WorkerSessionDefaultArgs> = $Result.GetResult<Prisma.$WorkerSessionPayload, S>

  type WorkerSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WorkerSessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WorkerSessionCountAggregateInputType | true
    }

  export interface WorkerSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkerSession'], meta: { name: 'WorkerSession' } }
    /**
     * Find zero or one WorkerSession that matches the filter.
     * @param {WorkerSessionFindUniqueArgs} args - Arguments to find a WorkerSession
     * @example
     * // Get one WorkerSession
     * const workerSession = await prisma.workerSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkerSessionFindUniqueArgs>(args: SelectSubset<T, WorkerSessionFindUniqueArgs<ExtArgs>>): Prisma__WorkerSessionClient<$Result.GetResult<Prisma.$WorkerSessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WorkerSession that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WorkerSessionFindUniqueOrThrowArgs} args - Arguments to find a WorkerSession
     * @example
     * // Get one WorkerSession
     * const workerSession = await prisma.workerSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkerSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkerSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkerSessionClient<$Result.GetResult<Prisma.$WorkerSessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WorkerSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerSessionFindFirstArgs} args - Arguments to find a WorkerSession
     * @example
     * // Get one WorkerSession
     * const workerSession = await prisma.workerSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkerSessionFindFirstArgs>(args?: SelectSubset<T, WorkerSessionFindFirstArgs<ExtArgs>>): Prisma__WorkerSessionClient<$Result.GetResult<Prisma.$WorkerSessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WorkerSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerSessionFindFirstOrThrowArgs} args - Arguments to find a WorkerSession
     * @example
     * // Get one WorkerSession
     * const workerSession = await prisma.workerSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkerSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkerSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkerSessionClient<$Result.GetResult<Prisma.$WorkerSessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WorkerSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkerSessions
     * const workerSessions = await prisma.workerSession.findMany()
     * 
     * // Get first 10 WorkerSessions
     * const workerSessions = await prisma.workerSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workerSessionWithIdOnly = await prisma.workerSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkerSessionFindManyArgs>(args?: SelectSubset<T, WorkerSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkerSessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WorkerSession.
     * @param {WorkerSessionCreateArgs} args - Arguments to create a WorkerSession.
     * @example
     * // Create one WorkerSession
     * const WorkerSession = await prisma.workerSession.create({
     *   data: {
     *     // ... data to create a WorkerSession
     *   }
     * })
     * 
     */
    create<T extends WorkerSessionCreateArgs>(args: SelectSubset<T, WorkerSessionCreateArgs<ExtArgs>>): Prisma__WorkerSessionClient<$Result.GetResult<Prisma.$WorkerSessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WorkerSessions.
     * @param {WorkerSessionCreateManyArgs} args - Arguments to create many WorkerSessions.
     * @example
     * // Create many WorkerSessions
     * const workerSession = await prisma.workerSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkerSessionCreateManyArgs>(args?: SelectSubset<T, WorkerSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkerSessions and returns the data saved in the database.
     * @param {WorkerSessionCreateManyAndReturnArgs} args - Arguments to create many WorkerSessions.
     * @example
     * // Create many WorkerSessions
     * const workerSession = await prisma.workerSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkerSessions and only return the `id`
     * const workerSessionWithIdOnly = await prisma.workerSession.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkerSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkerSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkerSessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WorkerSession.
     * @param {WorkerSessionDeleteArgs} args - Arguments to delete one WorkerSession.
     * @example
     * // Delete one WorkerSession
     * const WorkerSession = await prisma.workerSession.delete({
     *   where: {
     *     // ... filter to delete one WorkerSession
     *   }
     * })
     * 
     */
    delete<T extends WorkerSessionDeleteArgs>(args: SelectSubset<T, WorkerSessionDeleteArgs<ExtArgs>>): Prisma__WorkerSessionClient<$Result.GetResult<Prisma.$WorkerSessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WorkerSession.
     * @param {WorkerSessionUpdateArgs} args - Arguments to update one WorkerSession.
     * @example
     * // Update one WorkerSession
     * const workerSession = await prisma.workerSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkerSessionUpdateArgs>(args: SelectSubset<T, WorkerSessionUpdateArgs<ExtArgs>>): Prisma__WorkerSessionClient<$Result.GetResult<Prisma.$WorkerSessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WorkerSessions.
     * @param {WorkerSessionDeleteManyArgs} args - Arguments to filter WorkerSessions to delete.
     * @example
     * // Delete a few WorkerSessions
     * const { count } = await prisma.workerSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkerSessionDeleteManyArgs>(args?: SelectSubset<T, WorkerSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkerSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkerSessions
     * const workerSession = await prisma.workerSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkerSessionUpdateManyArgs>(args: SelectSubset<T, WorkerSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WorkerSession.
     * @param {WorkerSessionUpsertArgs} args - Arguments to update or create a WorkerSession.
     * @example
     * // Update or create a WorkerSession
     * const workerSession = await prisma.workerSession.upsert({
     *   create: {
     *     // ... data to create a WorkerSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkerSession we want to update
     *   }
     * })
     */
    upsert<T extends WorkerSessionUpsertArgs>(args: SelectSubset<T, WorkerSessionUpsertArgs<ExtArgs>>): Prisma__WorkerSessionClient<$Result.GetResult<Prisma.$WorkerSessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WorkerSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerSessionCountArgs} args - Arguments to filter WorkerSessions to count.
     * @example
     * // Count the number of WorkerSessions
     * const count = await prisma.workerSession.count({
     *   where: {
     *     // ... the filter for the WorkerSessions we want to count
     *   }
     * })
    **/
    count<T extends WorkerSessionCountArgs>(
      args?: Subset<T, WorkerSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkerSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkerSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkerSessionAggregateArgs>(args: Subset<T, WorkerSessionAggregateArgs>): Prisma.PrismaPromise<GetWorkerSessionAggregateType<T>>

    /**
     * Group by WorkerSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkerSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkerSessionGroupByArgs['orderBy'] }
        : { orderBy?: WorkerSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkerSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkerSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkerSession model
   */
  readonly fields: WorkerSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkerSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkerSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    worker<T extends WorkerSession$workerArgs<ExtArgs> = {}>(args?: Subset<T, WorkerSession$workerArgs<ExtArgs>>): Prisma__WorkerClient<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    autoApplication<T extends AutoApplicationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AutoApplicationDefaultArgs<ExtArgs>>): Prisma__AutoApplicationClient<$Result.GetResult<Prisma.$AutoApplicationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkerSession model
   */ 
  interface WorkerSessionFieldRefs {
    readonly id: FieldRef<"WorkerSession", 'String'>
    readonly workerId: FieldRef<"WorkerSession", 'Int'>
    readonly autoApplicationId: FieldRef<"WorkerSession", 'String'>
    readonly status: FieldRef<"WorkerSession", 'WorkerSessionStatus'>
    readonly browserSessionId: FieldRef<"WorkerSession", 'String'>
    readonly vncUrl: FieldRef<"WorkerSession", 'String'>
    readonly queuedAt: FieldRef<"WorkerSession", 'DateTime'>
    readonly assignedAt: FieldRef<"WorkerSession", 'DateTime'>
    readonly aiStartedAt: FieldRef<"WorkerSession", 'DateTime'>
    readonly aiCompletedAt: FieldRef<"WorkerSession", 'DateTime'>
    readonly submittedAt: FieldRef<"WorkerSession", 'DateTime'>
    readonly completedAt: FieldRef<"WorkerSession", 'DateTime'>
    readonly formData: FieldRef<"WorkerSession", 'Json'>
    readonly screenshotUrl: FieldRef<"WorkerSession", 'String'>
    readonly workerNotes: FieldRef<"WorkerSession", 'String'>
    readonly failReason: FieldRef<"WorkerSession", 'String'>
    readonly skipReason: FieldRef<"WorkerSession", 'String'>
  }
    

  // Custom InputTypes
  /**
   * WorkerSession findUnique
   */
  export type WorkerSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerSession
     */
    select?: WorkerSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerSessionInclude<ExtArgs> | null
    /**
     * Filter, which WorkerSession to fetch.
     */
    where: WorkerSessionWhereUniqueInput
  }

  /**
   * WorkerSession findUniqueOrThrow
   */
  export type WorkerSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerSession
     */
    select?: WorkerSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerSessionInclude<ExtArgs> | null
    /**
     * Filter, which WorkerSession to fetch.
     */
    where: WorkerSessionWhereUniqueInput
  }

  /**
   * WorkerSession findFirst
   */
  export type WorkerSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerSession
     */
    select?: WorkerSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerSessionInclude<ExtArgs> | null
    /**
     * Filter, which WorkerSession to fetch.
     */
    where?: WorkerSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkerSessions to fetch.
     */
    orderBy?: WorkerSessionOrderByWithRelationInput | WorkerSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkerSessions.
     */
    cursor?: WorkerSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkerSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkerSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkerSessions.
     */
    distinct?: WorkerSessionScalarFieldEnum | WorkerSessionScalarFieldEnum[]
  }

  /**
   * WorkerSession findFirstOrThrow
   */
  export type WorkerSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerSession
     */
    select?: WorkerSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerSessionInclude<ExtArgs> | null
    /**
     * Filter, which WorkerSession to fetch.
     */
    where?: WorkerSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkerSessions to fetch.
     */
    orderBy?: WorkerSessionOrderByWithRelationInput | WorkerSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkerSessions.
     */
    cursor?: WorkerSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkerSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkerSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkerSessions.
     */
    distinct?: WorkerSessionScalarFieldEnum | WorkerSessionScalarFieldEnum[]
  }

  /**
   * WorkerSession findMany
   */
  export type WorkerSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerSession
     */
    select?: WorkerSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerSessionInclude<ExtArgs> | null
    /**
     * Filter, which WorkerSessions to fetch.
     */
    where?: WorkerSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkerSessions to fetch.
     */
    orderBy?: WorkerSessionOrderByWithRelationInput | WorkerSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkerSessions.
     */
    cursor?: WorkerSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkerSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkerSessions.
     */
    skip?: number
    distinct?: WorkerSessionScalarFieldEnum | WorkerSessionScalarFieldEnum[]
  }

  /**
   * WorkerSession create
   */
  export type WorkerSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerSession
     */
    select?: WorkerSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkerSession.
     */
    data: XOR<WorkerSessionCreateInput, WorkerSessionUncheckedCreateInput>
  }

  /**
   * WorkerSession createMany
   */
  export type WorkerSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkerSessions.
     */
    data: WorkerSessionCreateManyInput | WorkerSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkerSession createManyAndReturn
   */
  export type WorkerSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerSession
     */
    select?: WorkerSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WorkerSessions.
     */
    data: WorkerSessionCreateManyInput | WorkerSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkerSession update
   */
  export type WorkerSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerSession
     */
    select?: WorkerSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkerSession.
     */
    data: XOR<WorkerSessionUpdateInput, WorkerSessionUncheckedUpdateInput>
    /**
     * Choose, which WorkerSession to update.
     */
    where: WorkerSessionWhereUniqueInput
  }

  /**
   * WorkerSession updateMany
   */
  export type WorkerSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkerSessions.
     */
    data: XOR<WorkerSessionUpdateManyMutationInput, WorkerSessionUncheckedUpdateManyInput>
    /**
     * Filter which WorkerSessions to update
     */
    where?: WorkerSessionWhereInput
  }

  /**
   * WorkerSession upsert
   */
  export type WorkerSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerSession
     */
    select?: WorkerSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkerSession to update in case it exists.
     */
    where: WorkerSessionWhereUniqueInput
    /**
     * In case the WorkerSession found by the `where` argument doesn't exist, create a new WorkerSession with this data.
     */
    create: XOR<WorkerSessionCreateInput, WorkerSessionUncheckedCreateInput>
    /**
     * In case the WorkerSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkerSessionUpdateInput, WorkerSessionUncheckedUpdateInput>
  }

  /**
   * WorkerSession delete
   */
  export type WorkerSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerSession
     */
    select?: WorkerSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerSessionInclude<ExtArgs> | null
    /**
     * Filter which WorkerSession to delete.
     */
    where: WorkerSessionWhereUniqueInput
  }

  /**
   * WorkerSession deleteMany
   */
  export type WorkerSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkerSessions to delete
     */
    where?: WorkerSessionWhereInput
  }

  /**
   * WorkerSession.worker
   */
  export type WorkerSession$workerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
    where?: WorkerWhereInput
  }

  /**
   * WorkerSession without action
   */
  export type WorkerSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerSession
     */
    select?: WorkerSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerSessionInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    clerkId: 'clerkId',
    createdAt: 'createdAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const GmailConnectionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    email: 'email',
    accessToken: 'accessToken',
    refreshToken: 'refreshToken',
    expiresAt: 'expiresAt',
    scope: 'scope',
    isActive: 'isActive',
    lastUsed: 'lastUsed',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GmailConnectionScalarFieldEnum = (typeof GmailConnectionScalarFieldEnum)[keyof typeof GmailConnectionScalarFieldEnum]


  export const ProfileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    data: 'data',
    updatedAt: 'updatedAt'
  };

  export type ProfileScalarFieldEnum = (typeof ProfileScalarFieldEnum)[keyof typeof ProfileScalarFieldEnum]


  export const JobScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    status: 'status',
    priority: 'priority',
    attempts: 'attempts',
    maxAttempts: 'maxAttempts',
    resumeText: 'resumeText',
    jobDescription: 'jobDescription',
    aiMode: 'aiMode',
    matchMode: 'matchMode',
    error: 'error',
    diagnostics: 'diagnostics',
    processingLog: 'processingLog',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    company: 'company',
    jobUrl: 'jobUrl',
    role: 'role'
  };

  export type JobScalarFieldEnum = (typeof JobScalarFieldEnum)[keyof typeof JobScalarFieldEnum]


  export const ArtifactScalarFieldEnum: {
    id: 'id',
    jobId: 'jobId',
    type: 'type',
    version: 'version',
    content: 'content',
    metadata: 'metadata',
    schema: 'schema',
    validated: 'validated',
    createdAt: 'createdAt'
  };

  export type ArtifactScalarFieldEnum = (typeof ArtifactScalarFieldEnum)[keyof typeof ArtifactScalarFieldEnum]


  export const EmbeddingScalarFieldEnum: {
    id: 'id',
    jobId: 'jobId',
    content: 'content',
    contentType: 'contentType',
    embedding: 'embedding',
    relevance: 'relevance',
    createdAt: 'createdAt'
  };

  export type EmbeddingScalarFieldEnum = (typeof EmbeddingScalarFieldEnum)[keyof typeof EmbeddingScalarFieldEnum]


  export const SubscriptionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    stripeCustomerId: 'stripeCustomerId',
    stripeSubscriptionId: 'stripeSubscriptionId',
    tier: 'tier',
    status: 'status',
    currentPeriodStart: 'currentPeriodStart',
    currentPeriodEnd: 'currentPeriodEnd',
    cancelAtPeriodEnd: 'cancelAtPeriodEnd',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubscriptionScalarFieldEnum = (typeof SubscriptionScalarFieldEnum)[keyof typeof SubscriptionScalarFieldEnum]


  export const UsageTrackingScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    date: 'date',
    resumesGenerated: 'resumesGenerated',
    dailyLimit: 'dailyLimit',
    tier: 'tier',
    resetAt: 'resetAt'
  };

  export type UsageTrackingScalarFieldEnum = (typeof UsageTrackingScalarFieldEnum)[keyof typeof UsageTrackingScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    stripePaymentId: 'stripePaymentId',
    amount: 'amount',
    currency: 'currency',
    status: 'status',
    description: 'description',
    createdAt: 'createdAt'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const AggregatedJobScalarFieldEnum: {
    id: 'id',
    externalId: 'externalId',
    source: 'source',
    title: 'title',
    company: 'company',
    location: 'location',
    salary: 'salary',
    description: 'description',
    requirements: 'requirements',
    applyUrl: 'applyUrl',
    companyUrl: 'companyUrl',
    atsType: 'atsType',
    atsCompany: 'atsCompany',
    atsComplexity: 'atsComplexity',
    atsConfidence: 'atsConfidence',
    aiApplyable: 'aiApplyable',
    extractedSkills: 'extractedSkills',
    extractedExperience: 'extractedExperience',
    extractedEducation: 'extractedEducation',
    extractedJobLevel: 'extractedJobLevel',
    extractedKeywords: 'extractedKeywords',
    extractedBenefits: 'extractedBenefits',
    lastExtractedAt: 'lastExtractedAt',
    extractionConfidence: 'extractionConfidence',
    postedDate: 'postedDate',
    expiresAt: 'expiresAt',
    firstSeenAt: 'firstSeenAt',
    lastChecked: 'lastChecked',
    closedAt: 'closedAt',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AggregatedJobScalarFieldEnum = (typeof AggregatedJobScalarFieldEnum)[keyof typeof AggregatedJobScalarFieldEnum]


  export const AutoApplicationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    jobId: 'jobId',
    status: 'status',
    method: 'method',
    submittedAt: 'submittedAt',
    confirmationUrl: 'confirmationUrl',
    confirmationId: 'confirmationId',
    confirmationData: 'confirmationData',
    error: 'error',
    errorType: 'errorType',
    retryCount: 'retryCount',
    maxRetries: 'maxRetries',
    cost: 'cost',
    createdAt: 'createdAt',
    startedAt: 'startedAt',
    completedAt: 'completedAt'
  };

  export type AutoApplicationScalarFieldEnum = (typeof AutoApplicationScalarFieldEnum)[keyof typeof AutoApplicationScalarFieldEnum]


  export const ApplicationRecipeScalarFieldEnum: {
    id: 'id',
    platform: 'platform',
    atsType: 'atsType',
    version: 'version',
    steps: 'steps',
    successRate: 'successRate',
    timesUsed: 'timesUsed',
    failureCount: 'failureCount',
    recordingCost: 'recordingCost',
    replayCost: 'replayCost',
    totalSaved: 'totalSaved',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    lastUsed: 'lastUsed',
    lastFailure: 'lastFailure',
    recordedBy: 'recordedBy'
  };

  export type ApplicationRecipeScalarFieldEnum = (typeof ApplicationRecipeScalarFieldEnum)[keyof typeof ApplicationRecipeScalarFieldEnum]


  export const RecipeExecutionScalarFieldEnum: {
    id: 'id',
    recipeId: 'recipeId',
    success: 'success',
    method: 'method',
    duration: 'duration',
    cost: 'cost',
    error: 'error',
    errorType: 'errorType',
    jobUrl: 'jobUrl',
    executedAt: 'executedAt'
  };

  export type RecipeExecutionScalarFieldEnum = (typeof RecipeExecutionScalarFieldEnum)[keyof typeof RecipeExecutionScalarFieldEnum]


  export const DiscoveredCompanyScalarFieldEnum: {
    id: 'id',
    atsType: 'atsType',
    slug: 'slug',
    name: 'name',
    discoveredAt: 'discoveredAt',
    discoveredFrom: 'discoveredFrom',
    lastFetchedAt: 'lastFetchedAt',
    isActive: 'isActive',
    totalJobs: 'totalJobs',
    lastJobCount: 'lastJobCount'
  };

  export type DiscoveredCompanyScalarFieldEnum = (typeof DiscoveredCompanyScalarFieldEnum)[keyof typeof DiscoveredCompanyScalarFieldEnum]


  export const ConversationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    lastMessageAt: 'lastMessageAt'
  };

  export type ConversationScalarFieldEnum = (typeof ConversationScalarFieldEnum)[keyof typeof ConversationScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    conversationId: 'conversationId',
    role: 'role',
    content: 'content',
    metadata: 'metadata',
    tokenCount: 'tokenCount',
    cost: 'cost',
    createdAt: 'createdAt'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const GoalScalarFieldEnum: {
    id: 'id',
    conversationId: 'conversationId',
    userId: 'userId',
    title: 'title',
    description: 'description',
    type: 'type',
    status: 'status',
    targetDate: 'targetDate',
    completedAt: 'completedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    metadata: 'metadata'
  };

  export type GoalScalarFieldEnum = (typeof GoalScalarFieldEnum)[keyof typeof GoalScalarFieldEnum]


  export const MessageUsageScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    ip: 'ip',
    date: 'date',
    count: 'count',
    resetAt: 'resetAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MessageUsageScalarFieldEnum = (typeof MessageUsageScalarFieldEnum)[keyof typeof MessageUsageScalarFieldEnum]


  export const RoutineScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    description: 'description',
    type: 'type',
    frequency: 'frequency',
    schedule: 'schedule',
    config: 'config',
    isActive: 'isActive',
    lastRun: 'lastRun',
    nextRun: 'nextRun',
    runCount: 'runCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RoutineScalarFieldEnum = (typeof RoutineScalarFieldEnum)[keyof typeof RoutineScalarFieldEnum]


  export const RoutineExecutionScalarFieldEnum: {
    id: 'id',
    routineId: 'routineId',
    status: 'status',
    summary: 'summary',
    results: 'results',
    duration: 'duration',
    error: 'error',
    createdAt: 'createdAt'
  };

  export type RoutineExecutionScalarFieldEnum = (typeof RoutineExecutionScalarFieldEnum)[keyof typeof RoutineExecutionScalarFieldEnum]


  export const WorkerScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    name: 'name',
    isActive: 'isActive',
    role: 'role',
    totalCompleted: 'totalCompleted',
    totalFailed: 'totalFailed',
    totalSkipped: 'totalSkipped',
    avgTimeSeconds: 'avgTimeSeconds',
    lastActiveAt: 'lastActiveAt',
    currentSessionId: 'currentSessionId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WorkerScalarFieldEnum = (typeof WorkerScalarFieldEnum)[keyof typeof WorkerScalarFieldEnum]


  export const WorkerSessionScalarFieldEnum: {
    id: 'id',
    workerId: 'workerId',
    autoApplicationId: 'autoApplicationId',
    status: 'status',
    browserSessionId: 'browserSessionId',
    vncUrl: 'vncUrl',
    queuedAt: 'queuedAt',
    assignedAt: 'assignedAt',
    aiStartedAt: 'aiStartedAt',
    aiCompletedAt: 'aiCompletedAt',
    submittedAt: 'submittedAt',
    completedAt: 'completedAt',
    formData: 'formData',
    screenshotUrl: 'screenshotUrl',
    workerNotes: 'workerNotes',
    failReason: 'failReason',
    skipReason: 'skipReason'
  };

  export type WorkerSessionScalarFieldEnum = (typeof WorkerSessionScalarFieldEnum)[keyof typeof WorkerSessionScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'JobStatus'
   */
  export type EnumJobStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'JobStatus'>
    


  /**
   * Reference to a field of type 'JobStatus[]'
   */
  export type ListEnumJobStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'JobStatus[]'>
    


  /**
   * Reference to a field of type 'Json[]'
   */
  export type ListJsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json[]'>
    


  /**
   * Reference to a field of type 'ArtifactType'
   */
  export type EnumArtifactTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ArtifactType'>
    


  /**
   * Reference to a field of type 'ArtifactType[]'
   */
  export type ListEnumArtifactTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ArtifactType[]'>
    


  /**
   * Reference to a field of type 'Bytes'
   */
  export type BytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes'>
    


  /**
   * Reference to a field of type 'Bytes[]'
   */
  export type ListBytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes[]'>
    


  /**
   * Reference to a field of type 'EmbeddingType'
   */
  export type EnumEmbeddingTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EmbeddingType'>
    


  /**
   * Reference to a field of type 'EmbeddingType[]'
   */
  export type ListEnumEmbeddingTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EmbeddingType[]'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'SubscriptionTier'
   */
  export type EnumSubscriptionTierFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionTier'>
    


  /**
   * Reference to a field of type 'SubscriptionTier[]'
   */
  export type ListEnumSubscriptionTierFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionTier[]'>
    


  /**
   * Reference to a field of type 'SubscriptionStatus'
   */
  export type EnumSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionStatus'>
    


  /**
   * Reference to a field of type 'SubscriptionStatus[]'
   */
  export type ListEnumSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionStatus[]'>
    


  /**
   * Reference to a field of type 'PaymentStatus'
   */
  export type EnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus'>
    


  /**
   * Reference to a field of type 'PaymentStatus[]'
   */
  export type ListEnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus[]'>
    


  /**
   * Reference to a field of type 'AutoApplicationStatus'
   */
  export type EnumAutoApplicationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AutoApplicationStatus'>
    


  /**
   * Reference to a field of type 'AutoApplicationStatus[]'
   */
  export type ListEnumAutoApplicationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AutoApplicationStatus[]'>
    


  /**
   * Reference to a field of type 'MessageRole'
   */
  export type EnumMessageRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MessageRole'>
    


  /**
   * Reference to a field of type 'MessageRole[]'
   */
  export type ListEnumMessageRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MessageRole[]'>
    


  /**
   * Reference to a field of type 'GoalType'
   */
  export type EnumGoalTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GoalType'>
    


  /**
   * Reference to a field of type 'GoalType[]'
   */
  export type ListEnumGoalTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GoalType[]'>
    


  /**
   * Reference to a field of type 'GoalStatus'
   */
  export type EnumGoalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GoalStatus'>
    


  /**
   * Reference to a field of type 'GoalStatus[]'
   */
  export type ListEnumGoalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GoalStatus[]'>
    


  /**
   * Reference to a field of type 'RoutineType'
   */
  export type EnumRoutineTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RoutineType'>
    


  /**
   * Reference to a field of type 'RoutineType[]'
   */
  export type ListEnumRoutineTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RoutineType[]'>
    


  /**
   * Reference to a field of type 'WorkerRole'
   */
  export type EnumWorkerRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkerRole'>
    


  /**
   * Reference to a field of type 'WorkerRole[]'
   */
  export type ListEnumWorkerRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkerRole[]'>
    


  /**
   * Reference to a field of type 'WorkerSessionStatus'
   */
  export type EnumWorkerSessionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkerSessionStatus'>
    


  /**
   * Reference to a field of type 'WorkerSessionStatus[]'
   */
  export type ListEnumWorkerSessionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkerSessionStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    clerkId?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    jobs?: JobListRelationFilter
    profile?: XOR<ProfileNullableRelationFilter, ProfileWhereInput> | null
    subscription?: XOR<SubscriptionNullableRelationFilter, SubscriptionWhereInput> | null
    usageTracking?: UsageTrackingListRelationFilter
    payments?: PaymentListRelationFilter
    autoApplications?: AutoApplicationListRelationFilter
    conversations?: ConversationListRelationFilter
    goals?: GoalListRelationFilter
    routines?: RoutineListRelationFilter
    gmailConnection?: XOR<GmailConnectionNullableRelationFilter, GmailConnectionWhereInput> | null
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    clerkId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    jobs?: JobOrderByRelationAggregateInput
    profile?: ProfileOrderByWithRelationInput
    subscription?: SubscriptionOrderByWithRelationInput
    usageTracking?: UsageTrackingOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
    autoApplications?: AutoApplicationOrderByRelationAggregateInput
    conversations?: ConversationOrderByRelationAggregateInput
    goals?: GoalOrderByRelationAggregateInput
    routines?: RoutineOrderByRelationAggregateInput
    gmailConnection?: GmailConnectionOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    clerkId?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    jobs?: JobListRelationFilter
    profile?: XOR<ProfileNullableRelationFilter, ProfileWhereInput> | null
    subscription?: XOR<SubscriptionNullableRelationFilter, SubscriptionWhereInput> | null
    usageTracking?: UsageTrackingListRelationFilter
    payments?: PaymentListRelationFilter
    autoApplications?: AutoApplicationListRelationFilter
    conversations?: ConversationListRelationFilter
    goals?: GoalListRelationFilter
    routines?: RoutineListRelationFilter
    gmailConnection?: XOR<GmailConnectionNullableRelationFilter, GmailConnectionWhereInput> | null
  }, "id" | "email" | "clerkId">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    clerkId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    clerkId?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type GmailConnectionWhereInput = {
    AND?: GmailConnectionWhereInput | GmailConnectionWhereInput[]
    OR?: GmailConnectionWhereInput[]
    NOT?: GmailConnectionWhereInput | GmailConnectionWhereInput[]
    id?: StringFilter<"GmailConnection"> | string
    userId?: IntFilter<"GmailConnection"> | number
    email?: StringFilter<"GmailConnection"> | string
    accessToken?: StringFilter<"GmailConnection"> | string
    refreshToken?: StringFilter<"GmailConnection"> | string
    expiresAt?: DateTimeFilter<"GmailConnection"> | Date | string
    scope?: StringFilter<"GmailConnection"> | string
    isActive?: BoolFilter<"GmailConnection"> | boolean
    lastUsed?: DateTimeNullableFilter<"GmailConnection"> | Date | string | null
    createdAt?: DateTimeFilter<"GmailConnection"> | Date | string
    updatedAt?: DateTimeFilter<"GmailConnection"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type GmailConnectionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    expiresAt?: SortOrder
    scope?: SortOrder
    isActive?: SortOrder
    lastUsed?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type GmailConnectionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: number
    AND?: GmailConnectionWhereInput | GmailConnectionWhereInput[]
    OR?: GmailConnectionWhereInput[]
    NOT?: GmailConnectionWhereInput | GmailConnectionWhereInput[]
    email?: StringFilter<"GmailConnection"> | string
    accessToken?: StringFilter<"GmailConnection"> | string
    refreshToken?: StringFilter<"GmailConnection"> | string
    expiresAt?: DateTimeFilter<"GmailConnection"> | Date | string
    scope?: StringFilter<"GmailConnection"> | string
    isActive?: BoolFilter<"GmailConnection"> | boolean
    lastUsed?: DateTimeNullableFilter<"GmailConnection"> | Date | string | null
    createdAt?: DateTimeFilter<"GmailConnection"> | Date | string
    updatedAt?: DateTimeFilter<"GmailConnection"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type GmailConnectionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    expiresAt?: SortOrder
    scope?: SortOrder
    isActive?: SortOrder
    lastUsed?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GmailConnectionCountOrderByAggregateInput
    _avg?: GmailConnectionAvgOrderByAggregateInput
    _max?: GmailConnectionMaxOrderByAggregateInput
    _min?: GmailConnectionMinOrderByAggregateInput
    _sum?: GmailConnectionSumOrderByAggregateInput
  }

  export type GmailConnectionScalarWhereWithAggregatesInput = {
    AND?: GmailConnectionScalarWhereWithAggregatesInput | GmailConnectionScalarWhereWithAggregatesInput[]
    OR?: GmailConnectionScalarWhereWithAggregatesInput[]
    NOT?: GmailConnectionScalarWhereWithAggregatesInput | GmailConnectionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GmailConnection"> | string
    userId?: IntWithAggregatesFilter<"GmailConnection"> | number
    email?: StringWithAggregatesFilter<"GmailConnection"> | string
    accessToken?: StringWithAggregatesFilter<"GmailConnection"> | string
    refreshToken?: StringWithAggregatesFilter<"GmailConnection"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"GmailConnection"> | Date | string
    scope?: StringWithAggregatesFilter<"GmailConnection"> | string
    isActive?: BoolWithAggregatesFilter<"GmailConnection"> | boolean
    lastUsed?: DateTimeNullableWithAggregatesFilter<"GmailConnection"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"GmailConnection"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"GmailConnection"> | Date | string
  }

  export type ProfileWhereInput = {
    AND?: ProfileWhereInput | ProfileWhereInput[]
    OR?: ProfileWhereInput[]
    NOT?: ProfileWhereInput | ProfileWhereInput[]
    id?: IntFilter<"Profile"> | number
    userId?: IntFilter<"Profile"> | number
    data?: JsonFilter<"Profile">
    updatedAt?: DateTimeFilter<"Profile"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ProfileOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    data?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    AND?: ProfileWhereInput | ProfileWhereInput[]
    OR?: ProfileWhereInput[]
    NOT?: ProfileWhereInput | ProfileWhereInput[]
    data?: JsonFilter<"Profile">
    updatedAt?: DateTimeFilter<"Profile"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type ProfileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    data?: SortOrder
    updatedAt?: SortOrder
    _count?: ProfileCountOrderByAggregateInput
    _avg?: ProfileAvgOrderByAggregateInput
    _max?: ProfileMaxOrderByAggregateInput
    _min?: ProfileMinOrderByAggregateInput
    _sum?: ProfileSumOrderByAggregateInput
  }

  export type ProfileScalarWhereWithAggregatesInput = {
    AND?: ProfileScalarWhereWithAggregatesInput | ProfileScalarWhereWithAggregatesInput[]
    OR?: ProfileScalarWhereWithAggregatesInput[]
    NOT?: ProfileScalarWhereWithAggregatesInput | ProfileScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Profile"> | number
    userId?: IntWithAggregatesFilter<"Profile"> | number
    data?: JsonWithAggregatesFilter<"Profile">
    updatedAt?: DateTimeWithAggregatesFilter<"Profile"> | Date | string
  }

  export type JobWhereInput = {
    AND?: JobWhereInput | JobWhereInput[]
    OR?: JobWhereInput[]
    NOT?: JobWhereInput | JobWhereInput[]
    id?: StringFilter<"Job"> | string
    userId?: IntNullableFilter<"Job"> | number | null
    status?: EnumJobStatusFilter<"Job"> | $Enums.JobStatus
    priority?: IntFilter<"Job"> | number
    attempts?: IntFilter<"Job"> | number
    maxAttempts?: IntFilter<"Job"> | number
    resumeText?: StringNullableFilter<"Job"> | string | null
    jobDescription?: StringFilter<"Job"> | string
    aiMode?: StringNullableFilter<"Job"> | string | null
    matchMode?: StringNullableFilter<"Job"> | string | null
    error?: StringNullableFilter<"Job"> | string | null
    diagnostics?: JsonNullableFilter<"Job">
    processingLog?: JsonNullableListFilter<"Job">
    metadata?: JsonNullableFilter<"Job">
    createdAt?: DateTimeFilter<"Job"> | Date | string
    updatedAt?: DateTimeFilter<"Job"> | Date | string
    startedAt?: DateTimeNullableFilter<"Job"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Job"> | Date | string | null
    company?: StringNullableFilter<"Job"> | string | null
    jobUrl?: StringNullableFilter<"Job"> | string | null
    role?: StringNullableFilter<"Job"> | string | null
    artifacts?: ArtifactListRelationFilter
    embeddings?: EmbeddingListRelationFilter
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type JobOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    attempts?: SortOrder
    maxAttempts?: SortOrder
    resumeText?: SortOrderInput | SortOrder
    jobDescription?: SortOrder
    aiMode?: SortOrderInput | SortOrder
    matchMode?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    diagnostics?: SortOrderInput | SortOrder
    processingLog?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    company?: SortOrderInput | SortOrder
    jobUrl?: SortOrderInput | SortOrder
    role?: SortOrderInput | SortOrder
    artifacts?: ArtifactOrderByRelationAggregateInput
    embeddings?: EmbeddingOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
  }

  export type JobWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: JobWhereInput | JobWhereInput[]
    OR?: JobWhereInput[]
    NOT?: JobWhereInput | JobWhereInput[]
    userId?: IntNullableFilter<"Job"> | number | null
    status?: EnumJobStatusFilter<"Job"> | $Enums.JobStatus
    priority?: IntFilter<"Job"> | number
    attempts?: IntFilter<"Job"> | number
    maxAttempts?: IntFilter<"Job"> | number
    resumeText?: StringNullableFilter<"Job"> | string | null
    jobDescription?: StringFilter<"Job"> | string
    aiMode?: StringNullableFilter<"Job"> | string | null
    matchMode?: StringNullableFilter<"Job"> | string | null
    error?: StringNullableFilter<"Job"> | string | null
    diagnostics?: JsonNullableFilter<"Job">
    processingLog?: JsonNullableListFilter<"Job">
    metadata?: JsonNullableFilter<"Job">
    createdAt?: DateTimeFilter<"Job"> | Date | string
    updatedAt?: DateTimeFilter<"Job"> | Date | string
    startedAt?: DateTimeNullableFilter<"Job"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Job"> | Date | string | null
    company?: StringNullableFilter<"Job"> | string | null
    jobUrl?: StringNullableFilter<"Job"> | string | null
    role?: StringNullableFilter<"Job"> | string | null
    artifacts?: ArtifactListRelationFilter
    embeddings?: EmbeddingListRelationFilter
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type JobOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    attempts?: SortOrder
    maxAttempts?: SortOrder
    resumeText?: SortOrderInput | SortOrder
    jobDescription?: SortOrder
    aiMode?: SortOrderInput | SortOrder
    matchMode?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    diagnostics?: SortOrderInput | SortOrder
    processingLog?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    company?: SortOrderInput | SortOrder
    jobUrl?: SortOrderInput | SortOrder
    role?: SortOrderInput | SortOrder
    _count?: JobCountOrderByAggregateInput
    _avg?: JobAvgOrderByAggregateInput
    _max?: JobMaxOrderByAggregateInput
    _min?: JobMinOrderByAggregateInput
    _sum?: JobSumOrderByAggregateInput
  }

  export type JobScalarWhereWithAggregatesInput = {
    AND?: JobScalarWhereWithAggregatesInput | JobScalarWhereWithAggregatesInput[]
    OR?: JobScalarWhereWithAggregatesInput[]
    NOT?: JobScalarWhereWithAggregatesInput | JobScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Job"> | string
    userId?: IntNullableWithAggregatesFilter<"Job"> | number | null
    status?: EnumJobStatusWithAggregatesFilter<"Job"> | $Enums.JobStatus
    priority?: IntWithAggregatesFilter<"Job"> | number
    attempts?: IntWithAggregatesFilter<"Job"> | number
    maxAttempts?: IntWithAggregatesFilter<"Job"> | number
    resumeText?: StringNullableWithAggregatesFilter<"Job"> | string | null
    jobDescription?: StringWithAggregatesFilter<"Job"> | string
    aiMode?: StringNullableWithAggregatesFilter<"Job"> | string | null
    matchMode?: StringNullableWithAggregatesFilter<"Job"> | string | null
    error?: StringNullableWithAggregatesFilter<"Job"> | string | null
    diagnostics?: JsonNullableWithAggregatesFilter<"Job">
    processingLog?: JsonNullableListFilter<"Job">
    metadata?: JsonNullableWithAggregatesFilter<"Job">
    createdAt?: DateTimeWithAggregatesFilter<"Job"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Job"> | Date | string
    startedAt?: DateTimeNullableWithAggregatesFilter<"Job"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"Job"> | Date | string | null
    company?: StringNullableWithAggregatesFilter<"Job"> | string | null
    jobUrl?: StringNullableWithAggregatesFilter<"Job"> | string | null
    role?: StringNullableWithAggregatesFilter<"Job"> | string | null
  }

  export type ArtifactWhereInput = {
    AND?: ArtifactWhereInput | ArtifactWhereInput[]
    OR?: ArtifactWhereInput[]
    NOT?: ArtifactWhereInput | ArtifactWhereInput[]
    id?: StringFilter<"Artifact"> | string
    jobId?: StringFilter<"Artifact"> | string
    type?: EnumArtifactTypeFilter<"Artifact"> | $Enums.ArtifactType
    version?: IntFilter<"Artifact"> | number
    content?: BytesFilter<"Artifact"> | Buffer
    metadata?: JsonNullableFilter<"Artifact">
    schema?: JsonNullableFilter<"Artifact">
    validated?: BoolFilter<"Artifact"> | boolean
    createdAt?: DateTimeFilter<"Artifact"> | Date | string
    job?: XOR<JobRelationFilter, JobWhereInput>
  }

  export type ArtifactOrderByWithRelationInput = {
    id?: SortOrder
    jobId?: SortOrder
    type?: SortOrder
    version?: SortOrder
    content?: SortOrder
    metadata?: SortOrderInput | SortOrder
    schema?: SortOrderInput | SortOrder
    validated?: SortOrder
    createdAt?: SortOrder
    job?: JobOrderByWithRelationInput
  }

  export type ArtifactWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    jobId_type_version?: ArtifactJobIdTypeVersionCompoundUniqueInput
    AND?: ArtifactWhereInput | ArtifactWhereInput[]
    OR?: ArtifactWhereInput[]
    NOT?: ArtifactWhereInput | ArtifactWhereInput[]
    jobId?: StringFilter<"Artifact"> | string
    type?: EnumArtifactTypeFilter<"Artifact"> | $Enums.ArtifactType
    version?: IntFilter<"Artifact"> | number
    content?: BytesFilter<"Artifact"> | Buffer
    metadata?: JsonNullableFilter<"Artifact">
    schema?: JsonNullableFilter<"Artifact">
    validated?: BoolFilter<"Artifact"> | boolean
    createdAt?: DateTimeFilter<"Artifact"> | Date | string
    job?: XOR<JobRelationFilter, JobWhereInput>
  }, "id" | "jobId_type_version">

  export type ArtifactOrderByWithAggregationInput = {
    id?: SortOrder
    jobId?: SortOrder
    type?: SortOrder
    version?: SortOrder
    content?: SortOrder
    metadata?: SortOrderInput | SortOrder
    schema?: SortOrderInput | SortOrder
    validated?: SortOrder
    createdAt?: SortOrder
    _count?: ArtifactCountOrderByAggregateInput
    _avg?: ArtifactAvgOrderByAggregateInput
    _max?: ArtifactMaxOrderByAggregateInput
    _min?: ArtifactMinOrderByAggregateInput
    _sum?: ArtifactSumOrderByAggregateInput
  }

  export type ArtifactScalarWhereWithAggregatesInput = {
    AND?: ArtifactScalarWhereWithAggregatesInput | ArtifactScalarWhereWithAggregatesInput[]
    OR?: ArtifactScalarWhereWithAggregatesInput[]
    NOT?: ArtifactScalarWhereWithAggregatesInput | ArtifactScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Artifact"> | string
    jobId?: StringWithAggregatesFilter<"Artifact"> | string
    type?: EnumArtifactTypeWithAggregatesFilter<"Artifact"> | $Enums.ArtifactType
    version?: IntWithAggregatesFilter<"Artifact"> | number
    content?: BytesWithAggregatesFilter<"Artifact"> | Buffer
    metadata?: JsonNullableWithAggregatesFilter<"Artifact">
    schema?: JsonNullableWithAggregatesFilter<"Artifact">
    validated?: BoolWithAggregatesFilter<"Artifact"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Artifact"> | Date | string
  }

  export type EmbeddingWhereInput = {
    AND?: EmbeddingWhereInput | EmbeddingWhereInput[]
    OR?: EmbeddingWhereInput[]
    NOT?: EmbeddingWhereInput | EmbeddingWhereInput[]
    id?: StringFilter<"Embedding"> | string
    jobId?: StringFilter<"Embedding"> | string
    content?: StringFilter<"Embedding"> | string
    contentType?: EnumEmbeddingTypeFilter<"Embedding"> | $Enums.EmbeddingType
    embedding?: FloatNullableListFilter<"Embedding">
    relevance?: FloatNullableFilter<"Embedding"> | number | null
    createdAt?: DateTimeFilter<"Embedding"> | Date | string
    job?: XOR<JobRelationFilter, JobWhereInput>
  }

  export type EmbeddingOrderByWithRelationInput = {
    id?: SortOrder
    jobId?: SortOrder
    content?: SortOrder
    contentType?: SortOrder
    embedding?: SortOrder
    relevance?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    job?: JobOrderByWithRelationInput
  }

  export type EmbeddingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EmbeddingWhereInput | EmbeddingWhereInput[]
    OR?: EmbeddingWhereInput[]
    NOT?: EmbeddingWhereInput | EmbeddingWhereInput[]
    jobId?: StringFilter<"Embedding"> | string
    content?: StringFilter<"Embedding"> | string
    contentType?: EnumEmbeddingTypeFilter<"Embedding"> | $Enums.EmbeddingType
    embedding?: FloatNullableListFilter<"Embedding">
    relevance?: FloatNullableFilter<"Embedding"> | number | null
    createdAt?: DateTimeFilter<"Embedding"> | Date | string
    job?: XOR<JobRelationFilter, JobWhereInput>
  }, "id">

  export type EmbeddingOrderByWithAggregationInput = {
    id?: SortOrder
    jobId?: SortOrder
    content?: SortOrder
    contentType?: SortOrder
    embedding?: SortOrder
    relevance?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: EmbeddingCountOrderByAggregateInput
    _avg?: EmbeddingAvgOrderByAggregateInput
    _max?: EmbeddingMaxOrderByAggregateInput
    _min?: EmbeddingMinOrderByAggregateInput
    _sum?: EmbeddingSumOrderByAggregateInput
  }

  export type EmbeddingScalarWhereWithAggregatesInput = {
    AND?: EmbeddingScalarWhereWithAggregatesInput | EmbeddingScalarWhereWithAggregatesInput[]
    OR?: EmbeddingScalarWhereWithAggregatesInput[]
    NOT?: EmbeddingScalarWhereWithAggregatesInput | EmbeddingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Embedding"> | string
    jobId?: StringWithAggregatesFilter<"Embedding"> | string
    content?: StringWithAggregatesFilter<"Embedding"> | string
    contentType?: EnumEmbeddingTypeWithAggregatesFilter<"Embedding"> | $Enums.EmbeddingType
    embedding?: FloatNullableListFilter<"Embedding">
    relevance?: FloatNullableWithAggregatesFilter<"Embedding"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Embedding"> | Date | string
  }

  export type SubscriptionWhereInput = {
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    id?: StringFilter<"Subscription"> | string
    userId?: IntFilter<"Subscription"> | number
    stripeCustomerId?: StringNullableFilter<"Subscription"> | string | null
    stripeSubscriptionId?: StringNullableFilter<"Subscription"> | string | null
    tier?: EnumSubscriptionTierFilter<"Subscription"> | $Enums.SubscriptionTier
    status?: EnumSubscriptionStatusFilter<"Subscription"> | $Enums.SubscriptionStatus
    currentPeriodStart?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    currentPeriodEnd?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    cancelAtPeriodEnd?: BoolFilter<"Subscription"> | boolean
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type SubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    stripeCustomerId?: SortOrderInput | SortOrder
    stripeSubscriptionId?: SortOrderInput | SortOrder
    tier?: SortOrder
    status?: SortOrder
    currentPeriodStart?: SortOrderInput | SortOrder
    currentPeriodEnd?: SortOrderInput | SortOrder
    cancelAtPeriodEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: number
    stripeCustomerId?: string
    stripeSubscriptionId?: string
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    tier?: EnumSubscriptionTierFilter<"Subscription"> | $Enums.SubscriptionTier
    status?: EnumSubscriptionStatusFilter<"Subscription"> | $Enums.SubscriptionStatus
    currentPeriodStart?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    currentPeriodEnd?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    cancelAtPeriodEnd?: BoolFilter<"Subscription"> | boolean
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId" | "stripeCustomerId" | "stripeSubscriptionId">

  export type SubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    stripeCustomerId?: SortOrderInput | SortOrder
    stripeSubscriptionId?: SortOrderInput | SortOrder
    tier?: SortOrder
    status?: SortOrder
    currentPeriodStart?: SortOrderInput | SortOrder
    currentPeriodEnd?: SortOrderInput | SortOrder
    cancelAtPeriodEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubscriptionCountOrderByAggregateInput
    _avg?: SubscriptionAvgOrderByAggregateInput
    _max?: SubscriptionMaxOrderByAggregateInput
    _min?: SubscriptionMinOrderByAggregateInput
    _sum?: SubscriptionSumOrderByAggregateInput
  }

  export type SubscriptionScalarWhereWithAggregatesInput = {
    AND?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    OR?: SubscriptionScalarWhereWithAggregatesInput[]
    NOT?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Subscription"> | string
    userId?: IntWithAggregatesFilter<"Subscription"> | number
    stripeCustomerId?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    stripeSubscriptionId?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    tier?: EnumSubscriptionTierWithAggregatesFilter<"Subscription"> | $Enums.SubscriptionTier
    status?: EnumSubscriptionStatusWithAggregatesFilter<"Subscription"> | $Enums.SubscriptionStatus
    currentPeriodStart?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    currentPeriodEnd?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    cancelAtPeriodEnd?: BoolWithAggregatesFilter<"Subscription"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
  }

  export type UsageTrackingWhereInput = {
    AND?: UsageTrackingWhereInput | UsageTrackingWhereInput[]
    OR?: UsageTrackingWhereInput[]
    NOT?: UsageTrackingWhereInput | UsageTrackingWhereInput[]
    id?: StringFilter<"UsageTracking"> | string
    userId?: IntFilter<"UsageTracking"> | number
    date?: DateTimeFilter<"UsageTracking"> | Date | string
    resumesGenerated?: IntFilter<"UsageTracking"> | number
    dailyLimit?: IntFilter<"UsageTracking"> | number
    tier?: EnumSubscriptionTierFilter<"UsageTracking"> | $Enums.SubscriptionTier
    resetAt?: DateTimeFilter<"UsageTracking"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UsageTrackingOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    resumesGenerated?: SortOrder
    dailyLimit?: SortOrder
    tier?: SortOrder
    resetAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UsageTrackingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_date?: UsageTrackingUserIdDateCompoundUniqueInput
    AND?: UsageTrackingWhereInput | UsageTrackingWhereInput[]
    OR?: UsageTrackingWhereInput[]
    NOT?: UsageTrackingWhereInput | UsageTrackingWhereInput[]
    userId?: IntFilter<"UsageTracking"> | number
    date?: DateTimeFilter<"UsageTracking"> | Date | string
    resumesGenerated?: IntFilter<"UsageTracking"> | number
    dailyLimit?: IntFilter<"UsageTracking"> | number
    tier?: EnumSubscriptionTierFilter<"UsageTracking"> | $Enums.SubscriptionTier
    resetAt?: DateTimeFilter<"UsageTracking"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId_date">

  export type UsageTrackingOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    resumesGenerated?: SortOrder
    dailyLimit?: SortOrder
    tier?: SortOrder
    resetAt?: SortOrder
    _count?: UsageTrackingCountOrderByAggregateInput
    _avg?: UsageTrackingAvgOrderByAggregateInput
    _max?: UsageTrackingMaxOrderByAggregateInput
    _min?: UsageTrackingMinOrderByAggregateInput
    _sum?: UsageTrackingSumOrderByAggregateInput
  }

  export type UsageTrackingScalarWhereWithAggregatesInput = {
    AND?: UsageTrackingScalarWhereWithAggregatesInput | UsageTrackingScalarWhereWithAggregatesInput[]
    OR?: UsageTrackingScalarWhereWithAggregatesInput[]
    NOT?: UsageTrackingScalarWhereWithAggregatesInput | UsageTrackingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UsageTracking"> | string
    userId?: IntWithAggregatesFilter<"UsageTracking"> | number
    date?: DateTimeWithAggregatesFilter<"UsageTracking"> | Date | string
    resumesGenerated?: IntWithAggregatesFilter<"UsageTracking"> | number
    dailyLimit?: IntWithAggregatesFilter<"UsageTracking"> | number
    tier?: EnumSubscriptionTierWithAggregatesFilter<"UsageTracking"> | $Enums.SubscriptionTier
    resetAt?: DateTimeWithAggregatesFilter<"UsageTracking"> | Date | string
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: StringFilter<"Payment"> | string
    userId?: IntFilter<"Payment"> | number
    stripePaymentId?: StringFilter<"Payment"> | string
    amount?: IntFilter<"Payment"> | number
    currency?: StringFilter<"Payment"> | string
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    description?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    stripePaymentId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    stripePaymentId?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    userId?: IntFilter<"Payment"> | number
    amount?: IntFilter<"Payment"> | number
    currency?: StringFilter<"Payment"> | string
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    description?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "stripePaymentId">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    stripePaymentId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payment"> | string
    userId?: IntWithAggregatesFilter<"Payment"> | number
    stripePaymentId?: StringWithAggregatesFilter<"Payment"> | string
    amount?: IntWithAggregatesFilter<"Payment"> | number
    currency?: StringWithAggregatesFilter<"Payment"> | string
    status?: EnumPaymentStatusWithAggregatesFilter<"Payment"> | $Enums.PaymentStatus
    description?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
  }

  export type AggregatedJobWhereInput = {
    AND?: AggregatedJobWhereInput | AggregatedJobWhereInput[]
    OR?: AggregatedJobWhereInput[]
    NOT?: AggregatedJobWhereInput | AggregatedJobWhereInput[]
    id?: StringFilter<"AggregatedJob"> | string
    externalId?: StringFilter<"AggregatedJob"> | string
    source?: StringFilter<"AggregatedJob"> | string
    title?: StringFilter<"AggregatedJob"> | string
    company?: StringFilter<"AggregatedJob"> | string
    location?: StringNullableFilter<"AggregatedJob"> | string | null
    salary?: StringNullableFilter<"AggregatedJob"> | string | null
    description?: StringFilter<"AggregatedJob"> | string
    requirements?: StringNullableFilter<"AggregatedJob"> | string | null
    applyUrl?: StringFilter<"AggregatedJob"> | string
    companyUrl?: StringNullableFilter<"AggregatedJob"> | string | null
    atsType?: StringFilter<"AggregatedJob"> | string
    atsCompany?: StringNullableFilter<"AggregatedJob"> | string | null
    atsComplexity?: StringFilter<"AggregatedJob"> | string
    atsConfidence?: FloatFilter<"AggregatedJob"> | number
    aiApplyable?: BoolFilter<"AggregatedJob"> | boolean
    extractedSkills?: StringNullableListFilter<"AggregatedJob">
    extractedExperience?: StringNullableFilter<"AggregatedJob"> | string | null
    extractedEducation?: StringNullableFilter<"AggregatedJob"> | string | null
    extractedJobLevel?: StringNullableFilter<"AggregatedJob"> | string | null
    extractedKeywords?: StringNullableListFilter<"AggregatedJob">
    extractedBenefits?: StringNullableListFilter<"AggregatedJob">
    lastExtractedAt?: DateTimeNullableFilter<"AggregatedJob"> | Date | string | null
    extractionConfidence?: FloatNullableFilter<"AggregatedJob"> | number | null
    postedDate?: DateTimeFilter<"AggregatedJob"> | Date | string
    expiresAt?: DateTimeNullableFilter<"AggregatedJob"> | Date | string | null
    firstSeenAt?: DateTimeFilter<"AggregatedJob"> | Date | string
    lastChecked?: DateTimeFilter<"AggregatedJob"> | Date | string
    closedAt?: DateTimeNullableFilter<"AggregatedJob"> | Date | string | null
    isActive?: BoolFilter<"AggregatedJob"> | boolean
    createdAt?: DateTimeFilter<"AggregatedJob"> | Date | string
    updatedAt?: DateTimeNullableFilter<"AggregatedJob"> | Date | string | null
    applications?: AutoApplicationListRelationFilter
  }

  export type AggregatedJobOrderByWithRelationInput = {
    id?: SortOrder
    externalId?: SortOrder
    source?: SortOrder
    title?: SortOrder
    company?: SortOrder
    location?: SortOrderInput | SortOrder
    salary?: SortOrderInput | SortOrder
    description?: SortOrder
    requirements?: SortOrderInput | SortOrder
    applyUrl?: SortOrder
    companyUrl?: SortOrderInput | SortOrder
    atsType?: SortOrder
    atsCompany?: SortOrderInput | SortOrder
    atsComplexity?: SortOrder
    atsConfidence?: SortOrder
    aiApplyable?: SortOrder
    extractedSkills?: SortOrder
    extractedExperience?: SortOrderInput | SortOrder
    extractedEducation?: SortOrderInput | SortOrder
    extractedJobLevel?: SortOrderInput | SortOrder
    extractedKeywords?: SortOrder
    extractedBenefits?: SortOrder
    lastExtractedAt?: SortOrderInput | SortOrder
    extractionConfidence?: SortOrderInput | SortOrder
    postedDate?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    firstSeenAt?: SortOrder
    lastChecked?: SortOrder
    closedAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    applications?: AutoApplicationOrderByRelationAggregateInput
  }

  export type AggregatedJobWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    externalId?: string
    AND?: AggregatedJobWhereInput | AggregatedJobWhereInput[]
    OR?: AggregatedJobWhereInput[]
    NOT?: AggregatedJobWhereInput | AggregatedJobWhereInput[]
    source?: StringFilter<"AggregatedJob"> | string
    title?: StringFilter<"AggregatedJob"> | string
    company?: StringFilter<"AggregatedJob"> | string
    location?: StringNullableFilter<"AggregatedJob"> | string | null
    salary?: StringNullableFilter<"AggregatedJob"> | string | null
    description?: StringFilter<"AggregatedJob"> | string
    requirements?: StringNullableFilter<"AggregatedJob"> | string | null
    applyUrl?: StringFilter<"AggregatedJob"> | string
    companyUrl?: StringNullableFilter<"AggregatedJob"> | string | null
    atsType?: StringFilter<"AggregatedJob"> | string
    atsCompany?: StringNullableFilter<"AggregatedJob"> | string | null
    atsComplexity?: StringFilter<"AggregatedJob"> | string
    atsConfidence?: FloatFilter<"AggregatedJob"> | number
    aiApplyable?: BoolFilter<"AggregatedJob"> | boolean
    extractedSkills?: StringNullableListFilter<"AggregatedJob">
    extractedExperience?: StringNullableFilter<"AggregatedJob"> | string | null
    extractedEducation?: StringNullableFilter<"AggregatedJob"> | string | null
    extractedJobLevel?: StringNullableFilter<"AggregatedJob"> | string | null
    extractedKeywords?: StringNullableListFilter<"AggregatedJob">
    extractedBenefits?: StringNullableListFilter<"AggregatedJob">
    lastExtractedAt?: DateTimeNullableFilter<"AggregatedJob"> | Date | string | null
    extractionConfidence?: FloatNullableFilter<"AggregatedJob"> | number | null
    postedDate?: DateTimeFilter<"AggregatedJob"> | Date | string
    expiresAt?: DateTimeNullableFilter<"AggregatedJob"> | Date | string | null
    firstSeenAt?: DateTimeFilter<"AggregatedJob"> | Date | string
    lastChecked?: DateTimeFilter<"AggregatedJob"> | Date | string
    closedAt?: DateTimeNullableFilter<"AggregatedJob"> | Date | string | null
    isActive?: BoolFilter<"AggregatedJob"> | boolean
    createdAt?: DateTimeFilter<"AggregatedJob"> | Date | string
    updatedAt?: DateTimeNullableFilter<"AggregatedJob"> | Date | string | null
    applications?: AutoApplicationListRelationFilter
  }, "id" | "externalId">

  export type AggregatedJobOrderByWithAggregationInput = {
    id?: SortOrder
    externalId?: SortOrder
    source?: SortOrder
    title?: SortOrder
    company?: SortOrder
    location?: SortOrderInput | SortOrder
    salary?: SortOrderInput | SortOrder
    description?: SortOrder
    requirements?: SortOrderInput | SortOrder
    applyUrl?: SortOrder
    companyUrl?: SortOrderInput | SortOrder
    atsType?: SortOrder
    atsCompany?: SortOrderInput | SortOrder
    atsComplexity?: SortOrder
    atsConfidence?: SortOrder
    aiApplyable?: SortOrder
    extractedSkills?: SortOrder
    extractedExperience?: SortOrderInput | SortOrder
    extractedEducation?: SortOrderInput | SortOrder
    extractedJobLevel?: SortOrderInput | SortOrder
    extractedKeywords?: SortOrder
    extractedBenefits?: SortOrder
    lastExtractedAt?: SortOrderInput | SortOrder
    extractionConfidence?: SortOrderInput | SortOrder
    postedDate?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    firstSeenAt?: SortOrder
    lastChecked?: SortOrder
    closedAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: AggregatedJobCountOrderByAggregateInput
    _avg?: AggregatedJobAvgOrderByAggregateInput
    _max?: AggregatedJobMaxOrderByAggregateInput
    _min?: AggregatedJobMinOrderByAggregateInput
    _sum?: AggregatedJobSumOrderByAggregateInput
  }

  export type AggregatedJobScalarWhereWithAggregatesInput = {
    AND?: AggregatedJobScalarWhereWithAggregatesInput | AggregatedJobScalarWhereWithAggregatesInput[]
    OR?: AggregatedJobScalarWhereWithAggregatesInput[]
    NOT?: AggregatedJobScalarWhereWithAggregatesInput | AggregatedJobScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AggregatedJob"> | string
    externalId?: StringWithAggregatesFilter<"AggregatedJob"> | string
    source?: StringWithAggregatesFilter<"AggregatedJob"> | string
    title?: StringWithAggregatesFilter<"AggregatedJob"> | string
    company?: StringWithAggregatesFilter<"AggregatedJob"> | string
    location?: StringNullableWithAggregatesFilter<"AggregatedJob"> | string | null
    salary?: StringNullableWithAggregatesFilter<"AggregatedJob"> | string | null
    description?: StringWithAggregatesFilter<"AggregatedJob"> | string
    requirements?: StringNullableWithAggregatesFilter<"AggregatedJob"> | string | null
    applyUrl?: StringWithAggregatesFilter<"AggregatedJob"> | string
    companyUrl?: StringNullableWithAggregatesFilter<"AggregatedJob"> | string | null
    atsType?: StringWithAggregatesFilter<"AggregatedJob"> | string
    atsCompany?: StringNullableWithAggregatesFilter<"AggregatedJob"> | string | null
    atsComplexity?: StringWithAggregatesFilter<"AggregatedJob"> | string
    atsConfidence?: FloatWithAggregatesFilter<"AggregatedJob"> | number
    aiApplyable?: BoolWithAggregatesFilter<"AggregatedJob"> | boolean
    extractedSkills?: StringNullableListFilter<"AggregatedJob">
    extractedExperience?: StringNullableWithAggregatesFilter<"AggregatedJob"> | string | null
    extractedEducation?: StringNullableWithAggregatesFilter<"AggregatedJob"> | string | null
    extractedJobLevel?: StringNullableWithAggregatesFilter<"AggregatedJob"> | string | null
    extractedKeywords?: StringNullableListFilter<"AggregatedJob">
    extractedBenefits?: StringNullableListFilter<"AggregatedJob">
    lastExtractedAt?: DateTimeNullableWithAggregatesFilter<"AggregatedJob"> | Date | string | null
    extractionConfidence?: FloatNullableWithAggregatesFilter<"AggregatedJob"> | number | null
    postedDate?: DateTimeWithAggregatesFilter<"AggregatedJob"> | Date | string
    expiresAt?: DateTimeNullableWithAggregatesFilter<"AggregatedJob"> | Date | string | null
    firstSeenAt?: DateTimeWithAggregatesFilter<"AggregatedJob"> | Date | string
    lastChecked?: DateTimeWithAggregatesFilter<"AggregatedJob"> | Date | string
    closedAt?: DateTimeNullableWithAggregatesFilter<"AggregatedJob"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"AggregatedJob"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"AggregatedJob"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"AggregatedJob"> | Date | string | null
  }

  export type AutoApplicationWhereInput = {
    AND?: AutoApplicationWhereInput | AutoApplicationWhereInput[]
    OR?: AutoApplicationWhereInput[]
    NOT?: AutoApplicationWhereInput | AutoApplicationWhereInput[]
    id?: StringFilter<"AutoApplication"> | string
    userId?: IntFilter<"AutoApplication"> | number
    jobId?: StringFilter<"AutoApplication"> | string
    status?: EnumAutoApplicationStatusFilter<"AutoApplication"> | $Enums.AutoApplicationStatus
    method?: StringFilter<"AutoApplication"> | string
    submittedAt?: DateTimeNullableFilter<"AutoApplication"> | Date | string | null
    confirmationUrl?: StringNullableFilter<"AutoApplication"> | string | null
    confirmationId?: StringNullableFilter<"AutoApplication"> | string | null
    confirmationData?: JsonNullableFilter<"AutoApplication">
    error?: StringNullableFilter<"AutoApplication"> | string | null
    errorType?: StringNullableFilter<"AutoApplication"> | string | null
    retryCount?: IntFilter<"AutoApplication"> | number
    maxRetries?: IntFilter<"AutoApplication"> | number
    cost?: FloatFilter<"AutoApplication"> | number
    createdAt?: DateTimeFilter<"AutoApplication"> | Date | string
    startedAt?: DateTimeNullableFilter<"AutoApplication"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"AutoApplication"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    job?: XOR<AggregatedJobRelationFilter, AggregatedJobWhereInput>
    workerSession?: XOR<WorkerSessionNullableRelationFilter, WorkerSessionWhereInput> | null
  }

  export type AutoApplicationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    jobId?: SortOrder
    status?: SortOrder
    method?: SortOrder
    submittedAt?: SortOrderInput | SortOrder
    confirmationUrl?: SortOrderInput | SortOrder
    confirmationId?: SortOrderInput | SortOrder
    confirmationData?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    errorType?: SortOrderInput | SortOrder
    retryCount?: SortOrder
    maxRetries?: SortOrder
    cost?: SortOrder
    createdAt?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    job?: AggregatedJobOrderByWithRelationInput
    workerSession?: WorkerSessionOrderByWithRelationInput
  }

  export type AutoApplicationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_jobId?: AutoApplicationUserIdJobIdCompoundUniqueInput
    AND?: AutoApplicationWhereInput | AutoApplicationWhereInput[]
    OR?: AutoApplicationWhereInput[]
    NOT?: AutoApplicationWhereInput | AutoApplicationWhereInput[]
    userId?: IntFilter<"AutoApplication"> | number
    jobId?: StringFilter<"AutoApplication"> | string
    status?: EnumAutoApplicationStatusFilter<"AutoApplication"> | $Enums.AutoApplicationStatus
    method?: StringFilter<"AutoApplication"> | string
    submittedAt?: DateTimeNullableFilter<"AutoApplication"> | Date | string | null
    confirmationUrl?: StringNullableFilter<"AutoApplication"> | string | null
    confirmationId?: StringNullableFilter<"AutoApplication"> | string | null
    confirmationData?: JsonNullableFilter<"AutoApplication">
    error?: StringNullableFilter<"AutoApplication"> | string | null
    errorType?: StringNullableFilter<"AutoApplication"> | string | null
    retryCount?: IntFilter<"AutoApplication"> | number
    maxRetries?: IntFilter<"AutoApplication"> | number
    cost?: FloatFilter<"AutoApplication"> | number
    createdAt?: DateTimeFilter<"AutoApplication"> | Date | string
    startedAt?: DateTimeNullableFilter<"AutoApplication"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"AutoApplication"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    job?: XOR<AggregatedJobRelationFilter, AggregatedJobWhereInput>
    workerSession?: XOR<WorkerSessionNullableRelationFilter, WorkerSessionWhereInput> | null
  }, "id" | "userId_jobId">

  export type AutoApplicationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    jobId?: SortOrder
    status?: SortOrder
    method?: SortOrder
    submittedAt?: SortOrderInput | SortOrder
    confirmationUrl?: SortOrderInput | SortOrder
    confirmationId?: SortOrderInput | SortOrder
    confirmationData?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    errorType?: SortOrderInput | SortOrder
    retryCount?: SortOrder
    maxRetries?: SortOrder
    cost?: SortOrder
    createdAt?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    _count?: AutoApplicationCountOrderByAggregateInput
    _avg?: AutoApplicationAvgOrderByAggregateInput
    _max?: AutoApplicationMaxOrderByAggregateInput
    _min?: AutoApplicationMinOrderByAggregateInput
    _sum?: AutoApplicationSumOrderByAggregateInput
  }

  export type AutoApplicationScalarWhereWithAggregatesInput = {
    AND?: AutoApplicationScalarWhereWithAggregatesInput | AutoApplicationScalarWhereWithAggregatesInput[]
    OR?: AutoApplicationScalarWhereWithAggregatesInput[]
    NOT?: AutoApplicationScalarWhereWithAggregatesInput | AutoApplicationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AutoApplication"> | string
    userId?: IntWithAggregatesFilter<"AutoApplication"> | number
    jobId?: StringWithAggregatesFilter<"AutoApplication"> | string
    status?: EnumAutoApplicationStatusWithAggregatesFilter<"AutoApplication"> | $Enums.AutoApplicationStatus
    method?: StringWithAggregatesFilter<"AutoApplication"> | string
    submittedAt?: DateTimeNullableWithAggregatesFilter<"AutoApplication"> | Date | string | null
    confirmationUrl?: StringNullableWithAggregatesFilter<"AutoApplication"> | string | null
    confirmationId?: StringNullableWithAggregatesFilter<"AutoApplication"> | string | null
    confirmationData?: JsonNullableWithAggregatesFilter<"AutoApplication">
    error?: StringNullableWithAggregatesFilter<"AutoApplication"> | string | null
    errorType?: StringNullableWithAggregatesFilter<"AutoApplication"> | string | null
    retryCount?: IntWithAggregatesFilter<"AutoApplication"> | number
    maxRetries?: IntWithAggregatesFilter<"AutoApplication"> | number
    cost?: FloatWithAggregatesFilter<"AutoApplication"> | number
    createdAt?: DateTimeWithAggregatesFilter<"AutoApplication"> | Date | string
    startedAt?: DateTimeNullableWithAggregatesFilter<"AutoApplication"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"AutoApplication"> | Date | string | null
  }

  export type ApplicationRecipeWhereInput = {
    AND?: ApplicationRecipeWhereInput | ApplicationRecipeWhereInput[]
    OR?: ApplicationRecipeWhereInput[]
    NOT?: ApplicationRecipeWhereInput | ApplicationRecipeWhereInput[]
    id?: StringFilter<"ApplicationRecipe"> | string
    platform?: StringFilter<"ApplicationRecipe"> | string
    atsType?: StringFilter<"ApplicationRecipe"> | string
    version?: IntFilter<"ApplicationRecipe"> | number
    steps?: JsonFilter<"ApplicationRecipe">
    successRate?: FloatFilter<"ApplicationRecipe"> | number
    timesUsed?: IntFilter<"ApplicationRecipe"> | number
    failureCount?: IntFilter<"ApplicationRecipe"> | number
    recordingCost?: FloatFilter<"ApplicationRecipe"> | number
    replayCost?: FloatFilter<"ApplicationRecipe"> | number
    totalSaved?: FloatFilter<"ApplicationRecipe"> | number
    createdAt?: DateTimeFilter<"ApplicationRecipe"> | Date | string
    updatedAt?: DateTimeFilter<"ApplicationRecipe"> | Date | string
    lastUsed?: DateTimeNullableFilter<"ApplicationRecipe"> | Date | string | null
    lastFailure?: DateTimeNullableFilter<"ApplicationRecipe"> | Date | string | null
    recordedBy?: StringNullableFilter<"ApplicationRecipe"> | string | null
    executions?: RecipeExecutionListRelationFilter
  }

  export type ApplicationRecipeOrderByWithRelationInput = {
    id?: SortOrder
    platform?: SortOrder
    atsType?: SortOrder
    version?: SortOrder
    steps?: SortOrder
    successRate?: SortOrder
    timesUsed?: SortOrder
    failureCount?: SortOrder
    recordingCost?: SortOrder
    replayCost?: SortOrder
    totalSaved?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastUsed?: SortOrderInput | SortOrder
    lastFailure?: SortOrderInput | SortOrder
    recordedBy?: SortOrderInput | SortOrder
    executions?: RecipeExecutionOrderByRelationAggregateInput
  }

  export type ApplicationRecipeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    platform?: string
    AND?: ApplicationRecipeWhereInput | ApplicationRecipeWhereInput[]
    OR?: ApplicationRecipeWhereInput[]
    NOT?: ApplicationRecipeWhereInput | ApplicationRecipeWhereInput[]
    atsType?: StringFilter<"ApplicationRecipe"> | string
    version?: IntFilter<"ApplicationRecipe"> | number
    steps?: JsonFilter<"ApplicationRecipe">
    successRate?: FloatFilter<"ApplicationRecipe"> | number
    timesUsed?: IntFilter<"ApplicationRecipe"> | number
    failureCount?: IntFilter<"ApplicationRecipe"> | number
    recordingCost?: FloatFilter<"ApplicationRecipe"> | number
    replayCost?: FloatFilter<"ApplicationRecipe"> | number
    totalSaved?: FloatFilter<"ApplicationRecipe"> | number
    createdAt?: DateTimeFilter<"ApplicationRecipe"> | Date | string
    updatedAt?: DateTimeFilter<"ApplicationRecipe"> | Date | string
    lastUsed?: DateTimeNullableFilter<"ApplicationRecipe"> | Date | string | null
    lastFailure?: DateTimeNullableFilter<"ApplicationRecipe"> | Date | string | null
    recordedBy?: StringNullableFilter<"ApplicationRecipe"> | string | null
    executions?: RecipeExecutionListRelationFilter
  }, "id" | "platform">

  export type ApplicationRecipeOrderByWithAggregationInput = {
    id?: SortOrder
    platform?: SortOrder
    atsType?: SortOrder
    version?: SortOrder
    steps?: SortOrder
    successRate?: SortOrder
    timesUsed?: SortOrder
    failureCount?: SortOrder
    recordingCost?: SortOrder
    replayCost?: SortOrder
    totalSaved?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastUsed?: SortOrderInput | SortOrder
    lastFailure?: SortOrderInput | SortOrder
    recordedBy?: SortOrderInput | SortOrder
    _count?: ApplicationRecipeCountOrderByAggregateInput
    _avg?: ApplicationRecipeAvgOrderByAggregateInput
    _max?: ApplicationRecipeMaxOrderByAggregateInput
    _min?: ApplicationRecipeMinOrderByAggregateInput
    _sum?: ApplicationRecipeSumOrderByAggregateInput
  }

  export type ApplicationRecipeScalarWhereWithAggregatesInput = {
    AND?: ApplicationRecipeScalarWhereWithAggregatesInput | ApplicationRecipeScalarWhereWithAggregatesInput[]
    OR?: ApplicationRecipeScalarWhereWithAggregatesInput[]
    NOT?: ApplicationRecipeScalarWhereWithAggregatesInput | ApplicationRecipeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ApplicationRecipe"> | string
    platform?: StringWithAggregatesFilter<"ApplicationRecipe"> | string
    atsType?: StringWithAggregatesFilter<"ApplicationRecipe"> | string
    version?: IntWithAggregatesFilter<"ApplicationRecipe"> | number
    steps?: JsonWithAggregatesFilter<"ApplicationRecipe">
    successRate?: FloatWithAggregatesFilter<"ApplicationRecipe"> | number
    timesUsed?: IntWithAggregatesFilter<"ApplicationRecipe"> | number
    failureCount?: IntWithAggregatesFilter<"ApplicationRecipe"> | number
    recordingCost?: FloatWithAggregatesFilter<"ApplicationRecipe"> | number
    replayCost?: FloatWithAggregatesFilter<"ApplicationRecipe"> | number
    totalSaved?: FloatWithAggregatesFilter<"ApplicationRecipe"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ApplicationRecipe"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ApplicationRecipe"> | Date | string
    lastUsed?: DateTimeNullableWithAggregatesFilter<"ApplicationRecipe"> | Date | string | null
    lastFailure?: DateTimeNullableWithAggregatesFilter<"ApplicationRecipe"> | Date | string | null
    recordedBy?: StringNullableWithAggregatesFilter<"ApplicationRecipe"> | string | null
  }

  export type RecipeExecutionWhereInput = {
    AND?: RecipeExecutionWhereInput | RecipeExecutionWhereInput[]
    OR?: RecipeExecutionWhereInput[]
    NOT?: RecipeExecutionWhereInput | RecipeExecutionWhereInput[]
    id?: StringFilter<"RecipeExecution"> | string
    recipeId?: StringFilter<"RecipeExecution"> | string
    success?: BoolFilter<"RecipeExecution"> | boolean
    method?: StringFilter<"RecipeExecution"> | string
    duration?: IntNullableFilter<"RecipeExecution"> | number | null
    cost?: FloatFilter<"RecipeExecution"> | number
    error?: StringNullableFilter<"RecipeExecution"> | string | null
    errorType?: StringNullableFilter<"RecipeExecution"> | string | null
    jobUrl?: StringNullableFilter<"RecipeExecution"> | string | null
    executedAt?: DateTimeFilter<"RecipeExecution"> | Date | string
    recipe?: XOR<ApplicationRecipeRelationFilter, ApplicationRecipeWhereInput>
  }

  export type RecipeExecutionOrderByWithRelationInput = {
    id?: SortOrder
    recipeId?: SortOrder
    success?: SortOrder
    method?: SortOrder
    duration?: SortOrderInput | SortOrder
    cost?: SortOrder
    error?: SortOrderInput | SortOrder
    errorType?: SortOrderInput | SortOrder
    jobUrl?: SortOrderInput | SortOrder
    executedAt?: SortOrder
    recipe?: ApplicationRecipeOrderByWithRelationInput
  }

  export type RecipeExecutionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RecipeExecutionWhereInput | RecipeExecutionWhereInput[]
    OR?: RecipeExecutionWhereInput[]
    NOT?: RecipeExecutionWhereInput | RecipeExecutionWhereInput[]
    recipeId?: StringFilter<"RecipeExecution"> | string
    success?: BoolFilter<"RecipeExecution"> | boolean
    method?: StringFilter<"RecipeExecution"> | string
    duration?: IntNullableFilter<"RecipeExecution"> | number | null
    cost?: FloatFilter<"RecipeExecution"> | number
    error?: StringNullableFilter<"RecipeExecution"> | string | null
    errorType?: StringNullableFilter<"RecipeExecution"> | string | null
    jobUrl?: StringNullableFilter<"RecipeExecution"> | string | null
    executedAt?: DateTimeFilter<"RecipeExecution"> | Date | string
    recipe?: XOR<ApplicationRecipeRelationFilter, ApplicationRecipeWhereInput>
  }, "id">

  export type RecipeExecutionOrderByWithAggregationInput = {
    id?: SortOrder
    recipeId?: SortOrder
    success?: SortOrder
    method?: SortOrder
    duration?: SortOrderInput | SortOrder
    cost?: SortOrder
    error?: SortOrderInput | SortOrder
    errorType?: SortOrderInput | SortOrder
    jobUrl?: SortOrderInput | SortOrder
    executedAt?: SortOrder
    _count?: RecipeExecutionCountOrderByAggregateInput
    _avg?: RecipeExecutionAvgOrderByAggregateInput
    _max?: RecipeExecutionMaxOrderByAggregateInput
    _min?: RecipeExecutionMinOrderByAggregateInput
    _sum?: RecipeExecutionSumOrderByAggregateInput
  }

  export type RecipeExecutionScalarWhereWithAggregatesInput = {
    AND?: RecipeExecutionScalarWhereWithAggregatesInput | RecipeExecutionScalarWhereWithAggregatesInput[]
    OR?: RecipeExecutionScalarWhereWithAggregatesInput[]
    NOT?: RecipeExecutionScalarWhereWithAggregatesInput | RecipeExecutionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RecipeExecution"> | string
    recipeId?: StringWithAggregatesFilter<"RecipeExecution"> | string
    success?: BoolWithAggregatesFilter<"RecipeExecution"> | boolean
    method?: StringWithAggregatesFilter<"RecipeExecution"> | string
    duration?: IntNullableWithAggregatesFilter<"RecipeExecution"> | number | null
    cost?: FloatWithAggregatesFilter<"RecipeExecution"> | number
    error?: StringNullableWithAggregatesFilter<"RecipeExecution"> | string | null
    errorType?: StringNullableWithAggregatesFilter<"RecipeExecution"> | string | null
    jobUrl?: StringNullableWithAggregatesFilter<"RecipeExecution"> | string | null
    executedAt?: DateTimeWithAggregatesFilter<"RecipeExecution"> | Date | string
  }

  export type DiscoveredCompanyWhereInput = {
    AND?: DiscoveredCompanyWhereInput | DiscoveredCompanyWhereInput[]
    OR?: DiscoveredCompanyWhereInput[]
    NOT?: DiscoveredCompanyWhereInput | DiscoveredCompanyWhereInput[]
    id?: StringFilter<"DiscoveredCompany"> | string
    atsType?: StringFilter<"DiscoveredCompany"> | string
    slug?: StringFilter<"DiscoveredCompany"> | string
    name?: StringNullableFilter<"DiscoveredCompany"> | string | null
    discoveredAt?: DateTimeFilter<"DiscoveredCompany"> | Date | string
    discoveredFrom?: StringNullableFilter<"DiscoveredCompany"> | string | null
    lastFetchedAt?: DateTimeFilter<"DiscoveredCompany"> | Date | string
    isActive?: BoolFilter<"DiscoveredCompany"> | boolean
    totalJobs?: IntFilter<"DiscoveredCompany"> | number
    lastJobCount?: IntFilter<"DiscoveredCompany"> | number
  }

  export type DiscoveredCompanyOrderByWithRelationInput = {
    id?: SortOrder
    atsType?: SortOrder
    slug?: SortOrder
    name?: SortOrderInput | SortOrder
    discoveredAt?: SortOrder
    discoveredFrom?: SortOrderInput | SortOrder
    lastFetchedAt?: SortOrder
    isActive?: SortOrder
    totalJobs?: SortOrder
    lastJobCount?: SortOrder
  }

  export type DiscoveredCompanyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    atsType_slug?: DiscoveredCompanyAtsTypeSlugCompoundUniqueInput
    AND?: DiscoveredCompanyWhereInput | DiscoveredCompanyWhereInput[]
    OR?: DiscoveredCompanyWhereInput[]
    NOT?: DiscoveredCompanyWhereInput | DiscoveredCompanyWhereInput[]
    atsType?: StringFilter<"DiscoveredCompany"> | string
    slug?: StringFilter<"DiscoveredCompany"> | string
    name?: StringNullableFilter<"DiscoveredCompany"> | string | null
    discoveredAt?: DateTimeFilter<"DiscoveredCompany"> | Date | string
    discoveredFrom?: StringNullableFilter<"DiscoveredCompany"> | string | null
    lastFetchedAt?: DateTimeFilter<"DiscoveredCompany"> | Date | string
    isActive?: BoolFilter<"DiscoveredCompany"> | boolean
    totalJobs?: IntFilter<"DiscoveredCompany"> | number
    lastJobCount?: IntFilter<"DiscoveredCompany"> | number
  }, "id" | "atsType_slug">

  export type DiscoveredCompanyOrderByWithAggregationInput = {
    id?: SortOrder
    atsType?: SortOrder
    slug?: SortOrder
    name?: SortOrderInput | SortOrder
    discoveredAt?: SortOrder
    discoveredFrom?: SortOrderInput | SortOrder
    lastFetchedAt?: SortOrder
    isActive?: SortOrder
    totalJobs?: SortOrder
    lastJobCount?: SortOrder
    _count?: DiscoveredCompanyCountOrderByAggregateInput
    _avg?: DiscoveredCompanyAvgOrderByAggregateInput
    _max?: DiscoveredCompanyMaxOrderByAggregateInput
    _min?: DiscoveredCompanyMinOrderByAggregateInput
    _sum?: DiscoveredCompanySumOrderByAggregateInput
  }

  export type DiscoveredCompanyScalarWhereWithAggregatesInput = {
    AND?: DiscoveredCompanyScalarWhereWithAggregatesInput | DiscoveredCompanyScalarWhereWithAggregatesInput[]
    OR?: DiscoveredCompanyScalarWhereWithAggregatesInput[]
    NOT?: DiscoveredCompanyScalarWhereWithAggregatesInput | DiscoveredCompanyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DiscoveredCompany"> | string
    atsType?: StringWithAggregatesFilter<"DiscoveredCompany"> | string
    slug?: StringWithAggregatesFilter<"DiscoveredCompany"> | string
    name?: StringNullableWithAggregatesFilter<"DiscoveredCompany"> | string | null
    discoveredAt?: DateTimeWithAggregatesFilter<"DiscoveredCompany"> | Date | string
    discoveredFrom?: StringNullableWithAggregatesFilter<"DiscoveredCompany"> | string | null
    lastFetchedAt?: DateTimeWithAggregatesFilter<"DiscoveredCompany"> | Date | string
    isActive?: BoolWithAggregatesFilter<"DiscoveredCompany"> | boolean
    totalJobs?: IntWithAggregatesFilter<"DiscoveredCompany"> | number
    lastJobCount?: IntWithAggregatesFilter<"DiscoveredCompany"> | number
  }

  export type ConversationWhereInput = {
    AND?: ConversationWhereInput | ConversationWhereInput[]
    OR?: ConversationWhereInput[]
    NOT?: ConversationWhereInput | ConversationWhereInput[]
    id?: StringFilter<"Conversation"> | string
    userId?: IntNullableFilter<"Conversation"> | number | null
    title?: StringNullableFilter<"Conversation"> | string | null
    createdAt?: DateTimeFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeFilter<"Conversation"> | Date | string
    lastMessageAt?: DateTimeFilter<"Conversation"> | Date | string
    messages?: MessageListRelationFilter
    goals?: GoalListRelationFilter
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type ConversationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastMessageAt?: SortOrder
    messages?: MessageOrderByRelationAggregateInput
    goals?: GoalOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
  }

  export type ConversationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ConversationWhereInput | ConversationWhereInput[]
    OR?: ConversationWhereInput[]
    NOT?: ConversationWhereInput | ConversationWhereInput[]
    userId?: IntNullableFilter<"Conversation"> | number | null
    title?: StringNullableFilter<"Conversation"> | string | null
    createdAt?: DateTimeFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeFilter<"Conversation"> | Date | string
    lastMessageAt?: DateTimeFilter<"Conversation"> | Date | string
    messages?: MessageListRelationFilter
    goals?: GoalListRelationFilter
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type ConversationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastMessageAt?: SortOrder
    _count?: ConversationCountOrderByAggregateInput
    _avg?: ConversationAvgOrderByAggregateInput
    _max?: ConversationMaxOrderByAggregateInput
    _min?: ConversationMinOrderByAggregateInput
    _sum?: ConversationSumOrderByAggregateInput
  }

  export type ConversationScalarWhereWithAggregatesInput = {
    AND?: ConversationScalarWhereWithAggregatesInput | ConversationScalarWhereWithAggregatesInput[]
    OR?: ConversationScalarWhereWithAggregatesInput[]
    NOT?: ConversationScalarWhereWithAggregatesInput | ConversationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Conversation"> | string
    userId?: IntNullableWithAggregatesFilter<"Conversation"> | number | null
    title?: StringNullableWithAggregatesFilter<"Conversation"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Conversation"> | Date | string
    lastMessageAt?: DateTimeWithAggregatesFilter<"Conversation"> | Date | string
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: StringFilter<"Message"> | string
    conversationId?: StringFilter<"Message"> | string
    role?: EnumMessageRoleFilter<"Message"> | $Enums.MessageRole
    content?: StringFilter<"Message"> | string
    metadata?: JsonNullableFilter<"Message">
    tokenCount?: IntNullableFilter<"Message"> | number | null
    cost?: FloatNullableFilter<"Message"> | number | null
    createdAt?: DateTimeFilter<"Message"> | Date | string
    conversation?: XOR<ConversationRelationFilter, ConversationWhereInput>
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    metadata?: SortOrderInput | SortOrder
    tokenCount?: SortOrderInput | SortOrder
    cost?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    conversation?: ConversationOrderByWithRelationInput
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    conversationId?: StringFilter<"Message"> | string
    role?: EnumMessageRoleFilter<"Message"> | $Enums.MessageRole
    content?: StringFilter<"Message"> | string
    metadata?: JsonNullableFilter<"Message">
    tokenCount?: IntNullableFilter<"Message"> | number | null
    cost?: FloatNullableFilter<"Message"> | number | null
    createdAt?: DateTimeFilter<"Message"> | Date | string
    conversation?: XOR<ConversationRelationFilter, ConversationWhereInput>
  }, "id">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    metadata?: SortOrderInput | SortOrder
    tokenCount?: SortOrderInput | SortOrder
    cost?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: MessageCountOrderByAggregateInput
    _avg?: MessageAvgOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
    _sum?: MessageSumOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Message"> | string
    conversationId?: StringWithAggregatesFilter<"Message"> | string
    role?: EnumMessageRoleWithAggregatesFilter<"Message"> | $Enums.MessageRole
    content?: StringWithAggregatesFilter<"Message"> | string
    metadata?: JsonNullableWithAggregatesFilter<"Message">
    tokenCount?: IntNullableWithAggregatesFilter<"Message"> | number | null
    cost?: FloatNullableWithAggregatesFilter<"Message"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
  }

  export type GoalWhereInput = {
    AND?: GoalWhereInput | GoalWhereInput[]
    OR?: GoalWhereInput[]
    NOT?: GoalWhereInput | GoalWhereInput[]
    id?: StringFilter<"Goal"> | string
    conversationId?: StringNullableFilter<"Goal"> | string | null
    userId?: IntFilter<"Goal"> | number
    title?: StringFilter<"Goal"> | string
    description?: StringNullableFilter<"Goal"> | string | null
    type?: EnumGoalTypeFilter<"Goal"> | $Enums.GoalType
    status?: EnumGoalStatusFilter<"Goal"> | $Enums.GoalStatus
    targetDate?: DateTimeNullableFilter<"Goal"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Goal"> | Date | string | null
    createdAt?: DateTimeFilter<"Goal"> | Date | string
    updatedAt?: DateTimeFilter<"Goal"> | Date | string
    metadata?: JsonNullableFilter<"Goal">
    conversation?: XOR<ConversationNullableRelationFilter, ConversationWhereInput> | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type GoalOrderByWithRelationInput = {
    id?: SortOrder
    conversationId?: SortOrderInput | SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    status?: SortOrder
    targetDate?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    metadata?: SortOrderInput | SortOrder
    conversation?: ConversationOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type GoalWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GoalWhereInput | GoalWhereInput[]
    OR?: GoalWhereInput[]
    NOT?: GoalWhereInput | GoalWhereInput[]
    conversationId?: StringNullableFilter<"Goal"> | string | null
    userId?: IntFilter<"Goal"> | number
    title?: StringFilter<"Goal"> | string
    description?: StringNullableFilter<"Goal"> | string | null
    type?: EnumGoalTypeFilter<"Goal"> | $Enums.GoalType
    status?: EnumGoalStatusFilter<"Goal"> | $Enums.GoalStatus
    targetDate?: DateTimeNullableFilter<"Goal"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Goal"> | Date | string | null
    createdAt?: DateTimeFilter<"Goal"> | Date | string
    updatedAt?: DateTimeFilter<"Goal"> | Date | string
    metadata?: JsonNullableFilter<"Goal">
    conversation?: XOR<ConversationNullableRelationFilter, ConversationWhereInput> | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type GoalOrderByWithAggregationInput = {
    id?: SortOrder
    conversationId?: SortOrderInput | SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    status?: SortOrder
    targetDate?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: GoalCountOrderByAggregateInput
    _avg?: GoalAvgOrderByAggregateInput
    _max?: GoalMaxOrderByAggregateInput
    _min?: GoalMinOrderByAggregateInput
    _sum?: GoalSumOrderByAggregateInput
  }

  export type GoalScalarWhereWithAggregatesInput = {
    AND?: GoalScalarWhereWithAggregatesInput | GoalScalarWhereWithAggregatesInput[]
    OR?: GoalScalarWhereWithAggregatesInput[]
    NOT?: GoalScalarWhereWithAggregatesInput | GoalScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Goal"> | string
    conversationId?: StringNullableWithAggregatesFilter<"Goal"> | string | null
    userId?: IntWithAggregatesFilter<"Goal"> | number
    title?: StringWithAggregatesFilter<"Goal"> | string
    description?: StringNullableWithAggregatesFilter<"Goal"> | string | null
    type?: EnumGoalTypeWithAggregatesFilter<"Goal"> | $Enums.GoalType
    status?: EnumGoalStatusWithAggregatesFilter<"Goal"> | $Enums.GoalStatus
    targetDate?: DateTimeNullableWithAggregatesFilter<"Goal"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"Goal"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Goal"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Goal"> | Date | string
    metadata?: JsonNullableWithAggregatesFilter<"Goal">
  }

  export type MessageUsageWhereInput = {
    AND?: MessageUsageWhereInput | MessageUsageWhereInput[]
    OR?: MessageUsageWhereInput[]
    NOT?: MessageUsageWhereInput | MessageUsageWhereInput[]
    id?: StringFilter<"MessageUsage"> | string
    userId?: IntNullableFilter<"MessageUsage"> | number | null
    ip?: StringNullableFilter<"MessageUsage"> | string | null
    date?: DateTimeFilter<"MessageUsage"> | Date | string
    count?: IntFilter<"MessageUsage"> | number
    resetAt?: DateTimeFilter<"MessageUsage"> | Date | string
    createdAt?: DateTimeFilter<"MessageUsage"> | Date | string
    updatedAt?: DateTimeFilter<"MessageUsage"> | Date | string
  }

  export type MessageUsageOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    ip?: SortOrderInput | SortOrder
    date?: SortOrder
    count?: SortOrder
    resetAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessageUsageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_date?: MessageUsageUserIdDateCompoundUniqueInput
    ip_date?: MessageUsageIpDateCompoundUniqueInput
    AND?: MessageUsageWhereInput | MessageUsageWhereInput[]
    OR?: MessageUsageWhereInput[]
    NOT?: MessageUsageWhereInput | MessageUsageWhereInput[]
    userId?: IntNullableFilter<"MessageUsage"> | number | null
    ip?: StringNullableFilter<"MessageUsage"> | string | null
    date?: DateTimeFilter<"MessageUsage"> | Date | string
    count?: IntFilter<"MessageUsage"> | number
    resetAt?: DateTimeFilter<"MessageUsage"> | Date | string
    createdAt?: DateTimeFilter<"MessageUsage"> | Date | string
    updatedAt?: DateTimeFilter<"MessageUsage"> | Date | string
  }, "id" | "userId_date" | "ip_date">

  export type MessageUsageOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    ip?: SortOrderInput | SortOrder
    date?: SortOrder
    count?: SortOrder
    resetAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MessageUsageCountOrderByAggregateInput
    _avg?: MessageUsageAvgOrderByAggregateInput
    _max?: MessageUsageMaxOrderByAggregateInput
    _min?: MessageUsageMinOrderByAggregateInput
    _sum?: MessageUsageSumOrderByAggregateInput
  }

  export type MessageUsageScalarWhereWithAggregatesInput = {
    AND?: MessageUsageScalarWhereWithAggregatesInput | MessageUsageScalarWhereWithAggregatesInput[]
    OR?: MessageUsageScalarWhereWithAggregatesInput[]
    NOT?: MessageUsageScalarWhereWithAggregatesInput | MessageUsageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MessageUsage"> | string
    userId?: IntNullableWithAggregatesFilter<"MessageUsage"> | number | null
    ip?: StringNullableWithAggregatesFilter<"MessageUsage"> | string | null
    date?: DateTimeWithAggregatesFilter<"MessageUsage"> | Date | string
    count?: IntWithAggregatesFilter<"MessageUsage"> | number
    resetAt?: DateTimeWithAggregatesFilter<"MessageUsage"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"MessageUsage"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MessageUsage"> | Date | string
  }

  export type RoutineWhereInput = {
    AND?: RoutineWhereInput | RoutineWhereInput[]
    OR?: RoutineWhereInput[]
    NOT?: RoutineWhereInput | RoutineWhereInput[]
    id?: StringFilter<"Routine"> | string
    userId?: IntFilter<"Routine"> | number
    title?: StringFilter<"Routine"> | string
    description?: StringNullableFilter<"Routine"> | string | null
    type?: EnumRoutineTypeFilter<"Routine"> | $Enums.RoutineType
    frequency?: StringFilter<"Routine"> | string
    schedule?: StringFilter<"Routine"> | string
    config?: JsonNullableFilter<"Routine">
    isActive?: BoolFilter<"Routine"> | boolean
    lastRun?: DateTimeNullableFilter<"Routine"> | Date | string | null
    nextRun?: DateTimeNullableFilter<"Routine"> | Date | string | null
    runCount?: IntFilter<"Routine"> | number
    createdAt?: DateTimeFilter<"Routine"> | Date | string
    updatedAt?: DateTimeFilter<"Routine"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    executions?: RoutineExecutionListRelationFilter
  }

  export type RoutineOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    frequency?: SortOrder
    schedule?: SortOrder
    config?: SortOrderInput | SortOrder
    isActive?: SortOrder
    lastRun?: SortOrderInput | SortOrder
    nextRun?: SortOrderInput | SortOrder
    runCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    executions?: RoutineExecutionOrderByRelationAggregateInput
  }

  export type RoutineWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RoutineWhereInput | RoutineWhereInput[]
    OR?: RoutineWhereInput[]
    NOT?: RoutineWhereInput | RoutineWhereInput[]
    userId?: IntFilter<"Routine"> | number
    title?: StringFilter<"Routine"> | string
    description?: StringNullableFilter<"Routine"> | string | null
    type?: EnumRoutineTypeFilter<"Routine"> | $Enums.RoutineType
    frequency?: StringFilter<"Routine"> | string
    schedule?: StringFilter<"Routine"> | string
    config?: JsonNullableFilter<"Routine">
    isActive?: BoolFilter<"Routine"> | boolean
    lastRun?: DateTimeNullableFilter<"Routine"> | Date | string | null
    nextRun?: DateTimeNullableFilter<"Routine"> | Date | string | null
    runCount?: IntFilter<"Routine"> | number
    createdAt?: DateTimeFilter<"Routine"> | Date | string
    updatedAt?: DateTimeFilter<"Routine"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    executions?: RoutineExecutionListRelationFilter
  }, "id">

  export type RoutineOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    frequency?: SortOrder
    schedule?: SortOrder
    config?: SortOrderInput | SortOrder
    isActive?: SortOrder
    lastRun?: SortOrderInput | SortOrder
    nextRun?: SortOrderInput | SortOrder
    runCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RoutineCountOrderByAggregateInput
    _avg?: RoutineAvgOrderByAggregateInput
    _max?: RoutineMaxOrderByAggregateInput
    _min?: RoutineMinOrderByAggregateInput
    _sum?: RoutineSumOrderByAggregateInput
  }

  export type RoutineScalarWhereWithAggregatesInput = {
    AND?: RoutineScalarWhereWithAggregatesInput | RoutineScalarWhereWithAggregatesInput[]
    OR?: RoutineScalarWhereWithAggregatesInput[]
    NOT?: RoutineScalarWhereWithAggregatesInput | RoutineScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Routine"> | string
    userId?: IntWithAggregatesFilter<"Routine"> | number
    title?: StringWithAggregatesFilter<"Routine"> | string
    description?: StringNullableWithAggregatesFilter<"Routine"> | string | null
    type?: EnumRoutineTypeWithAggregatesFilter<"Routine"> | $Enums.RoutineType
    frequency?: StringWithAggregatesFilter<"Routine"> | string
    schedule?: StringWithAggregatesFilter<"Routine"> | string
    config?: JsonNullableWithAggregatesFilter<"Routine">
    isActive?: BoolWithAggregatesFilter<"Routine"> | boolean
    lastRun?: DateTimeNullableWithAggregatesFilter<"Routine"> | Date | string | null
    nextRun?: DateTimeNullableWithAggregatesFilter<"Routine"> | Date | string | null
    runCount?: IntWithAggregatesFilter<"Routine"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Routine"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Routine"> | Date | string
  }

  export type RoutineExecutionWhereInput = {
    AND?: RoutineExecutionWhereInput | RoutineExecutionWhereInput[]
    OR?: RoutineExecutionWhereInput[]
    NOT?: RoutineExecutionWhereInput | RoutineExecutionWhereInput[]
    id?: StringFilter<"RoutineExecution"> | string
    routineId?: StringFilter<"RoutineExecution"> | string
    status?: StringFilter<"RoutineExecution"> | string
    summary?: StringNullableFilter<"RoutineExecution"> | string | null
    results?: JsonNullableFilter<"RoutineExecution">
    duration?: IntNullableFilter<"RoutineExecution"> | number | null
    error?: StringNullableFilter<"RoutineExecution"> | string | null
    createdAt?: DateTimeFilter<"RoutineExecution"> | Date | string
    routine?: XOR<RoutineRelationFilter, RoutineWhereInput>
  }

  export type RoutineExecutionOrderByWithRelationInput = {
    id?: SortOrder
    routineId?: SortOrder
    status?: SortOrder
    summary?: SortOrderInput | SortOrder
    results?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    routine?: RoutineOrderByWithRelationInput
  }

  export type RoutineExecutionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RoutineExecutionWhereInput | RoutineExecutionWhereInput[]
    OR?: RoutineExecutionWhereInput[]
    NOT?: RoutineExecutionWhereInput | RoutineExecutionWhereInput[]
    routineId?: StringFilter<"RoutineExecution"> | string
    status?: StringFilter<"RoutineExecution"> | string
    summary?: StringNullableFilter<"RoutineExecution"> | string | null
    results?: JsonNullableFilter<"RoutineExecution">
    duration?: IntNullableFilter<"RoutineExecution"> | number | null
    error?: StringNullableFilter<"RoutineExecution"> | string | null
    createdAt?: DateTimeFilter<"RoutineExecution"> | Date | string
    routine?: XOR<RoutineRelationFilter, RoutineWhereInput>
  }, "id">

  export type RoutineExecutionOrderByWithAggregationInput = {
    id?: SortOrder
    routineId?: SortOrder
    status?: SortOrder
    summary?: SortOrderInput | SortOrder
    results?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: RoutineExecutionCountOrderByAggregateInput
    _avg?: RoutineExecutionAvgOrderByAggregateInput
    _max?: RoutineExecutionMaxOrderByAggregateInput
    _min?: RoutineExecutionMinOrderByAggregateInput
    _sum?: RoutineExecutionSumOrderByAggregateInput
  }

  export type RoutineExecutionScalarWhereWithAggregatesInput = {
    AND?: RoutineExecutionScalarWhereWithAggregatesInput | RoutineExecutionScalarWhereWithAggregatesInput[]
    OR?: RoutineExecutionScalarWhereWithAggregatesInput[]
    NOT?: RoutineExecutionScalarWhereWithAggregatesInput | RoutineExecutionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RoutineExecution"> | string
    routineId?: StringWithAggregatesFilter<"RoutineExecution"> | string
    status?: StringWithAggregatesFilter<"RoutineExecution"> | string
    summary?: StringNullableWithAggregatesFilter<"RoutineExecution"> | string | null
    results?: JsonNullableWithAggregatesFilter<"RoutineExecution">
    duration?: IntNullableWithAggregatesFilter<"RoutineExecution"> | number | null
    error?: StringNullableWithAggregatesFilter<"RoutineExecution"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"RoutineExecution"> | Date | string
  }

  export type WorkerWhereInput = {
    AND?: WorkerWhereInput | WorkerWhereInput[]
    OR?: WorkerWhereInput[]
    NOT?: WorkerWhereInput | WorkerWhereInput[]
    id?: IntFilter<"Worker"> | number
    email?: StringFilter<"Worker"> | string
    password?: StringFilter<"Worker"> | string
    name?: StringFilter<"Worker"> | string
    isActive?: BoolFilter<"Worker"> | boolean
    role?: EnumWorkerRoleFilter<"Worker"> | $Enums.WorkerRole
    totalCompleted?: IntFilter<"Worker"> | number
    totalFailed?: IntFilter<"Worker"> | number
    totalSkipped?: IntFilter<"Worker"> | number
    avgTimeSeconds?: IntNullableFilter<"Worker"> | number | null
    lastActiveAt?: DateTimeNullableFilter<"Worker"> | Date | string | null
    currentSessionId?: StringNullableFilter<"Worker"> | string | null
    createdAt?: DateTimeFilter<"Worker"> | Date | string
    updatedAt?: DateTimeFilter<"Worker"> | Date | string
    sessions?: WorkerSessionListRelationFilter
  }

  export type WorkerOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    role?: SortOrder
    totalCompleted?: SortOrder
    totalFailed?: SortOrder
    totalSkipped?: SortOrder
    avgTimeSeconds?: SortOrderInput | SortOrder
    lastActiveAt?: SortOrderInput | SortOrder
    currentSessionId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sessions?: WorkerSessionOrderByRelationAggregateInput
  }

  export type WorkerWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: WorkerWhereInput | WorkerWhereInput[]
    OR?: WorkerWhereInput[]
    NOT?: WorkerWhereInput | WorkerWhereInput[]
    password?: StringFilter<"Worker"> | string
    name?: StringFilter<"Worker"> | string
    isActive?: BoolFilter<"Worker"> | boolean
    role?: EnumWorkerRoleFilter<"Worker"> | $Enums.WorkerRole
    totalCompleted?: IntFilter<"Worker"> | number
    totalFailed?: IntFilter<"Worker"> | number
    totalSkipped?: IntFilter<"Worker"> | number
    avgTimeSeconds?: IntNullableFilter<"Worker"> | number | null
    lastActiveAt?: DateTimeNullableFilter<"Worker"> | Date | string | null
    currentSessionId?: StringNullableFilter<"Worker"> | string | null
    createdAt?: DateTimeFilter<"Worker"> | Date | string
    updatedAt?: DateTimeFilter<"Worker"> | Date | string
    sessions?: WorkerSessionListRelationFilter
  }, "id" | "email">

  export type WorkerOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    role?: SortOrder
    totalCompleted?: SortOrder
    totalFailed?: SortOrder
    totalSkipped?: SortOrder
    avgTimeSeconds?: SortOrderInput | SortOrder
    lastActiveAt?: SortOrderInput | SortOrder
    currentSessionId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WorkerCountOrderByAggregateInput
    _avg?: WorkerAvgOrderByAggregateInput
    _max?: WorkerMaxOrderByAggregateInput
    _min?: WorkerMinOrderByAggregateInput
    _sum?: WorkerSumOrderByAggregateInput
  }

  export type WorkerScalarWhereWithAggregatesInput = {
    AND?: WorkerScalarWhereWithAggregatesInput | WorkerScalarWhereWithAggregatesInput[]
    OR?: WorkerScalarWhereWithAggregatesInput[]
    NOT?: WorkerScalarWhereWithAggregatesInput | WorkerScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Worker"> | number
    email?: StringWithAggregatesFilter<"Worker"> | string
    password?: StringWithAggregatesFilter<"Worker"> | string
    name?: StringWithAggregatesFilter<"Worker"> | string
    isActive?: BoolWithAggregatesFilter<"Worker"> | boolean
    role?: EnumWorkerRoleWithAggregatesFilter<"Worker"> | $Enums.WorkerRole
    totalCompleted?: IntWithAggregatesFilter<"Worker"> | number
    totalFailed?: IntWithAggregatesFilter<"Worker"> | number
    totalSkipped?: IntWithAggregatesFilter<"Worker"> | number
    avgTimeSeconds?: IntNullableWithAggregatesFilter<"Worker"> | number | null
    lastActiveAt?: DateTimeNullableWithAggregatesFilter<"Worker"> | Date | string | null
    currentSessionId?: StringNullableWithAggregatesFilter<"Worker"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Worker"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Worker"> | Date | string
  }

  export type WorkerSessionWhereInput = {
    AND?: WorkerSessionWhereInput | WorkerSessionWhereInput[]
    OR?: WorkerSessionWhereInput[]
    NOT?: WorkerSessionWhereInput | WorkerSessionWhereInput[]
    id?: StringFilter<"WorkerSession"> | string
    workerId?: IntNullableFilter<"WorkerSession"> | number | null
    autoApplicationId?: StringFilter<"WorkerSession"> | string
    status?: EnumWorkerSessionStatusFilter<"WorkerSession"> | $Enums.WorkerSessionStatus
    browserSessionId?: StringNullableFilter<"WorkerSession"> | string | null
    vncUrl?: StringNullableFilter<"WorkerSession"> | string | null
    queuedAt?: DateTimeFilter<"WorkerSession"> | Date | string
    assignedAt?: DateTimeNullableFilter<"WorkerSession"> | Date | string | null
    aiStartedAt?: DateTimeNullableFilter<"WorkerSession"> | Date | string | null
    aiCompletedAt?: DateTimeNullableFilter<"WorkerSession"> | Date | string | null
    submittedAt?: DateTimeNullableFilter<"WorkerSession"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"WorkerSession"> | Date | string | null
    formData?: JsonNullableFilter<"WorkerSession">
    screenshotUrl?: StringNullableFilter<"WorkerSession"> | string | null
    workerNotes?: StringNullableFilter<"WorkerSession"> | string | null
    failReason?: StringNullableFilter<"WorkerSession"> | string | null
    skipReason?: StringNullableFilter<"WorkerSession"> | string | null
    worker?: XOR<WorkerNullableRelationFilter, WorkerWhereInput> | null
    autoApplication?: XOR<AutoApplicationRelationFilter, AutoApplicationWhereInput>
  }

  export type WorkerSessionOrderByWithRelationInput = {
    id?: SortOrder
    workerId?: SortOrderInput | SortOrder
    autoApplicationId?: SortOrder
    status?: SortOrder
    browserSessionId?: SortOrderInput | SortOrder
    vncUrl?: SortOrderInput | SortOrder
    queuedAt?: SortOrder
    assignedAt?: SortOrderInput | SortOrder
    aiStartedAt?: SortOrderInput | SortOrder
    aiCompletedAt?: SortOrderInput | SortOrder
    submittedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    formData?: SortOrderInput | SortOrder
    screenshotUrl?: SortOrderInput | SortOrder
    workerNotes?: SortOrderInput | SortOrder
    failReason?: SortOrderInput | SortOrder
    skipReason?: SortOrderInput | SortOrder
    worker?: WorkerOrderByWithRelationInput
    autoApplication?: AutoApplicationOrderByWithRelationInput
  }

  export type WorkerSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    autoApplicationId?: string
    AND?: WorkerSessionWhereInput | WorkerSessionWhereInput[]
    OR?: WorkerSessionWhereInput[]
    NOT?: WorkerSessionWhereInput | WorkerSessionWhereInput[]
    workerId?: IntNullableFilter<"WorkerSession"> | number | null
    status?: EnumWorkerSessionStatusFilter<"WorkerSession"> | $Enums.WorkerSessionStatus
    browserSessionId?: StringNullableFilter<"WorkerSession"> | string | null
    vncUrl?: StringNullableFilter<"WorkerSession"> | string | null
    queuedAt?: DateTimeFilter<"WorkerSession"> | Date | string
    assignedAt?: DateTimeNullableFilter<"WorkerSession"> | Date | string | null
    aiStartedAt?: DateTimeNullableFilter<"WorkerSession"> | Date | string | null
    aiCompletedAt?: DateTimeNullableFilter<"WorkerSession"> | Date | string | null
    submittedAt?: DateTimeNullableFilter<"WorkerSession"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"WorkerSession"> | Date | string | null
    formData?: JsonNullableFilter<"WorkerSession">
    screenshotUrl?: StringNullableFilter<"WorkerSession"> | string | null
    workerNotes?: StringNullableFilter<"WorkerSession"> | string | null
    failReason?: StringNullableFilter<"WorkerSession"> | string | null
    skipReason?: StringNullableFilter<"WorkerSession"> | string | null
    worker?: XOR<WorkerNullableRelationFilter, WorkerWhereInput> | null
    autoApplication?: XOR<AutoApplicationRelationFilter, AutoApplicationWhereInput>
  }, "id" | "autoApplicationId">

  export type WorkerSessionOrderByWithAggregationInput = {
    id?: SortOrder
    workerId?: SortOrderInput | SortOrder
    autoApplicationId?: SortOrder
    status?: SortOrder
    browserSessionId?: SortOrderInput | SortOrder
    vncUrl?: SortOrderInput | SortOrder
    queuedAt?: SortOrder
    assignedAt?: SortOrderInput | SortOrder
    aiStartedAt?: SortOrderInput | SortOrder
    aiCompletedAt?: SortOrderInput | SortOrder
    submittedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    formData?: SortOrderInput | SortOrder
    screenshotUrl?: SortOrderInput | SortOrder
    workerNotes?: SortOrderInput | SortOrder
    failReason?: SortOrderInput | SortOrder
    skipReason?: SortOrderInput | SortOrder
    _count?: WorkerSessionCountOrderByAggregateInput
    _avg?: WorkerSessionAvgOrderByAggregateInput
    _max?: WorkerSessionMaxOrderByAggregateInput
    _min?: WorkerSessionMinOrderByAggregateInput
    _sum?: WorkerSessionSumOrderByAggregateInput
  }

  export type WorkerSessionScalarWhereWithAggregatesInput = {
    AND?: WorkerSessionScalarWhereWithAggregatesInput | WorkerSessionScalarWhereWithAggregatesInput[]
    OR?: WorkerSessionScalarWhereWithAggregatesInput[]
    NOT?: WorkerSessionScalarWhereWithAggregatesInput | WorkerSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WorkerSession"> | string
    workerId?: IntNullableWithAggregatesFilter<"WorkerSession"> | number | null
    autoApplicationId?: StringWithAggregatesFilter<"WorkerSession"> | string
    status?: EnumWorkerSessionStatusWithAggregatesFilter<"WorkerSession"> | $Enums.WorkerSessionStatus
    browserSessionId?: StringNullableWithAggregatesFilter<"WorkerSession"> | string | null
    vncUrl?: StringNullableWithAggregatesFilter<"WorkerSession"> | string | null
    queuedAt?: DateTimeWithAggregatesFilter<"WorkerSession"> | Date | string
    assignedAt?: DateTimeNullableWithAggregatesFilter<"WorkerSession"> | Date | string | null
    aiStartedAt?: DateTimeNullableWithAggregatesFilter<"WorkerSession"> | Date | string | null
    aiCompletedAt?: DateTimeNullableWithAggregatesFilter<"WorkerSession"> | Date | string | null
    submittedAt?: DateTimeNullableWithAggregatesFilter<"WorkerSession"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"WorkerSession"> | Date | string | null
    formData?: JsonNullableWithAggregatesFilter<"WorkerSession">
    screenshotUrl?: StringNullableWithAggregatesFilter<"WorkerSession"> | string | null
    workerNotes?: StringNullableWithAggregatesFilter<"WorkerSession"> | string | null
    failReason?: StringNullableWithAggregatesFilter<"WorkerSession"> | string | null
    skipReason?: StringNullableWithAggregatesFilter<"WorkerSession"> | string | null
  }

  export type UserCreateInput = {
    email: string
    password: string
    clerkId?: string | null
    createdAt?: Date | string
    jobs?: JobCreateNestedManyWithoutUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    usageTracking?: UsageTrackingCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    autoApplications?: AutoApplicationCreateNestedManyWithoutUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    goals?: GoalCreateNestedManyWithoutUserInput
    routines?: RoutineCreateNestedManyWithoutUserInput
    gmailConnection?: GmailConnectionCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    email: string
    password: string
    clerkId?: string | null
    createdAt?: Date | string
    jobs?: JobUncheckedCreateNestedManyWithoutUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    usageTracking?: UsageTrackingUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    autoApplications?: AutoApplicationUncheckedCreateNestedManyWithoutUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    goals?: GoalUncheckedCreateNestedManyWithoutUserInput
    routines?: RoutineUncheckedCreateNestedManyWithoutUserInput
    gmailConnection?: GmailConnectionUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    clerkId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobs?: JobUpdateManyWithoutUserNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    usageTracking?: UsageTrackingUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    autoApplications?: AutoApplicationUpdateManyWithoutUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    goals?: GoalUpdateManyWithoutUserNestedInput
    routines?: RoutineUpdateManyWithoutUserNestedInput
    gmailConnection?: GmailConnectionUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    clerkId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobs?: JobUncheckedUpdateManyWithoutUserNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    usageTracking?: UsageTrackingUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    autoApplications?: AutoApplicationUncheckedUpdateManyWithoutUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    goals?: GoalUncheckedUpdateManyWithoutUserNestedInput
    routines?: RoutineUncheckedUpdateManyWithoutUserNestedInput
    gmailConnection?: GmailConnectionUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    email: string
    password: string
    clerkId?: string | null
    createdAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    clerkId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    clerkId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GmailConnectionCreateInput = {
    id?: string
    email: string
    accessToken: string
    refreshToken: string
    expiresAt: Date | string
    scope: string
    isActive?: boolean
    lastUsed?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutGmailConnectionInput
  }

  export type GmailConnectionUncheckedCreateInput = {
    id?: string
    userId: number
    email: string
    accessToken: string
    refreshToken: string
    expiresAt: Date | string
    scope: string
    isActive?: boolean
    lastUsed?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GmailConnectionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scope?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutGmailConnectionNestedInput
  }

  export type GmailConnectionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scope?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GmailConnectionCreateManyInput = {
    id?: string
    userId: number
    email: string
    accessToken: string
    refreshToken: string
    expiresAt: Date | string
    scope: string
    isActive?: boolean
    lastUsed?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GmailConnectionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scope?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GmailConnectionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scope?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileCreateInput = {
    data: JsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProfileInput
  }

  export type ProfileUncheckedCreateInput = {
    id?: number
    userId: number
    data: JsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
  }

  export type ProfileUpdateInput = {
    data?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileCreateManyInput = {
    id?: number
    userId: number
    data: JsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
  }

  export type ProfileUpdateManyMutationInput = {
    data?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobCreateInput = {
    id?: string
    status?: $Enums.JobStatus
    priority?: number
    attempts?: number
    maxAttempts?: number
    resumeText?: string | null
    jobDescription: string
    aiMode?: string | null
    matchMode?: string | null
    error?: string | null
    diagnostics?: NullableJsonNullValueInput | InputJsonValue
    processingLog?: JobCreateprocessingLogInput | InputJsonValue[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    company?: string | null
    jobUrl?: string | null
    role?: string | null
    artifacts?: ArtifactCreateNestedManyWithoutJobInput
    embeddings?: EmbeddingCreateNestedManyWithoutJobInput
    user?: UserCreateNestedOneWithoutJobsInput
  }

  export type JobUncheckedCreateInput = {
    id?: string
    userId?: number | null
    status?: $Enums.JobStatus
    priority?: number
    attempts?: number
    maxAttempts?: number
    resumeText?: string | null
    jobDescription: string
    aiMode?: string | null
    matchMode?: string | null
    error?: string | null
    diagnostics?: NullableJsonNullValueInput | InputJsonValue
    processingLog?: JobCreateprocessingLogInput | InputJsonValue[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    company?: string | null
    jobUrl?: string | null
    role?: string | null
    artifacts?: ArtifactUncheckedCreateNestedManyWithoutJobInput
    embeddings?: EmbeddingUncheckedCreateNestedManyWithoutJobInput
  }

  export type JobUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    priority?: IntFieldUpdateOperationsInput | number
    attempts?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    resumeText?: NullableStringFieldUpdateOperationsInput | string | null
    jobDescription?: StringFieldUpdateOperationsInput | string
    aiMode?: NullableStringFieldUpdateOperationsInput | string | null
    matchMode?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    diagnostics?: NullableJsonNullValueInput | InputJsonValue
    processingLog?: JobUpdateprocessingLogInput | InputJsonValue[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    jobUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    artifacts?: ArtifactUpdateManyWithoutJobNestedInput
    embeddings?: EmbeddingUpdateManyWithoutJobNestedInput
    user?: UserUpdateOneWithoutJobsNestedInput
  }

  export type JobUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    priority?: IntFieldUpdateOperationsInput | number
    attempts?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    resumeText?: NullableStringFieldUpdateOperationsInput | string | null
    jobDescription?: StringFieldUpdateOperationsInput | string
    aiMode?: NullableStringFieldUpdateOperationsInput | string | null
    matchMode?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    diagnostics?: NullableJsonNullValueInput | InputJsonValue
    processingLog?: JobUpdateprocessingLogInput | InputJsonValue[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    jobUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    artifacts?: ArtifactUncheckedUpdateManyWithoutJobNestedInput
    embeddings?: EmbeddingUncheckedUpdateManyWithoutJobNestedInput
  }

  export type JobCreateManyInput = {
    id?: string
    userId?: number | null
    status?: $Enums.JobStatus
    priority?: number
    attempts?: number
    maxAttempts?: number
    resumeText?: string | null
    jobDescription: string
    aiMode?: string | null
    matchMode?: string | null
    error?: string | null
    diagnostics?: NullableJsonNullValueInput | InputJsonValue
    processingLog?: JobCreateprocessingLogInput | InputJsonValue[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    company?: string | null
    jobUrl?: string | null
    role?: string | null
  }

  export type JobUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    priority?: IntFieldUpdateOperationsInput | number
    attempts?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    resumeText?: NullableStringFieldUpdateOperationsInput | string | null
    jobDescription?: StringFieldUpdateOperationsInput | string
    aiMode?: NullableStringFieldUpdateOperationsInput | string | null
    matchMode?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    diagnostics?: NullableJsonNullValueInput | InputJsonValue
    processingLog?: JobUpdateprocessingLogInput | InputJsonValue[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    jobUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JobUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    priority?: IntFieldUpdateOperationsInput | number
    attempts?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    resumeText?: NullableStringFieldUpdateOperationsInput | string | null
    jobDescription?: StringFieldUpdateOperationsInput | string
    aiMode?: NullableStringFieldUpdateOperationsInput | string | null
    matchMode?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    diagnostics?: NullableJsonNullValueInput | InputJsonValue
    processingLog?: JobUpdateprocessingLogInput | InputJsonValue[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    jobUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ArtifactCreateInput = {
    id?: string
    type: $Enums.ArtifactType
    version?: number
    content: Buffer
    metadata?: NullableJsonNullValueInput | InputJsonValue
    schema?: NullableJsonNullValueInput | InputJsonValue
    validated?: boolean
    createdAt?: Date | string
    job: JobCreateNestedOneWithoutArtifactsInput
  }

  export type ArtifactUncheckedCreateInput = {
    id?: string
    jobId: string
    type: $Enums.ArtifactType
    version?: number
    content: Buffer
    metadata?: NullableJsonNullValueInput | InputJsonValue
    schema?: NullableJsonNullValueInput | InputJsonValue
    validated?: boolean
    createdAt?: Date | string
  }

  export type ArtifactUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumArtifactTypeFieldUpdateOperationsInput | $Enums.ArtifactType
    version?: IntFieldUpdateOperationsInput | number
    content?: BytesFieldUpdateOperationsInput | Buffer
    metadata?: NullableJsonNullValueInput | InputJsonValue
    schema?: NullableJsonNullValueInput | InputJsonValue
    validated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    job?: JobUpdateOneRequiredWithoutArtifactsNestedInput
  }

  export type ArtifactUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    type?: EnumArtifactTypeFieldUpdateOperationsInput | $Enums.ArtifactType
    version?: IntFieldUpdateOperationsInput | number
    content?: BytesFieldUpdateOperationsInput | Buffer
    metadata?: NullableJsonNullValueInput | InputJsonValue
    schema?: NullableJsonNullValueInput | InputJsonValue
    validated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArtifactCreateManyInput = {
    id?: string
    jobId: string
    type: $Enums.ArtifactType
    version?: number
    content: Buffer
    metadata?: NullableJsonNullValueInput | InputJsonValue
    schema?: NullableJsonNullValueInput | InputJsonValue
    validated?: boolean
    createdAt?: Date | string
  }

  export type ArtifactUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumArtifactTypeFieldUpdateOperationsInput | $Enums.ArtifactType
    version?: IntFieldUpdateOperationsInput | number
    content?: BytesFieldUpdateOperationsInput | Buffer
    metadata?: NullableJsonNullValueInput | InputJsonValue
    schema?: NullableJsonNullValueInput | InputJsonValue
    validated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArtifactUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    type?: EnumArtifactTypeFieldUpdateOperationsInput | $Enums.ArtifactType
    version?: IntFieldUpdateOperationsInput | number
    content?: BytesFieldUpdateOperationsInput | Buffer
    metadata?: NullableJsonNullValueInput | InputJsonValue
    schema?: NullableJsonNullValueInput | InputJsonValue
    validated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmbeddingCreateInput = {
    id?: string
    content: string
    contentType: $Enums.EmbeddingType
    embedding?: EmbeddingCreateembeddingInput | number[]
    relevance?: number | null
    createdAt?: Date | string
    job: JobCreateNestedOneWithoutEmbeddingsInput
  }

  export type EmbeddingUncheckedCreateInput = {
    id?: string
    jobId: string
    content: string
    contentType: $Enums.EmbeddingType
    embedding?: EmbeddingCreateembeddingInput | number[]
    relevance?: number | null
    createdAt?: Date | string
  }

  export type EmbeddingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    contentType?: EnumEmbeddingTypeFieldUpdateOperationsInput | $Enums.EmbeddingType
    embedding?: EmbeddingUpdateembeddingInput | number[]
    relevance?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    job?: JobUpdateOneRequiredWithoutEmbeddingsNestedInput
  }

  export type EmbeddingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    contentType?: EnumEmbeddingTypeFieldUpdateOperationsInput | $Enums.EmbeddingType
    embedding?: EmbeddingUpdateembeddingInput | number[]
    relevance?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmbeddingCreateManyInput = {
    id?: string
    jobId: string
    content: string
    contentType: $Enums.EmbeddingType
    embedding?: EmbeddingCreateembeddingInput | number[]
    relevance?: number | null
    createdAt?: Date | string
  }

  export type EmbeddingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    contentType?: EnumEmbeddingTypeFieldUpdateOperationsInput | $Enums.EmbeddingType
    embedding?: EmbeddingUpdateembeddingInput | number[]
    relevance?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmbeddingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    contentType?: EnumEmbeddingTypeFieldUpdateOperationsInput | $Enums.EmbeddingType
    embedding?: EmbeddingUpdateembeddingInput | number[]
    relevance?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionCreateInput = {
    id?: string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    tier?: $Enums.SubscriptionTier
    status?: $Enums.SubscriptionStatus
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    cancelAtPeriodEnd?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateInput = {
    id?: string
    userId: number
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    tier?: $Enums.SubscriptionTier
    status?: $Enums.SubscriptionStatus
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    cancelAtPeriodEnd?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    tier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    tier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionCreateManyInput = {
    id?: string
    userId: number
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    tier?: $Enums.SubscriptionTier
    status?: $Enums.SubscriptionStatus
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    cancelAtPeriodEnd?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    tier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    tier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageTrackingCreateInput = {
    id?: string
    date?: Date | string
    resumesGenerated?: number
    dailyLimit: number
    tier: $Enums.SubscriptionTier
    resetAt: Date | string
    user: UserCreateNestedOneWithoutUsageTrackingInput
  }

  export type UsageTrackingUncheckedCreateInput = {
    id?: string
    userId: number
    date?: Date | string
    resumesGenerated?: number
    dailyLimit: number
    tier: $Enums.SubscriptionTier
    resetAt: Date | string
  }

  export type UsageTrackingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    resumesGenerated?: IntFieldUpdateOperationsInput | number
    dailyLimit?: IntFieldUpdateOperationsInput | number
    tier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    resetAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUsageTrackingNestedInput
  }

  export type UsageTrackingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    resumesGenerated?: IntFieldUpdateOperationsInput | number
    dailyLimit?: IntFieldUpdateOperationsInput | number
    tier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    resetAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageTrackingCreateManyInput = {
    id?: string
    userId: number
    date?: Date | string
    resumesGenerated?: number
    dailyLimit: number
    tier: $Enums.SubscriptionTier
    resetAt: Date | string
  }

  export type UsageTrackingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    resumesGenerated?: IntFieldUpdateOperationsInput | number
    dailyLimit?: IntFieldUpdateOperationsInput | number
    tier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    resetAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageTrackingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    resumesGenerated?: IntFieldUpdateOperationsInput | number
    dailyLimit?: IntFieldUpdateOperationsInput | number
    tier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    resetAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateInput = {
    id?: string
    stripePaymentId: string
    amount: number
    currency?: string
    status: $Enums.PaymentStatus
    description?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    userId: number
    stripePaymentId: string
    amount: number
    currency?: string
    status: $Enums.PaymentStatus
    description?: string | null
    createdAt?: Date | string
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripePaymentId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    stripePaymentId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyInput = {
    id?: string
    userId: number
    stripePaymentId: string
    amount: number
    currency?: string
    status: $Enums.PaymentStatus
    description?: string | null
    createdAt?: Date | string
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripePaymentId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    stripePaymentId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AggregatedJobCreateInput = {
    id?: string
    externalId: string
    source: string
    title: string
    company: string
    location?: string | null
    salary?: string | null
    description: string
    requirements?: string | null
    applyUrl: string
    companyUrl?: string | null
    atsType: string
    atsCompany?: string | null
    atsComplexity: string
    atsConfidence: number
    aiApplyable?: boolean
    extractedSkills?: AggregatedJobCreateextractedSkillsInput | string[]
    extractedExperience?: string | null
    extractedEducation?: string | null
    extractedJobLevel?: string | null
    extractedKeywords?: AggregatedJobCreateextractedKeywordsInput | string[]
    extractedBenefits?: AggregatedJobCreateextractedBenefitsInput | string[]
    lastExtractedAt?: Date | string | null
    extractionConfidence?: number | null
    postedDate: Date | string
    expiresAt?: Date | string | null
    firstSeenAt?: Date | string
    lastChecked?: Date | string
    closedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    applications?: AutoApplicationCreateNestedManyWithoutJobInput
  }

  export type AggregatedJobUncheckedCreateInput = {
    id?: string
    externalId: string
    source: string
    title: string
    company: string
    location?: string | null
    salary?: string | null
    description: string
    requirements?: string | null
    applyUrl: string
    companyUrl?: string | null
    atsType: string
    atsCompany?: string | null
    atsComplexity: string
    atsConfidence: number
    aiApplyable?: boolean
    extractedSkills?: AggregatedJobCreateextractedSkillsInput | string[]
    extractedExperience?: string | null
    extractedEducation?: string | null
    extractedJobLevel?: string | null
    extractedKeywords?: AggregatedJobCreateextractedKeywordsInput | string[]
    extractedBenefits?: AggregatedJobCreateextractedBenefitsInput | string[]
    lastExtractedAt?: Date | string | null
    extractionConfidence?: number | null
    postedDate: Date | string
    expiresAt?: Date | string | null
    firstSeenAt?: Date | string
    lastChecked?: Date | string
    closedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    applications?: AutoApplicationUncheckedCreateNestedManyWithoutJobInput
  }

  export type AggregatedJobUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    applyUrl?: StringFieldUpdateOperationsInput | string
    companyUrl?: NullableStringFieldUpdateOperationsInput | string | null
    atsType?: StringFieldUpdateOperationsInput | string
    atsCompany?: NullableStringFieldUpdateOperationsInput | string | null
    atsComplexity?: StringFieldUpdateOperationsInput | string
    atsConfidence?: FloatFieldUpdateOperationsInput | number
    aiApplyable?: BoolFieldUpdateOperationsInput | boolean
    extractedSkills?: AggregatedJobUpdateextractedSkillsInput | string[]
    extractedExperience?: NullableStringFieldUpdateOperationsInput | string | null
    extractedEducation?: NullableStringFieldUpdateOperationsInput | string | null
    extractedJobLevel?: NullableStringFieldUpdateOperationsInput | string | null
    extractedKeywords?: AggregatedJobUpdateextractedKeywordsInput | string[]
    extractedBenefits?: AggregatedJobUpdateextractedBenefitsInput | string[]
    lastExtractedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extractionConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    postedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firstSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChecked?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applications?: AutoApplicationUpdateManyWithoutJobNestedInput
  }

  export type AggregatedJobUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    applyUrl?: StringFieldUpdateOperationsInput | string
    companyUrl?: NullableStringFieldUpdateOperationsInput | string | null
    atsType?: StringFieldUpdateOperationsInput | string
    atsCompany?: NullableStringFieldUpdateOperationsInput | string | null
    atsComplexity?: StringFieldUpdateOperationsInput | string
    atsConfidence?: FloatFieldUpdateOperationsInput | number
    aiApplyable?: BoolFieldUpdateOperationsInput | boolean
    extractedSkills?: AggregatedJobUpdateextractedSkillsInput | string[]
    extractedExperience?: NullableStringFieldUpdateOperationsInput | string | null
    extractedEducation?: NullableStringFieldUpdateOperationsInput | string | null
    extractedJobLevel?: NullableStringFieldUpdateOperationsInput | string | null
    extractedKeywords?: AggregatedJobUpdateextractedKeywordsInput | string[]
    extractedBenefits?: AggregatedJobUpdateextractedBenefitsInput | string[]
    lastExtractedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extractionConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    postedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firstSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChecked?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applications?: AutoApplicationUncheckedUpdateManyWithoutJobNestedInput
  }

  export type AggregatedJobCreateManyInput = {
    id?: string
    externalId: string
    source: string
    title: string
    company: string
    location?: string | null
    salary?: string | null
    description: string
    requirements?: string | null
    applyUrl: string
    companyUrl?: string | null
    atsType: string
    atsCompany?: string | null
    atsComplexity: string
    atsConfidence: number
    aiApplyable?: boolean
    extractedSkills?: AggregatedJobCreateextractedSkillsInput | string[]
    extractedExperience?: string | null
    extractedEducation?: string | null
    extractedJobLevel?: string | null
    extractedKeywords?: AggregatedJobCreateextractedKeywordsInput | string[]
    extractedBenefits?: AggregatedJobCreateextractedBenefitsInput | string[]
    lastExtractedAt?: Date | string | null
    extractionConfidence?: number | null
    postedDate: Date | string
    expiresAt?: Date | string | null
    firstSeenAt?: Date | string
    lastChecked?: Date | string
    closedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type AggregatedJobUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    applyUrl?: StringFieldUpdateOperationsInput | string
    companyUrl?: NullableStringFieldUpdateOperationsInput | string | null
    atsType?: StringFieldUpdateOperationsInput | string
    atsCompany?: NullableStringFieldUpdateOperationsInput | string | null
    atsComplexity?: StringFieldUpdateOperationsInput | string
    atsConfidence?: FloatFieldUpdateOperationsInput | number
    aiApplyable?: BoolFieldUpdateOperationsInput | boolean
    extractedSkills?: AggregatedJobUpdateextractedSkillsInput | string[]
    extractedExperience?: NullableStringFieldUpdateOperationsInput | string | null
    extractedEducation?: NullableStringFieldUpdateOperationsInput | string | null
    extractedJobLevel?: NullableStringFieldUpdateOperationsInput | string | null
    extractedKeywords?: AggregatedJobUpdateextractedKeywordsInput | string[]
    extractedBenefits?: AggregatedJobUpdateextractedBenefitsInput | string[]
    lastExtractedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extractionConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    postedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firstSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChecked?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AggregatedJobUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    applyUrl?: StringFieldUpdateOperationsInput | string
    companyUrl?: NullableStringFieldUpdateOperationsInput | string | null
    atsType?: StringFieldUpdateOperationsInput | string
    atsCompany?: NullableStringFieldUpdateOperationsInput | string | null
    atsComplexity?: StringFieldUpdateOperationsInput | string
    atsConfidence?: FloatFieldUpdateOperationsInput | number
    aiApplyable?: BoolFieldUpdateOperationsInput | boolean
    extractedSkills?: AggregatedJobUpdateextractedSkillsInput | string[]
    extractedExperience?: NullableStringFieldUpdateOperationsInput | string | null
    extractedEducation?: NullableStringFieldUpdateOperationsInput | string | null
    extractedJobLevel?: NullableStringFieldUpdateOperationsInput | string | null
    extractedKeywords?: AggregatedJobUpdateextractedKeywordsInput | string[]
    extractedBenefits?: AggregatedJobUpdateextractedBenefitsInput | string[]
    lastExtractedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extractionConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    postedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firstSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChecked?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AutoApplicationCreateInput = {
    id?: string
    status?: $Enums.AutoApplicationStatus
    method?: string
    submittedAt?: Date | string | null
    confirmationUrl?: string | null
    confirmationId?: string | null
    confirmationData?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    errorType?: string | null
    retryCount?: number
    maxRetries?: number
    cost?: number
    createdAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    user: UserCreateNestedOneWithoutAutoApplicationsInput
    job: AggregatedJobCreateNestedOneWithoutApplicationsInput
    workerSession?: WorkerSessionCreateNestedOneWithoutAutoApplicationInput
  }

  export type AutoApplicationUncheckedCreateInput = {
    id?: string
    userId: number
    jobId: string
    status?: $Enums.AutoApplicationStatus
    method?: string
    submittedAt?: Date | string | null
    confirmationUrl?: string | null
    confirmationId?: string | null
    confirmationData?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    errorType?: string | null
    retryCount?: number
    maxRetries?: number
    cost?: number
    createdAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    workerSession?: WorkerSessionUncheckedCreateNestedOneWithoutAutoApplicationInput
  }

  export type AutoApplicationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumAutoApplicationStatusFieldUpdateOperationsInput | $Enums.AutoApplicationStatus
    method?: StringFieldUpdateOperationsInput | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    confirmationId?: NullableStringFieldUpdateOperationsInput | string | null
    confirmationData?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    errorType?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    maxRetries?: IntFieldUpdateOperationsInput | number
    cost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutAutoApplicationsNestedInput
    job?: AggregatedJobUpdateOneRequiredWithoutApplicationsNestedInput
    workerSession?: WorkerSessionUpdateOneWithoutAutoApplicationNestedInput
  }

  export type AutoApplicationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    jobId?: StringFieldUpdateOperationsInput | string
    status?: EnumAutoApplicationStatusFieldUpdateOperationsInput | $Enums.AutoApplicationStatus
    method?: StringFieldUpdateOperationsInput | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    confirmationId?: NullableStringFieldUpdateOperationsInput | string | null
    confirmationData?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    errorType?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    maxRetries?: IntFieldUpdateOperationsInput | number
    cost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workerSession?: WorkerSessionUncheckedUpdateOneWithoutAutoApplicationNestedInput
  }

  export type AutoApplicationCreateManyInput = {
    id?: string
    userId: number
    jobId: string
    status?: $Enums.AutoApplicationStatus
    method?: string
    submittedAt?: Date | string | null
    confirmationUrl?: string | null
    confirmationId?: string | null
    confirmationData?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    errorType?: string | null
    retryCount?: number
    maxRetries?: number
    cost?: number
    createdAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
  }

  export type AutoApplicationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumAutoApplicationStatusFieldUpdateOperationsInput | $Enums.AutoApplicationStatus
    method?: StringFieldUpdateOperationsInput | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    confirmationId?: NullableStringFieldUpdateOperationsInput | string | null
    confirmationData?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    errorType?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    maxRetries?: IntFieldUpdateOperationsInput | number
    cost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AutoApplicationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    jobId?: StringFieldUpdateOperationsInput | string
    status?: EnumAutoApplicationStatusFieldUpdateOperationsInput | $Enums.AutoApplicationStatus
    method?: StringFieldUpdateOperationsInput | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    confirmationId?: NullableStringFieldUpdateOperationsInput | string | null
    confirmationData?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    errorType?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    maxRetries?: IntFieldUpdateOperationsInput | number
    cost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ApplicationRecipeCreateInput = {
    id?: string
    platform: string
    atsType: string
    version?: number
    steps: JsonNullValueInput | InputJsonValue
    successRate?: number
    timesUsed?: number
    failureCount?: number
    recordingCost?: number
    replayCost?: number
    totalSaved?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastUsed?: Date | string | null
    lastFailure?: Date | string | null
    recordedBy?: string | null
    executions?: RecipeExecutionCreateNestedManyWithoutRecipeInput
  }

  export type ApplicationRecipeUncheckedCreateInput = {
    id?: string
    platform: string
    atsType: string
    version?: number
    steps: JsonNullValueInput | InputJsonValue
    successRate?: number
    timesUsed?: number
    failureCount?: number
    recordingCost?: number
    replayCost?: number
    totalSaved?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastUsed?: Date | string | null
    lastFailure?: Date | string | null
    recordedBy?: string | null
    executions?: RecipeExecutionUncheckedCreateNestedManyWithoutRecipeInput
  }

  export type ApplicationRecipeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    atsType?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    steps?: JsonNullValueInput | InputJsonValue
    successRate?: FloatFieldUpdateOperationsInput | number
    timesUsed?: IntFieldUpdateOperationsInput | number
    failureCount?: IntFieldUpdateOperationsInput | number
    recordingCost?: FloatFieldUpdateOperationsInput | number
    replayCost?: FloatFieldUpdateOperationsInput | number
    totalSaved?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastFailure?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recordedBy?: NullableStringFieldUpdateOperationsInput | string | null
    executions?: RecipeExecutionUpdateManyWithoutRecipeNestedInput
  }

  export type ApplicationRecipeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    atsType?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    steps?: JsonNullValueInput | InputJsonValue
    successRate?: FloatFieldUpdateOperationsInput | number
    timesUsed?: IntFieldUpdateOperationsInput | number
    failureCount?: IntFieldUpdateOperationsInput | number
    recordingCost?: FloatFieldUpdateOperationsInput | number
    replayCost?: FloatFieldUpdateOperationsInput | number
    totalSaved?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastFailure?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recordedBy?: NullableStringFieldUpdateOperationsInput | string | null
    executions?: RecipeExecutionUncheckedUpdateManyWithoutRecipeNestedInput
  }

  export type ApplicationRecipeCreateManyInput = {
    id?: string
    platform: string
    atsType: string
    version?: number
    steps: JsonNullValueInput | InputJsonValue
    successRate?: number
    timesUsed?: number
    failureCount?: number
    recordingCost?: number
    replayCost?: number
    totalSaved?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastUsed?: Date | string | null
    lastFailure?: Date | string | null
    recordedBy?: string | null
  }

  export type ApplicationRecipeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    atsType?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    steps?: JsonNullValueInput | InputJsonValue
    successRate?: FloatFieldUpdateOperationsInput | number
    timesUsed?: IntFieldUpdateOperationsInput | number
    failureCount?: IntFieldUpdateOperationsInput | number
    recordingCost?: FloatFieldUpdateOperationsInput | number
    replayCost?: FloatFieldUpdateOperationsInput | number
    totalSaved?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastFailure?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recordedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ApplicationRecipeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    atsType?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    steps?: JsonNullValueInput | InputJsonValue
    successRate?: FloatFieldUpdateOperationsInput | number
    timesUsed?: IntFieldUpdateOperationsInput | number
    failureCount?: IntFieldUpdateOperationsInput | number
    recordingCost?: FloatFieldUpdateOperationsInput | number
    replayCost?: FloatFieldUpdateOperationsInput | number
    totalSaved?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastFailure?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recordedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RecipeExecutionCreateInput = {
    id?: string
    success: boolean
    method: string
    duration?: number | null
    cost: number
    error?: string | null
    errorType?: string | null
    jobUrl?: string | null
    executedAt?: Date | string
    recipe: ApplicationRecipeCreateNestedOneWithoutExecutionsInput
  }

  export type RecipeExecutionUncheckedCreateInput = {
    id?: string
    recipeId: string
    success: boolean
    method: string
    duration?: number | null
    cost: number
    error?: string | null
    errorType?: string | null
    jobUrl?: string | null
    executedAt?: Date | string
  }

  export type RecipeExecutionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    method?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    cost?: FloatFieldUpdateOperationsInput | number
    error?: NullableStringFieldUpdateOperationsInput | string | null
    errorType?: NullableStringFieldUpdateOperationsInput | string | null
    jobUrl?: NullableStringFieldUpdateOperationsInput | string | null
    executedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recipe?: ApplicationRecipeUpdateOneRequiredWithoutExecutionsNestedInput
  }

  export type RecipeExecutionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipeId?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    method?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    cost?: FloatFieldUpdateOperationsInput | number
    error?: NullableStringFieldUpdateOperationsInput | string | null
    errorType?: NullableStringFieldUpdateOperationsInput | string | null
    jobUrl?: NullableStringFieldUpdateOperationsInput | string | null
    executedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecipeExecutionCreateManyInput = {
    id?: string
    recipeId: string
    success: boolean
    method: string
    duration?: number | null
    cost: number
    error?: string | null
    errorType?: string | null
    jobUrl?: string | null
    executedAt?: Date | string
  }

  export type RecipeExecutionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    method?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    cost?: FloatFieldUpdateOperationsInput | number
    error?: NullableStringFieldUpdateOperationsInput | string | null
    errorType?: NullableStringFieldUpdateOperationsInput | string | null
    jobUrl?: NullableStringFieldUpdateOperationsInput | string | null
    executedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecipeExecutionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipeId?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    method?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    cost?: FloatFieldUpdateOperationsInput | number
    error?: NullableStringFieldUpdateOperationsInput | string | null
    errorType?: NullableStringFieldUpdateOperationsInput | string | null
    jobUrl?: NullableStringFieldUpdateOperationsInput | string | null
    executedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiscoveredCompanyCreateInput = {
    id?: string
    atsType: string
    slug: string
    name?: string | null
    discoveredAt?: Date | string
    discoveredFrom?: string | null
    lastFetchedAt: Date | string
    isActive?: boolean
    totalJobs?: number
    lastJobCount?: number
  }

  export type DiscoveredCompanyUncheckedCreateInput = {
    id?: string
    atsType: string
    slug: string
    name?: string | null
    discoveredAt?: Date | string
    discoveredFrom?: string | null
    lastFetchedAt: Date | string
    isActive?: boolean
    totalJobs?: number
    lastJobCount?: number
  }

  export type DiscoveredCompanyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    atsType?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    discoveredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discoveredFrom?: NullableStringFieldUpdateOperationsInput | string | null
    lastFetchedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    totalJobs?: IntFieldUpdateOperationsInput | number
    lastJobCount?: IntFieldUpdateOperationsInput | number
  }

  export type DiscoveredCompanyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    atsType?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    discoveredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discoveredFrom?: NullableStringFieldUpdateOperationsInput | string | null
    lastFetchedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    totalJobs?: IntFieldUpdateOperationsInput | number
    lastJobCount?: IntFieldUpdateOperationsInput | number
  }

  export type DiscoveredCompanyCreateManyInput = {
    id?: string
    atsType: string
    slug: string
    name?: string | null
    discoveredAt?: Date | string
    discoveredFrom?: string | null
    lastFetchedAt: Date | string
    isActive?: boolean
    totalJobs?: number
    lastJobCount?: number
  }

  export type DiscoveredCompanyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    atsType?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    discoveredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discoveredFrom?: NullableStringFieldUpdateOperationsInput | string | null
    lastFetchedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    totalJobs?: IntFieldUpdateOperationsInput | number
    lastJobCount?: IntFieldUpdateOperationsInput | number
  }

  export type DiscoveredCompanyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    atsType?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    discoveredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discoveredFrom?: NullableStringFieldUpdateOperationsInput | string | null
    lastFetchedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    totalJobs?: IntFieldUpdateOperationsInput | number
    lastJobCount?: IntFieldUpdateOperationsInput | number
  }

  export type ConversationCreateInput = {
    id?: string
    title?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastMessageAt?: Date | string
    messages?: MessageCreateNestedManyWithoutConversationInput
    goals?: GoalCreateNestedManyWithoutConversationInput
    user?: UserCreateNestedOneWithoutConversationsInput
  }

  export type ConversationUncheckedCreateInput = {
    id?: string
    userId?: number | null
    title?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastMessageAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
    goals?: GoalUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMessageAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUpdateManyWithoutConversationNestedInput
    goals?: GoalUpdateManyWithoutConversationNestedInput
    user?: UserUpdateOneWithoutConversationsNestedInput
  }

  export type ConversationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMessageAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
    goals?: GoalUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationCreateManyInput = {
    id?: string
    userId?: number | null
    title?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastMessageAt?: Date | string
  }

  export type ConversationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMessageAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMessageAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateInput = {
    id?: string
    role: $Enums.MessageRole
    content: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tokenCount?: number | null
    cost?: number | null
    createdAt?: Date | string
    conversation: ConversationCreateNestedOneWithoutMessagesInput
  }

  export type MessageUncheckedCreateInput = {
    id?: string
    conversationId: string
    role: $Enums.MessageRole
    content: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tokenCount?: number | null
    cost?: number | null
    createdAt?: Date | string
  }

  export type MessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumMessageRoleFieldUpdateOperationsInput | $Enums.MessageRole
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tokenCount?: NullableIntFieldUpdateOperationsInput | number | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversation?: ConversationUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    role?: EnumMessageRoleFieldUpdateOperationsInput | $Enums.MessageRole
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tokenCount?: NullableIntFieldUpdateOperationsInput | number | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateManyInput = {
    id?: string
    conversationId: string
    role: $Enums.MessageRole
    content: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tokenCount?: number | null
    cost?: number | null
    createdAt?: Date | string
  }

  export type MessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumMessageRoleFieldUpdateOperationsInput | $Enums.MessageRole
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tokenCount?: NullableIntFieldUpdateOperationsInput | number | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    role?: EnumMessageRoleFieldUpdateOperationsInput | $Enums.MessageRole
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tokenCount?: NullableIntFieldUpdateOperationsInput | number | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GoalCreateInput = {
    id?: string
    title: string
    description?: string | null
    type?: $Enums.GoalType
    status?: $Enums.GoalStatus
    targetDate?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    conversation?: ConversationCreateNestedOneWithoutGoalsInput
    user: UserCreateNestedOneWithoutGoalsInput
  }

  export type GoalUncheckedCreateInput = {
    id?: string
    conversationId?: string | null
    userId: number
    title: string
    description?: string | null
    type?: $Enums.GoalType
    status?: $Enums.GoalStatus
    targetDate?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type GoalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumGoalTypeFieldUpdateOperationsInput | $Enums.GoalType
    status?: EnumGoalStatusFieldUpdateOperationsInput | $Enums.GoalStatus
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    conversation?: ConversationUpdateOneWithoutGoalsNestedInput
    user?: UserUpdateOneRequiredWithoutGoalsNestedInput
  }

  export type GoalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumGoalTypeFieldUpdateOperationsInput | $Enums.GoalType
    status?: EnumGoalStatusFieldUpdateOperationsInput | $Enums.GoalStatus
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type GoalCreateManyInput = {
    id?: string
    conversationId?: string | null
    userId: number
    title: string
    description?: string | null
    type?: $Enums.GoalType
    status?: $Enums.GoalStatus
    targetDate?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type GoalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumGoalTypeFieldUpdateOperationsInput | $Enums.GoalType
    status?: EnumGoalStatusFieldUpdateOperationsInput | $Enums.GoalStatus
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type GoalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumGoalTypeFieldUpdateOperationsInput | $Enums.GoalType
    status?: EnumGoalStatusFieldUpdateOperationsInput | $Enums.GoalStatus
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MessageUsageCreateInput = {
    id?: string
    userId?: number | null
    ip?: string | null
    date?: Date | string
    count?: number
    resetAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageUsageUncheckedCreateInput = {
    id?: string
    userId?: number | null
    ip?: string | null
    date?: Date | string
    count?: number
    resetAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageUsageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    count?: IntFieldUpdateOperationsInput | number
    resetAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUsageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    count?: IntFieldUpdateOperationsInput | number
    resetAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUsageCreateManyInput = {
    id?: string
    userId?: number | null
    ip?: string | null
    date?: Date | string
    count?: number
    resetAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageUsageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    count?: IntFieldUpdateOperationsInput | number
    resetAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUsageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    count?: IntFieldUpdateOperationsInput | number
    resetAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoutineCreateInput = {
    id?: string
    title: string
    description?: string | null
    type?: $Enums.RoutineType
    frequency?: string
    schedule?: string
    config?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    lastRun?: Date | string | null
    nextRun?: Date | string | null
    runCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutRoutinesInput
    executions?: RoutineExecutionCreateNestedManyWithoutRoutineInput
  }

  export type RoutineUncheckedCreateInput = {
    id?: string
    userId: number
    title: string
    description?: string | null
    type?: $Enums.RoutineType
    frequency?: string
    schedule?: string
    config?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    lastRun?: Date | string | null
    nextRun?: Date | string | null
    runCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    executions?: RoutineExecutionUncheckedCreateNestedManyWithoutRoutineInput
  }

  export type RoutineUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumRoutineTypeFieldUpdateOperationsInput | $Enums.RoutineType
    frequency?: StringFieldUpdateOperationsInput | string
    schedule?: StringFieldUpdateOperationsInput | string
    config?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastRun?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRun?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    runCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRoutinesNestedInput
    executions?: RoutineExecutionUpdateManyWithoutRoutineNestedInput
  }

  export type RoutineUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumRoutineTypeFieldUpdateOperationsInput | $Enums.RoutineType
    frequency?: StringFieldUpdateOperationsInput | string
    schedule?: StringFieldUpdateOperationsInput | string
    config?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastRun?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRun?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    runCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executions?: RoutineExecutionUncheckedUpdateManyWithoutRoutineNestedInput
  }

  export type RoutineCreateManyInput = {
    id?: string
    userId: number
    title: string
    description?: string | null
    type?: $Enums.RoutineType
    frequency?: string
    schedule?: string
    config?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    lastRun?: Date | string | null
    nextRun?: Date | string | null
    runCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoutineUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumRoutineTypeFieldUpdateOperationsInput | $Enums.RoutineType
    frequency?: StringFieldUpdateOperationsInput | string
    schedule?: StringFieldUpdateOperationsInput | string
    config?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastRun?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRun?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    runCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoutineUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumRoutineTypeFieldUpdateOperationsInput | $Enums.RoutineType
    frequency?: StringFieldUpdateOperationsInput | string
    schedule?: StringFieldUpdateOperationsInput | string
    config?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastRun?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRun?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    runCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoutineExecutionCreateInput = {
    id?: string
    status?: string
    summary?: string | null
    results?: NullableJsonNullValueInput | InputJsonValue
    duration?: number | null
    error?: string | null
    createdAt?: Date | string
    routine: RoutineCreateNestedOneWithoutExecutionsInput
  }

  export type RoutineExecutionUncheckedCreateInput = {
    id?: string
    routineId: string
    status?: string
    summary?: string | null
    results?: NullableJsonNullValueInput | InputJsonValue
    duration?: number | null
    error?: string | null
    createdAt?: Date | string
  }

  export type RoutineExecutionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    results?: NullableJsonNullValueInput | InputJsonValue
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    routine?: RoutineUpdateOneRequiredWithoutExecutionsNestedInput
  }

  export type RoutineExecutionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    routineId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    results?: NullableJsonNullValueInput | InputJsonValue
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoutineExecutionCreateManyInput = {
    id?: string
    routineId: string
    status?: string
    summary?: string | null
    results?: NullableJsonNullValueInput | InputJsonValue
    duration?: number | null
    error?: string | null
    createdAt?: Date | string
  }

  export type RoutineExecutionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    results?: NullableJsonNullValueInput | InputJsonValue
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoutineExecutionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    routineId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    results?: NullableJsonNullValueInput | InputJsonValue
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkerCreateInput = {
    email: string
    password: string
    name: string
    isActive?: boolean
    role?: $Enums.WorkerRole
    totalCompleted?: number
    totalFailed?: number
    totalSkipped?: number
    avgTimeSeconds?: number | null
    lastActiveAt?: Date | string | null
    currentSessionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: WorkerSessionCreateNestedManyWithoutWorkerInput
  }

  export type WorkerUncheckedCreateInput = {
    id?: number
    email: string
    password: string
    name: string
    isActive?: boolean
    role?: $Enums.WorkerRole
    totalCompleted?: number
    totalFailed?: number
    totalSkipped?: number
    avgTimeSeconds?: number | null
    lastActiveAt?: Date | string | null
    currentSessionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: WorkerSessionUncheckedCreateNestedManyWithoutWorkerInput
  }

  export type WorkerUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumWorkerRoleFieldUpdateOperationsInput | $Enums.WorkerRole
    totalCompleted?: IntFieldUpdateOperationsInput | number
    totalFailed?: IntFieldUpdateOperationsInput | number
    totalSkipped?: IntFieldUpdateOperationsInput | number
    avgTimeSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: WorkerSessionUpdateManyWithoutWorkerNestedInput
  }

  export type WorkerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumWorkerRoleFieldUpdateOperationsInput | $Enums.WorkerRole
    totalCompleted?: IntFieldUpdateOperationsInput | number
    totalFailed?: IntFieldUpdateOperationsInput | number
    totalSkipped?: IntFieldUpdateOperationsInput | number
    avgTimeSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: WorkerSessionUncheckedUpdateManyWithoutWorkerNestedInput
  }

  export type WorkerCreateManyInput = {
    id?: number
    email: string
    password: string
    name: string
    isActive?: boolean
    role?: $Enums.WorkerRole
    totalCompleted?: number
    totalFailed?: number
    totalSkipped?: number
    avgTimeSeconds?: number | null
    lastActiveAt?: Date | string | null
    currentSessionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkerUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumWorkerRoleFieldUpdateOperationsInput | $Enums.WorkerRole
    totalCompleted?: IntFieldUpdateOperationsInput | number
    totalFailed?: IntFieldUpdateOperationsInput | number
    totalSkipped?: IntFieldUpdateOperationsInput | number
    avgTimeSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumWorkerRoleFieldUpdateOperationsInput | $Enums.WorkerRole
    totalCompleted?: IntFieldUpdateOperationsInput | number
    totalFailed?: IntFieldUpdateOperationsInput | number
    totalSkipped?: IntFieldUpdateOperationsInput | number
    avgTimeSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkerSessionCreateInput = {
    id?: string
    status?: $Enums.WorkerSessionStatus
    browserSessionId?: string | null
    vncUrl?: string | null
    queuedAt?: Date | string
    assignedAt?: Date | string | null
    aiStartedAt?: Date | string | null
    aiCompletedAt?: Date | string | null
    submittedAt?: Date | string | null
    completedAt?: Date | string | null
    formData?: NullableJsonNullValueInput | InputJsonValue
    screenshotUrl?: string | null
    workerNotes?: string | null
    failReason?: string | null
    skipReason?: string | null
    worker?: WorkerCreateNestedOneWithoutSessionsInput
    autoApplication: AutoApplicationCreateNestedOneWithoutWorkerSessionInput
  }

  export type WorkerSessionUncheckedCreateInput = {
    id?: string
    workerId?: number | null
    autoApplicationId: string
    status?: $Enums.WorkerSessionStatus
    browserSessionId?: string | null
    vncUrl?: string | null
    queuedAt?: Date | string
    assignedAt?: Date | string | null
    aiStartedAt?: Date | string | null
    aiCompletedAt?: Date | string | null
    submittedAt?: Date | string | null
    completedAt?: Date | string | null
    formData?: NullableJsonNullValueInput | InputJsonValue
    screenshotUrl?: string | null
    workerNotes?: string | null
    failReason?: string | null
    skipReason?: string | null
  }

  export type WorkerSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumWorkerSessionStatusFieldUpdateOperationsInput | $Enums.WorkerSessionStatus
    browserSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    vncUrl?: NullableStringFieldUpdateOperationsInput | string | null
    queuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    formData?: NullableJsonNullValueInput | InputJsonValue
    screenshotUrl?: NullableStringFieldUpdateOperationsInput | string | null
    workerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    failReason?: NullableStringFieldUpdateOperationsInput | string | null
    skipReason?: NullableStringFieldUpdateOperationsInput | string | null
    worker?: WorkerUpdateOneWithoutSessionsNestedInput
    autoApplication?: AutoApplicationUpdateOneRequiredWithoutWorkerSessionNestedInput
  }

  export type WorkerSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workerId?: NullableIntFieldUpdateOperationsInput | number | null
    autoApplicationId?: StringFieldUpdateOperationsInput | string
    status?: EnumWorkerSessionStatusFieldUpdateOperationsInput | $Enums.WorkerSessionStatus
    browserSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    vncUrl?: NullableStringFieldUpdateOperationsInput | string | null
    queuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    formData?: NullableJsonNullValueInput | InputJsonValue
    screenshotUrl?: NullableStringFieldUpdateOperationsInput | string | null
    workerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    failReason?: NullableStringFieldUpdateOperationsInput | string | null
    skipReason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkerSessionCreateManyInput = {
    id?: string
    workerId?: number | null
    autoApplicationId: string
    status?: $Enums.WorkerSessionStatus
    browserSessionId?: string | null
    vncUrl?: string | null
    queuedAt?: Date | string
    assignedAt?: Date | string | null
    aiStartedAt?: Date | string | null
    aiCompletedAt?: Date | string | null
    submittedAt?: Date | string | null
    completedAt?: Date | string | null
    formData?: NullableJsonNullValueInput | InputJsonValue
    screenshotUrl?: string | null
    workerNotes?: string | null
    failReason?: string | null
    skipReason?: string | null
  }

  export type WorkerSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumWorkerSessionStatusFieldUpdateOperationsInput | $Enums.WorkerSessionStatus
    browserSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    vncUrl?: NullableStringFieldUpdateOperationsInput | string | null
    queuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    formData?: NullableJsonNullValueInput | InputJsonValue
    screenshotUrl?: NullableStringFieldUpdateOperationsInput | string | null
    workerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    failReason?: NullableStringFieldUpdateOperationsInput | string | null
    skipReason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkerSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workerId?: NullableIntFieldUpdateOperationsInput | number | null
    autoApplicationId?: StringFieldUpdateOperationsInput | string
    status?: EnumWorkerSessionStatusFieldUpdateOperationsInput | $Enums.WorkerSessionStatus
    browserSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    vncUrl?: NullableStringFieldUpdateOperationsInput | string | null
    queuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    formData?: NullableJsonNullValueInput | InputJsonValue
    screenshotUrl?: NullableStringFieldUpdateOperationsInput | string | null
    workerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    failReason?: NullableStringFieldUpdateOperationsInput | string | null
    skipReason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type JobListRelationFilter = {
    every?: JobWhereInput
    some?: JobWhereInput
    none?: JobWhereInput
  }

  export type ProfileNullableRelationFilter = {
    is?: ProfileWhereInput | null
    isNot?: ProfileWhereInput | null
  }

  export type SubscriptionNullableRelationFilter = {
    is?: SubscriptionWhereInput | null
    isNot?: SubscriptionWhereInput | null
  }

  export type UsageTrackingListRelationFilter = {
    every?: UsageTrackingWhereInput
    some?: UsageTrackingWhereInput
    none?: UsageTrackingWhereInput
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type AutoApplicationListRelationFilter = {
    every?: AutoApplicationWhereInput
    some?: AutoApplicationWhereInput
    none?: AutoApplicationWhereInput
  }

  export type ConversationListRelationFilter = {
    every?: ConversationWhereInput
    some?: ConversationWhereInput
    none?: ConversationWhereInput
  }

  export type GoalListRelationFilter = {
    every?: GoalWhereInput
    some?: GoalWhereInput
    none?: GoalWhereInput
  }

  export type RoutineListRelationFilter = {
    every?: RoutineWhereInput
    some?: RoutineWhereInput
    none?: RoutineWhereInput
  }

  export type GmailConnectionNullableRelationFilter = {
    is?: GmailConnectionWhereInput | null
    isNot?: GmailConnectionWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type JobOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsageTrackingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AutoApplicationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConversationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GoalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoutineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    clerkId?: SortOrder
    createdAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    clerkId?: SortOrder
    createdAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    clerkId?: SortOrder
    createdAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type GmailConnectionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    expiresAt?: SortOrder
    scope?: SortOrder
    isActive?: SortOrder
    lastUsed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GmailConnectionAvgOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type GmailConnectionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    expiresAt?: SortOrder
    scope?: SortOrder
    isActive?: SortOrder
    lastUsed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GmailConnectionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    expiresAt?: SortOrder
    scope?: SortOrder
    isActive?: SortOrder
    lastUsed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GmailConnectionSumOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ProfileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    data?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProfileAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type ProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProfileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProfileSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type EnumJobStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.JobStatus | EnumJobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumJobStatusFilter<$PrismaModel> | $Enums.JobStatus
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }
  export type JsonNullableListFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableListFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableListFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableListFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableListFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableListFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue[] | ListJsonFieldRefInput<$PrismaModel> | null
    has?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    hasEvery?: InputJsonValue[] | ListJsonFieldRefInput<$PrismaModel>
    hasSome?: InputJsonValue[] | ListJsonFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type ArtifactListRelationFilter = {
    every?: ArtifactWhereInput
    some?: ArtifactWhereInput
    none?: ArtifactWhereInput
  }

  export type EmbeddingListRelationFilter = {
    every?: EmbeddingWhereInput
    some?: EmbeddingWhereInput
    none?: EmbeddingWhereInput
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type ArtifactOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmbeddingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JobCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    attempts?: SortOrder
    maxAttempts?: SortOrder
    resumeText?: SortOrder
    jobDescription?: SortOrder
    aiMode?: SortOrder
    matchMode?: SortOrder
    error?: SortOrder
    diagnostics?: SortOrder
    processingLog?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    company?: SortOrder
    jobUrl?: SortOrder
    role?: SortOrder
  }

  export type JobAvgOrderByAggregateInput = {
    userId?: SortOrder
    priority?: SortOrder
    attempts?: SortOrder
    maxAttempts?: SortOrder
  }

  export type JobMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    attempts?: SortOrder
    maxAttempts?: SortOrder
    resumeText?: SortOrder
    jobDescription?: SortOrder
    aiMode?: SortOrder
    matchMode?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    company?: SortOrder
    jobUrl?: SortOrder
    role?: SortOrder
  }

  export type JobMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    attempts?: SortOrder
    maxAttempts?: SortOrder
    resumeText?: SortOrder
    jobDescription?: SortOrder
    aiMode?: SortOrder
    matchMode?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    company?: SortOrder
    jobUrl?: SortOrder
    role?: SortOrder
  }

  export type JobSumOrderByAggregateInput = {
    userId?: SortOrder
    priority?: SortOrder
    attempts?: SortOrder
    maxAttempts?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumJobStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.JobStatus | EnumJobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumJobStatusWithAggregatesFilter<$PrismaModel> | $Enums.JobStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumJobStatusFilter<$PrismaModel>
    _max?: NestedEnumJobStatusFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumArtifactTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ArtifactType | EnumArtifactTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ArtifactType[] | ListEnumArtifactTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ArtifactType[] | ListEnumArtifactTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumArtifactTypeFilter<$PrismaModel> | $Enums.ArtifactType
  }

  export type BytesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel>
    in?: Buffer[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Buffer[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesFilter<$PrismaModel> | Buffer
  }

  export type JobRelationFilter = {
    is?: JobWhereInput
    isNot?: JobWhereInput
  }

  export type ArtifactJobIdTypeVersionCompoundUniqueInput = {
    jobId: string
    type: $Enums.ArtifactType
    version: number
  }

  export type ArtifactCountOrderByAggregateInput = {
    id?: SortOrder
    jobId?: SortOrder
    type?: SortOrder
    version?: SortOrder
    content?: SortOrder
    metadata?: SortOrder
    schema?: SortOrder
    validated?: SortOrder
    createdAt?: SortOrder
  }

  export type ArtifactAvgOrderByAggregateInput = {
    version?: SortOrder
  }

  export type ArtifactMaxOrderByAggregateInput = {
    id?: SortOrder
    jobId?: SortOrder
    type?: SortOrder
    version?: SortOrder
    content?: SortOrder
    validated?: SortOrder
    createdAt?: SortOrder
  }

  export type ArtifactMinOrderByAggregateInput = {
    id?: SortOrder
    jobId?: SortOrder
    type?: SortOrder
    version?: SortOrder
    content?: SortOrder
    validated?: SortOrder
    createdAt?: SortOrder
  }

  export type ArtifactSumOrderByAggregateInput = {
    version?: SortOrder
  }

  export type EnumArtifactTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ArtifactType | EnumArtifactTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ArtifactType[] | ListEnumArtifactTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ArtifactType[] | ListEnumArtifactTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumArtifactTypeWithAggregatesFilter<$PrismaModel> | $Enums.ArtifactType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumArtifactTypeFilter<$PrismaModel>
    _max?: NestedEnumArtifactTypeFilter<$PrismaModel>
  }

  export type BytesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel>
    in?: Buffer[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Buffer[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesWithAggregatesFilter<$PrismaModel> | Buffer
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBytesFilter<$PrismaModel>
    _max?: NestedBytesFilter<$PrismaModel>
  }

  export type EnumEmbeddingTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EmbeddingType | EnumEmbeddingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EmbeddingType[] | ListEnumEmbeddingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmbeddingType[] | ListEnumEmbeddingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEmbeddingTypeFilter<$PrismaModel> | $Enums.EmbeddingType
  }

  export type FloatNullableListFilter<$PrismaModel = never> = {
    equals?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    has?: number | FloatFieldRefInput<$PrismaModel> | null
    hasEvery?: number[] | ListFloatFieldRefInput<$PrismaModel>
    hasSome?: number[] | ListFloatFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type EmbeddingCountOrderByAggregateInput = {
    id?: SortOrder
    jobId?: SortOrder
    content?: SortOrder
    contentType?: SortOrder
    embedding?: SortOrder
    relevance?: SortOrder
    createdAt?: SortOrder
  }

  export type EmbeddingAvgOrderByAggregateInput = {
    embedding?: SortOrder
    relevance?: SortOrder
  }

  export type EmbeddingMaxOrderByAggregateInput = {
    id?: SortOrder
    jobId?: SortOrder
    content?: SortOrder
    contentType?: SortOrder
    relevance?: SortOrder
    createdAt?: SortOrder
  }

  export type EmbeddingMinOrderByAggregateInput = {
    id?: SortOrder
    jobId?: SortOrder
    content?: SortOrder
    contentType?: SortOrder
    relevance?: SortOrder
    createdAt?: SortOrder
  }

  export type EmbeddingSumOrderByAggregateInput = {
    embedding?: SortOrder
    relevance?: SortOrder
  }

  export type EnumEmbeddingTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EmbeddingType | EnumEmbeddingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EmbeddingType[] | ListEnumEmbeddingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmbeddingType[] | ListEnumEmbeddingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEmbeddingTypeWithAggregatesFilter<$PrismaModel> | $Enums.EmbeddingType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEmbeddingTypeFilter<$PrismaModel>
    _max?: NestedEnumEmbeddingTypeFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumSubscriptionTierFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionTier | EnumSubscriptionTierFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionTierFilter<$PrismaModel> | $Enums.SubscriptionTier
  }

  export type EnumSubscriptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusFilter<$PrismaModel> | $Enums.SubscriptionStatus
  }

  export type SubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    stripeCustomerId?: SortOrder
    stripeSubscriptionId?: SortOrder
    tier?: SortOrder
    status?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionAvgOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type SubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    stripeCustomerId?: SortOrder
    stripeSubscriptionId?: SortOrder
    tier?: SortOrder
    status?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    stripeCustomerId?: SortOrder
    stripeSubscriptionId?: SortOrder
    tier?: SortOrder
    status?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionSumOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type EnumSubscriptionTierWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionTier | EnumSubscriptionTierFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionTierWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionTier
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionTierFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionTierFilter<$PrismaModel>
  }

  export type EnumSubscriptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
  }

  export type UsageTrackingUserIdDateCompoundUniqueInput = {
    userId: number
    date: Date | string
  }

  export type UsageTrackingCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    resumesGenerated?: SortOrder
    dailyLimit?: SortOrder
    tier?: SortOrder
    resetAt?: SortOrder
  }

  export type UsageTrackingAvgOrderByAggregateInput = {
    userId?: SortOrder
    resumesGenerated?: SortOrder
    dailyLimit?: SortOrder
  }

  export type UsageTrackingMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    resumesGenerated?: SortOrder
    dailyLimit?: SortOrder
    tier?: SortOrder
    resetAt?: SortOrder
  }

  export type UsageTrackingMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    resumesGenerated?: SortOrder
    dailyLimit?: SortOrder
    tier?: SortOrder
    resetAt?: SortOrder
  }

  export type UsageTrackingSumOrderByAggregateInput = {
    userId?: SortOrder
    resumesGenerated?: SortOrder
    dailyLimit?: SortOrder
  }

  export type EnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    stripePaymentId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    userId?: SortOrder
    amount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    stripePaymentId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    stripePaymentId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    userId?: SortOrder
    amount?: SortOrder
  }

  export type EnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type AggregatedJobCountOrderByAggregateInput = {
    id?: SortOrder
    externalId?: SortOrder
    source?: SortOrder
    title?: SortOrder
    company?: SortOrder
    location?: SortOrder
    salary?: SortOrder
    description?: SortOrder
    requirements?: SortOrder
    applyUrl?: SortOrder
    companyUrl?: SortOrder
    atsType?: SortOrder
    atsCompany?: SortOrder
    atsComplexity?: SortOrder
    atsConfidence?: SortOrder
    aiApplyable?: SortOrder
    extractedSkills?: SortOrder
    extractedExperience?: SortOrder
    extractedEducation?: SortOrder
    extractedJobLevel?: SortOrder
    extractedKeywords?: SortOrder
    extractedBenefits?: SortOrder
    lastExtractedAt?: SortOrder
    extractionConfidence?: SortOrder
    postedDate?: SortOrder
    expiresAt?: SortOrder
    firstSeenAt?: SortOrder
    lastChecked?: SortOrder
    closedAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AggregatedJobAvgOrderByAggregateInput = {
    atsConfidence?: SortOrder
    extractionConfidence?: SortOrder
  }

  export type AggregatedJobMaxOrderByAggregateInput = {
    id?: SortOrder
    externalId?: SortOrder
    source?: SortOrder
    title?: SortOrder
    company?: SortOrder
    location?: SortOrder
    salary?: SortOrder
    description?: SortOrder
    requirements?: SortOrder
    applyUrl?: SortOrder
    companyUrl?: SortOrder
    atsType?: SortOrder
    atsCompany?: SortOrder
    atsComplexity?: SortOrder
    atsConfidence?: SortOrder
    aiApplyable?: SortOrder
    extractedExperience?: SortOrder
    extractedEducation?: SortOrder
    extractedJobLevel?: SortOrder
    lastExtractedAt?: SortOrder
    extractionConfidence?: SortOrder
    postedDate?: SortOrder
    expiresAt?: SortOrder
    firstSeenAt?: SortOrder
    lastChecked?: SortOrder
    closedAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AggregatedJobMinOrderByAggregateInput = {
    id?: SortOrder
    externalId?: SortOrder
    source?: SortOrder
    title?: SortOrder
    company?: SortOrder
    location?: SortOrder
    salary?: SortOrder
    description?: SortOrder
    requirements?: SortOrder
    applyUrl?: SortOrder
    companyUrl?: SortOrder
    atsType?: SortOrder
    atsCompany?: SortOrder
    atsComplexity?: SortOrder
    atsConfidence?: SortOrder
    aiApplyable?: SortOrder
    extractedExperience?: SortOrder
    extractedEducation?: SortOrder
    extractedJobLevel?: SortOrder
    lastExtractedAt?: SortOrder
    extractionConfidence?: SortOrder
    postedDate?: SortOrder
    expiresAt?: SortOrder
    firstSeenAt?: SortOrder
    lastChecked?: SortOrder
    closedAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AggregatedJobSumOrderByAggregateInput = {
    atsConfidence?: SortOrder
    extractionConfidence?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumAutoApplicationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AutoApplicationStatus | EnumAutoApplicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AutoApplicationStatus[] | ListEnumAutoApplicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AutoApplicationStatus[] | ListEnumAutoApplicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAutoApplicationStatusFilter<$PrismaModel> | $Enums.AutoApplicationStatus
  }

  export type AggregatedJobRelationFilter = {
    is?: AggregatedJobWhereInput
    isNot?: AggregatedJobWhereInput
  }

  export type WorkerSessionNullableRelationFilter = {
    is?: WorkerSessionWhereInput | null
    isNot?: WorkerSessionWhereInput | null
  }

  export type AutoApplicationUserIdJobIdCompoundUniqueInput = {
    userId: number
    jobId: string
  }

  export type AutoApplicationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    jobId?: SortOrder
    status?: SortOrder
    method?: SortOrder
    submittedAt?: SortOrder
    confirmationUrl?: SortOrder
    confirmationId?: SortOrder
    confirmationData?: SortOrder
    error?: SortOrder
    errorType?: SortOrder
    retryCount?: SortOrder
    maxRetries?: SortOrder
    cost?: SortOrder
    createdAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type AutoApplicationAvgOrderByAggregateInput = {
    userId?: SortOrder
    retryCount?: SortOrder
    maxRetries?: SortOrder
    cost?: SortOrder
  }

  export type AutoApplicationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    jobId?: SortOrder
    status?: SortOrder
    method?: SortOrder
    submittedAt?: SortOrder
    confirmationUrl?: SortOrder
    confirmationId?: SortOrder
    error?: SortOrder
    errorType?: SortOrder
    retryCount?: SortOrder
    maxRetries?: SortOrder
    cost?: SortOrder
    createdAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type AutoApplicationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    jobId?: SortOrder
    status?: SortOrder
    method?: SortOrder
    submittedAt?: SortOrder
    confirmationUrl?: SortOrder
    confirmationId?: SortOrder
    error?: SortOrder
    errorType?: SortOrder
    retryCount?: SortOrder
    maxRetries?: SortOrder
    cost?: SortOrder
    createdAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type AutoApplicationSumOrderByAggregateInput = {
    userId?: SortOrder
    retryCount?: SortOrder
    maxRetries?: SortOrder
    cost?: SortOrder
  }

  export type EnumAutoApplicationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AutoApplicationStatus | EnumAutoApplicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AutoApplicationStatus[] | ListEnumAutoApplicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AutoApplicationStatus[] | ListEnumAutoApplicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAutoApplicationStatusWithAggregatesFilter<$PrismaModel> | $Enums.AutoApplicationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAutoApplicationStatusFilter<$PrismaModel>
    _max?: NestedEnumAutoApplicationStatusFilter<$PrismaModel>
  }

  export type RecipeExecutionListRelationFilter = {
    every?: RecipeExecutionWhereInput
    some?: RecipeExecutionWhereInput
    none?: RecipeExecutionWhereInput
  }

  export type RecipeExecutionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ApplicationRecipeCountOrderByAggregateInput = {
    id?: SortOrder
    platform?: SortOrder
    atsType?: SortOrder
    version?: SortOrder
    steps?: SortOrder
    successRate?: SortOrder
    timesUsed?: SortOrder
    failureCount?: SortOrder
    recordingCost?: SortOrder
    replayCost?: SortOrder
    totalSaved?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastUsed?: SortOrder
    lastFailure?: SortOrder
    recordedBy?: SortOrder
  }

  export type ApplicationRecipeAvgOrderByAggregateInput = {
    version?: SortOrder
    successRate?: SortOrder
    timesUsed?: SortOrder
    failureCount?: SortOrder
    recordingCost?: SortOrder
    replayCost?: SortOrder
    totalSaved?: SortOrder
  }

  export type ApplicationRecipeMaxOrderByAggregateInput = {
    id?: SortOrder
    platform?: SortOrder
    atsType?: SortOrder
    version?: SortOrder
    successRate?: SortOrder
    timesUsed?: SortOrder
    failureCount?: SortOrder
    recordingCost?: SortOrder
    replayCost?: SortOrder
    totalSaved?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastUsed?: SortOrder
    lastFailure?: SortOrder
    recordedBy?: SortOrder
  }

  export type ApplicationRecipeMinOrderByAggregateInput = {
    id?: SortOrder
    platform?: SortOrder
    atsType?: SortOrder
    version?: SortOrder
    successRate?: SortOrder
    timesUsed?: SortOrder
    failureCount?: SortOrder
    recordingCost?: SortOrder
    replayCost?: SortOrder
    totalSaved?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastUsed?: SortOrder
    lastFailure?: SortOrder
    recordedBy?: SortOrder
  }

  export type ApplicationRecipeSumOrderByAggregateInput = {
    version?: SortOrder
    successRate?: SortOrder
    timesUsed?: SortOrder
    failureCount?: SortOrder
    recordingCost?: SortOrder
    replayCost?: SortOrder
    totalSaved?: SortOrder
  }

  export type ApplicationRecipeRelationFilter = {
    is?: ApplicationRecipeWhereInput
    isNot?: ApplicationRecipeWhereInput
  }

  export type RecipeExecutionCountOrderByAggregateInput = {
    id?: SortOrder
    recipeId?: SortOrder
    success?: SortOrder
    method?: SortOrder
    duration?: SortOrder
    cost?: SortOrder
    error?: SortOrder
    errorType?: SortOrder
    jobUrl?: SortOrder
    executedAt?: SortOrder
  }

  export type RecipeExecutionAvgOrderByAggregateInput = {
    duration?: SortOrder
    cost?: SortOrder
  }

  export type RecipeExecutionMaxOrderByAggregateInput = {
    id?: SortOrder
    recipeId?: SortOrder
    success?: SortOrder
    method?: SortOrder
    duration?: SortOrder
    cost?: SortOrder
    error?: SortOrder
    errorType?: SortOrder
    jobUrl?: SortOrder
    executedAt?: SortOrder
  }

  export type RecipeExecutionMinOrderByAggregateInput = {
    id?: SortOrder
    recipeId?: SortOrder
    success?: SortOrder
    method?: SortOrder
    duration?: SortOrder
    cost?: SortOrder
    error?: SortOrder
    errorType?: SortOrder
    jobUrl?: SortOrder
    executedAt?: SortOrder
  }

  export type RecipeExecutionSumOrderByAggregateInput = {
    duration?: SortOrder
    cost?: SortOrder
  }

  export type DiscoveredCompanyAtsTypeSlugCompoundUniqueInput = {
    atsType: string
    slug: string
  }

  export type DiscoveredCompanyCountOrderByAggregateInput = {
    id?: SortOrder
    atsType?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    discoveredAt?: SortOrder
    discoveredFrom?: SortOrder
    lastFetchedAt?: SortOrder
    isActive?: SortOrder
    totalJobs?: SortOrder
    lastJobCount?: SortOrder
  }

  export type DiscoveredCompanyAvgOrderByAggregateInput = {
    totalJobs?: SortOrder
    lastJobCount?: SortOrder
  }

  export type DiscoveredCompanyMaxOrderByAggregateInput = {
    id?: SortOrder
    atsType?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    discoveredAt?: SortOrder
    discoveredFrom?: SortOrder
    lastFetchedAt?: SortOrder
    isActive?: SortOrder
    totalJobs?: SortOrder
    lastJobCount?: SortOrder
  }

  export type DiscoveredCompanyMinOrderByAggregateInput = {
    id?: SortOrder
    atsType?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    discoveredAt?: SortOrder
    discoveredFrom?: SortOrder
    lastFetchedAt?: SortOrder
    isActive?: SortOrder
    totalJobs?: SortOrder
    lastJobCount?: SortOrder
  }

  export type DiscoveredCompanySumOrderByAggregateInput = {
    totalJobs?: SortOrder
    lastJobCount?: SortOrder
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConversationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastMessageAt?: SortOrder
  }

  export type ConversationAvgOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type ConversationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastMessageAt?: SortOrder
  }

  export type ConversationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastMessageAt?: SortOrder
  }

  export type ConversationSumOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type EnumMessageRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageRole | EnumMessageRoleFieldRefInput<$PrismaModel>
    in?: $Enums.MessageRole[] | ListEnumMessageRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageRole[] | ListEnumMessageRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageRoleFilter<$PrismaModel> | $Enums.MessageRole
  }

  export type ConversationRelationFilter = {
    is?: ConversationWhereInput
    isNot?: ConversationWhereInput
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    metadata?: SortOrder
    tokenCount?: SortOrder
    cost?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageAvgOrderByAggregateInput = {
    tokenCount?: SortOrder
    cost?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    tokenCount?: SortOrder
    cost?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    tokenCount?: SortOrder
    cost?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageSumOrderByAggregateInput = {
    tokenCount?: SortOrder
    cost?: SortOrder
  }

  export type EnumMessageRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageRole | EnumMessageRoleFieldRefInput<$PrismaModel>
    in?: $Enums.MessageRole[] | ListEnumMessageRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageRole[] | ListEnumMessageRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageRoleWithAggregatesFilter<$PrismaModel> | $Enums.MessageRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessageRoleFilter<$PrismaModel>
    _max?: NestedEnumMessageRoleFilter<$PrismaModel>
  }

  export type EnumGoalTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.GoalType | EnumGoalTypeFieldRefInput<$PrismaModel>
    in?: $Enums.GoalType[] | ListEnumGoalTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.GoalType[] | ListEnumGoalTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumGoalTypeFilter<$PrismaModel> | $Enums.GoalType
  }

  export type EnumGoalStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.GoalStatus | EnumGoalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.GoalStatus[] | ListEnumGoalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.GoalStatus[] | ListEnumGoalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumGoalStatusFilter<$PrismaModel> | $Enums.GoalStatus
  }

  export type ConversationNullableRelationFilter = {
    is?: ConversationWhereInput | null
    isNot?: ConversationWhereInput | null
  }

  export type GoalCountOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    status?: SortOrder
    targetDate?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    metadata?: SortOrder
  }

  export type GoalAvgOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type GoalMaxOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    status?: SortOrder
    targetDate?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GoalMinOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    status?: SortOrder
    targetDate?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GoalSumOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type EnumGoalTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GoalType | EnumGoalTypeFieldRefInput<$PrismaModel>
    in?: $Enums.GoalType[] | ListEnumGoalTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.GoalType[] | ListEnumGoalTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumGoalTypeWithAggregatesFilter<$PrismaModel> | $Enums.GoalType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGoalTypeFilter<$PrismaModel>
    _max?: NestedEnumGoalTypeFilter<$PrismaModel>
  }

  export type EnumGoalStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GoalStatus | EnumGoalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.GoalStatus[] | ListEnumGoalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.GoalStatus[] | ListEnumGoalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumGoalStatusWithAggregatesFilter<$PrismaModel> | $Enums.GoalStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGoalStatusFilter<$PrismaModel>
    _max?: NestedEnumGoalStatusFilter<$PrismaModel>
  }

  export type MessageUsageUserIdDateCompoundUniqueInput = {
    userId: number
    date: Date | string
  }

  export type MessageUsageIpDateCompoundUniqueInput = {
    ip: string
    date: Date | string
  }

  export type MessageUsageCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    ip?: SortOrder
    date?: SortOrder
    count?: SortOrder
    resetAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessageUsageAvgOrderByAggregateInput = {
    userId?: SortOrder
    count?: SortOrder
  }

  export type MessageUsageMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    ip?: SortOrder
    date?: SortOrder
    count?: SortOrder
    resetAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessageUsageMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    ip?: SortOrder
    date?: SortOrder
    count?: SortOrder
    resetAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessageUsageSumOrderByAggregateInput = {
    userId?: SortOrder
    count?: SortOrder
  }

  export type EnumRoutineTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RoutineType | EnumRoutineTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RoutineType[] | ListEnumRoutineTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoutineType[] | ListEnumRoutineTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRoutineTypeFilter<$PrismaModel> | $Enums.RoutineType
  }

  export type RoutineExecutionListRelationFilter = {
    every?: RoutineExecutionWhereInput
    some?: RoutineExecutionWhereInput
    none?: RoutineExecutionWhereInput
  }

  export type RoutineExecutionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoutineCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    frequency?: SortOrder
    schedule?: SortOrder
    config?: SortOrder
    isActive?: SortOrder
    lastRun?: SortOrder
    nextRun?: SortOrder
    runCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoutineAvgOrderByAggregateInput = {
    userId?: SortOrder
    runCount?: SortOrder
  }

  export type RoutineMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    frequency?: SortOrder
    schedule?: SortOrder
    isActive?: SortOrder
    lastRun?: SortOrder
    nextRun?: SortOrder
    runCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoutineMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    frequency?: SortOrder
    schedule?: SortOrder
    isActive?: SortOrder
    lastRun?: SortOrder
    nextRun?: SortOrder
    runCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoutineSumOrderByAggregateInput = {
    userId?: SortOrder
    runCount?: SortOrder
  }

  export type EnumRoutineTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RoutineType | EnumRoutineTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RoutineType[] | ListEnumRoutineTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoutineType[] | ListEnumRoutineTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRoutineTypeWithAggregatesFilter<$PrismaModel> | $Enums.RoutineType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoutineTypeFilter<$PrismaModel>
    _max?: NestedEnumRoutineTypeFilter<$PrismaModel>
  }

  export type RoutineRelationFilter = {
    is?: RoutineWhereInput
    isNot?: RoutineWhereInput
  }

  export type RoutineExecutionCountOrderByAggregateInput = {
    id?: SortOrder
    routineId?: SortOrder
    status?: SortOrder
    summary?: SortOrder
    results?: SortOrder
    duration?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
  }

  export type RoutineExecutionAvgOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type RoutineExecutionMaxOrderByAggregateInput = {
    id?: SortOrder
    routineId?: SortOrder
    status?: SortOrder
    summary?: SortOrder
    duration?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
  }

  export type RoutineExecutionMinOrderByAggregateInput = {
    id?: SortOrder
    routineId?: SortOrder
    status?: SortOrder
    summary?: SortOrder
    duration?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
  }

  export type RoutineExecutionSumOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type EnumWorkerRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkerRole | EnumWorkerRoleFieldRefInput<$PrismaModel>
    in?: $Enums.WorkerRole[] | ListEnumWorkerRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkerRole[] | ListEnumWorkerRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkerRoleFilter<$PrismaModel> | $Enums.WorkerRole
  }

  export type WorkerSessionListRelationFilter = {
    every?: WorkerSessionWhereInput
    some?: WorkerSessionWhereInput
    none?: WorkerSessionWhereInput
  }

  export type WorkerSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkerCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    role?: SortOrder
    totalCompleted?: SortOrder
    totalFailed?: SortOrder
    totalSkipped?: SortOrder
    avgTimeSeconds?: SortOrder
    lastActiveAt?: SortOrder
    currentSessionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkerAvgOrderByAggregateInput = {
    id?: SortOrder
    totalCompleted?: SortOrder
    totalFailed?: SortOrder
    totalSkipped?: SortOrder
    avgTimeSeconds?: SortOrder
  }

  export type WorkerMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    role?: SortOrder
    totalCompleted?: SortOrder
    totalFailed?: SortOrder
    totalSkipped?: SortOrder
    avgTimeSeconds?: SortOrder
    lastActiveAt?: SortOrder
    currentSessionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkerMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    role?: SortOrder
    totalCompleted?: SortOrder
    totalFailed?: SortOrder
    totalSkipped?: SortOrder
    avgTimeSeconds?: SortOrder
    lastActiveAt?: SortOrder
    currentSessionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkerSumOrderByAggregateInput = {
    id?: SortOrder
    totalCompleted?: SortOrder
    totalFailed?: SortOrder
    totalSkipped?: SortOrder
    avgTimeSeconds?: SortOrder
  }

  export type EnumWorkerRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkerRole | EnumWorkerRoleFieldRefInput<$PrismaModel>
    in?: $Enums.WorkerRole[] | ListEnumWorkerRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkerRole[] | ListEnumWorkerRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkerRoleWithAggregatesFilter<$PrismaModel> | $Enums.WorkerRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkerRoleFilter<$PrismaModel>
    _max?: NestedEnumWorkerRoleFilter<$PrismaModel>
  }

  export type EnumWorkerSessionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkerSessionStatus | EnumWorkerSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkerSessionStatus[] | ListEnumWorkerSessionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkerSessionStatus[] | ListEnumWorkerSessionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkerSessionStatusFilter<$PrismaModel> | $Enums.WorkerSessionStatus
  }

  export type WorkerNullableRelationFilter = {
    is?: WorkerWhereInput | null
    isNot?: WorkerWhereInput | null
  }

  export type AutoApplicationRelationFilter = {
    is?: AutoApplicationWhereInput
    isNot?: AutoApplicationWhereInput
  }

  export type WorkerSessionCountOrderByAggregateInput = {
    id?: SortOrder
    workerId?: SortOrder
    autoApplicationId?: SortOrder
    status?: SortOrder
    browserSessionId?: SortOrder
    vncUrl?: SortOrder
    queuedAt?: SortOrder
    assignedAt?: SortOrder
    aiStartedAt?: SortOrder
    aiCompletedAt?: SortOrder
    submittedAt?: SortOrder
    completedAt?: SortOrder
    formData?: SortOrder
    screenshotUrl?: SortOrder
    workerNotes?: SortOrder
    failReason?: SortOrder
    skipReason?: SortOrder
  }

  export type WorkerSessionAvgOrderByAggregateInput = {
    workerId?: SortOrder
  }

  export type WorkerSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    workerId?: SortOrder
    autoApplicationId?: SortOrder
    status?: SortOrder
    browserSessionId?: SortOrder
    vncUrl?: SortOrder
    queuedAt?: SortOrder
    assignedAt?: SortOrder
    aiStartedAt?: SortOrder
    aiCompletedAt?: SortOrder
    submittedAt?: SortOrder
    completedAt?: SortOrder
    screenshotUrl?: SortOrder
    workerNotes?: SortOrder
    failReason?: SortOrder
    skipReason?: SortOrder
  }

  export type WorkerSessionMinOrderByAggregateInput = {
    id?: SortOrder
    workerId?: SortOrder
    autoApplicationId?: SortOrder
    status?: SortOrder
    browserSessionId?: SortOrder
    vncUrl?: SortOrder
    queuedAt?: SortOrder
    assignedAt?: SortOrder
    aiStartedAt?: SortOrder
    aiCompletedAt?: SortOrder
    submittedAt?: SortOrder
    completedAt?: SortOrder
    screenshotUrl?: SortOrder
    workerNotes?: SortOrder
    failReason?: SortOrder
    skipReason?: SortOrder
  }

  export type WorkerSessionSumOrderByAggregateInput = {
    workerId?: SortOrder
  }

  export type EnumWorkerSessionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkerSessionStatus | EnumWorkerSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkerSessionStatus[] | ListEnumWorkerSessionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkerSessionStatus[] | ListEnumWorkerSessionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkerSessionStatusWithAggregatesFilter<$PrismaModel> | $Enums.WorkerSessionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkerSessionStatusFilter<$PrismaModel>
    _max?: NestedEnumWorkerSessionStatusFilter<$PrismaModel>
  }

  export type JobCreateNestedManyWithoutUserInput = {
    create?: XOR<JobCreateWithoutUserInput, JobUncheckedCreateWithoutUserInput> | JobCreateWithoutUserInput[] | JobUncheckedCreateWithoutUserInput[]
    connectOrCreate?: JobCreateOrConnectWithoutUserInput | JobCreateOrConnectWithoutUserInput[]
    createMany?: JobCreateManyUserInputEnvelope
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
  }

  export type ProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    connect?: ProfileWhereUniqueInput
  }

  export type SubscriptionCreateNestedOneWithoutUserInput = {
    create?: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type UsageTrackingCreateNestedManyWithoutUserInput = {
    create?: XOR<UsageTrackingCreateWithoutUserInput, UsageTrackingUncheckedCreateWithoutUserInput> | UsageTrackingCreateWithoutUserInput[] | UsageTrackingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UsageTrackingCreateOrConnectWithoutUserInput | UsageTrackingCreateOrConnectWithoutUserInput[]
    createMany?: UsageTrackingCreateManyUserInputEnvelope
    connect?: UsageTrackingWhereUniqueInput | UsageTrackingWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutUserInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type AutoApplicationCreateNestedManyWithoutUserInput = {
    create?: XOR<AutoApplicationCreateWithoutUserInput, AutoApplicationUncheckedCreateWithoutUserInput> | AutoApplicationCreateWithoutUserInput[] | AutoApplicationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AutoApplicationCreateOrConnectWithoutUserInput | AutoApplicationCreateOrConnectWithoutUserInput[]
    createMany?: AutoApplicationCreateManyUserInputEnvelope
    connect?: AutoApplicationWhereUniqueInput | AutoApplicationWhereUniqueInput[]
  }

  export type ConversationCreateNestedManyWithoutUserInput = {
    create?: XOR<ConversationCreateWithoutUserInput, ConversationUncheckedCreateWithoutUserInput> | ConversationCreateWithoutUserInput[] | ConversationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutUserInput | ConversationCreateOrConnectWithoutUserInput[]
    createMany?: ConversationCreateManyUserInputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type GoalCreateNestedManyWithoutUserInput = {
    create?: XOR<GoalCreateWithoutUserInput, GoalUncheckedCreateWithoutUserInput> | GoalCreateWithoutUserInput[] | GoalUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GoalCreateOrConnectWithoutUserInput | GoalCreateOrConnectWithoutUserInput[]
    createMany?: GoalCreateManyUserInputEnvelope
    connect?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
  }

  export type RoutineCreateNestedManyWithoutUserInput = {
    create?: XOR<RoutineCreateWithoutUserInput, RoutineUncheckedCreateWithoutUserInput> | RoutineCreateWithoutUserInput[] | RoutineUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RoutineCreateOrConnectWithoutUserInput | RoutineCreateOrConnectWithoutUserInput[]
    createMany?: RoutineCreateManyUserInputEnvelope
    connect?: RoutineWhereUniqueInput | RoutineWhereUniqueInput[]
  }

  export type GmailConnectionCreateNestedOneWithoutUserInput = {
    create?: XOR<GmailConnectionCreateWithoutUserInput, GmailConnectionUncheckedCreateWithoutUserInput>
    connectOrCreate?: GmailConnectionCreateOrConnectWithoutUserInput
    connect?: GmailConnectionWhereUniqueInput
  }

  export type JobUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<JobCreateWithoutUserInput, JobUncheckedCreateWithoutUserInput> | JobCreateWithoutUserInput[] | JobUncheckedCreateWithoutUserInput[]
    connectOrCreate?: JobCreateOrConnectWithoutUserInput | JobCreateOrConnectWithoutUserInput[]
    createMany?: JobCreateManyUserInputEnvelope
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
  }

  export type ProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    connect?: ProfileWhereUniqueInput
  }

  export type SubscriptionUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type UsageTrackingUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UsageTrackingCreateWithoutUserInput, UsageTrackingUncheckedCreateWithoutUserInput> | UsageTrackingCreateWithoutUserInput[] | UsageTrackingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UsageTrackingCreateOrConnectWithoutUserInput | UsageTrackingCreateOrConnectWithoutUserInput[]
    createMany?: UsageTrackingCreateManyUserInputEnvelope
    connect?: UsageTrackingWhereUniqueInput | UsageTrackingWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type AutoApplicationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AutoApplicationCreateWithoutUserInput, AutoApplicationUncheckedCreateWithoutUserInput> | AutoApplicationCreateWithoutUserInput[] | AutoApplicationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AutoApplicationCreateOrConnectWithoutUserInput | AutoApplicationCreateOrConnectWithoutUserInput[]
    createMany?: AutoApplicationCreateManyUserInputEnvelope
    connect?: AutoApplicationWhereUniqueInput | AutoApplicationWhereUniqueInput[]
  }

  export type ConversationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ConversationCreateWithoutUserInput, ConversationUncheckedCreateWithoutUserInput> | ConversationCreateWithoutUserInput[] | ConversationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutUserInput | ConversationCreateOrConnectWithoutUserInput[]
    createMany?: ConversationCreateManyUserInputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type GoalUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<GoalCreateWithoutUserInput, GoalUncheckedCreateWithoutUserInput> | GoalCreateWithoutUserInput[] | GoalUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GoalCreateOrConnectWithoutUserInput | GoalCreateOrConnectWithoutUserInput[]
    createMany?: GoalCreateManyUserInputEnvelope
    connect?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
  }

  export type RoutineUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RoutineCreateWithoutUserInput, RoutineUncheckedCreateWithoutUserInput> | RoutineCreateWithoutUserInput[] | RoutineUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RoutineCreateOrConnectWithoutUserInput | RoutineCreateOrConnectWithoutUserInput[]
    createMany?: RoutineCreateManyUserInputEnvelope
    connect?: RoutineWhereUniqueInput | RoutineWhereUniqueInput[]
  }

  export type GmailConnectionUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<GmailConnectionCreateWithoutUserInput, GmailConnectionUncheckedCreateWithoutUserInput>
    connectOrCreate?: GmailConnectionCreateOrConnectWithoutUserInput
    connect?: GmailConnectionWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type JobUpdateManyWithoutUserNestedInput = {
    create?: XOR<JobCreateWithoutUserInput, JobUncheckedCreateWithoutUserInput> | JobCreateWithoutUserInput[] | JobUncheckedCreateWithoutUserInput[]
    connectOrCreate?: JobCreateOrConnectWithoutUserInput | JobCreateOrConnectWithoutUserInput[]
    upsert?: JobUpsertWithWhereUniqueWithoutUserInput | JobUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: JobCreateManyUserInputEnvelope
    set?: JobWhereUniqueInput | JobWhereUniqueInput[]
    disconnect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    delete?: JobWhereUniqueInput | JobWhereUniqueInput[]
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    update?: JobUpdateWithWhereUniqueWithoutUserInput | JobUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: JobUpdateManyWithWhereWithoutUserInput | JobUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: JobScalarWhereInput | JobScalarWhereInput[]
  }

  export type ProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    upsert?: ProfileUpsertWithoutUserInput
    disconnect?: ProfileWhereInput | boolean
    delete?: ProfileWhereInput | boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutUserInput, ProfileUpdateWithoutUserInput>, ProfileUncheckedUpdateWithoutUserInput>
  }

  export type SubscriptionUpdateOneWithoutUserNestedInput = {
    create?: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserInput
    upsert?: SubscriptionUpsertWithoutUserInput
    disconnect?: SubscriptionWhereInput | boolean
    delete?: SubscriptionWhereInput | boolean
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutUserInput, SubscriptionUpdateWithoutUserInput>, SubscriptionUncheckedUpdateWithoutUserInput>
  }

  export type UsageTrackingUpdateManyWithoutUserNestedInput = {
    create?: XOR<UsageTrackingCreateWithoutUserInput, UsageTrackingUncheckedCreateWithoutUserInput> | UsageTrackingCreateWithoutUserInput[] | UsageTrackingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UsageTrackingCreateOrConnectWithoutUserInput | UsageTrackingCreateOrConnectWithoutUserInput[]
    upsert?: UsageTrackingUpsertWithWhereUniqueWithoutUserInput | UsageTrackingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UsageTrackingCreateManyUserInputEnvelope
    set?: UsageTrackingWhereUniqueInput | UsageTrackingWhereUniqueInput[]
    disconnect?: UsageTrackingWhereUniqueInput | UsageTrackingWhereUniqueInput[]
    delete?: UsageTrackingWhereUniqueInput | UsageTrackingWhereUniqueInput[]
    connect?: UsageTrackingWhereUniqueInput | UsageTrackingWhereUniqueInput[]
    update?: UsageTrackingUpdateWithWhereUniqueWithoutUserInput | UsageTrackingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UsageTrackingUpdateManyWithWhereWithoutUserInput | UsageTrackingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UsageTrackingScalarWhereInput | UsageTrackingScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutUserNestedInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutUserInput | PaymentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutUserInput | PaymentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutUserInput | PaymentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type AutoApplicationUpdateManyWithoutUserNestedInput = {
    create?: XOR<AutoApplicationCreateWithoutUserInput, AutoApplicationUncheckedCreateWithoutUserInput> | AutoApplicationCreateWithoutUserInput[] | AutoApplicationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AutoApplicationCreateOrConnectWithoutUserInput | AutoApplicationCreateOrConnectWithoutUserInput[]
    upsert?: AutoApplicationUpsertWithWhereUniqueWithoutUserInput | AutoApplicationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AutoApplicationCreateManyUserInputEnvelope
    set?: AutoApplicationWhereUniqueInput | AutoApplicationWhereUniqueInput[]
    disconnect?: AutoApplicationWhereUniqueInput | AutoApplicationWhereUniqueInput[]
    delete?: AutoApplicationWhereUniqueInput | AutoApplicationWhereUniqueInput[]
    connect?: AutoApplicationWhereUniqueInput | AutoApplicationWhereUniqueInput[]
    update?: AutoApplicationUpdateWithWhereUniqueWithoutUserInput | AutoApplicationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AutoApplicationUpdateManyWithWhereWithoutUserInput | AutoApplicationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AutoApplicationScalarWhereInput | AutoApplicationScalarWhereInput[]
  }

  export type ConversationUpdateManyWithoutUserNestedInput = {
    create?: XOR<ConversationCreateWithoutUserInput, ConversationUncheckedCreateWithoutUserInput> | ConversationCreateWithoutUserInput[] | ConversationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutUserInput | ConversationCreateOrConnectWithoutUserInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutUserInput | ConversationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ConversationCreateManyUserInputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutUserInput | ConversationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutUserInput | ConversationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type GoalUpdateManyWithoutUserNestedInput = {
    create?: XOR<GoalCreateWithoutUserInput, GoalUncheckedCreateWithoutUserInput> | GoalCreateWithoutUserInput[] | GoalUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GoalCreateOrConnectWithoutUserInput | GoalCreateOrConnectWithoutUserInput[]
    upsert?: GoalUpsertWithWhereUniqueWithoutUserInput | GoalUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GoalCreateManyUserInputEnvelope
    set?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
    disconnect?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
    delete?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
    connect?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
    update?: GoalUpdateWithWhereUniqueWithoutUserInput | GoalUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GoalUpdateManyWithWhereWithoutUserInput | GoalUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GoalScalarWhereInput | GoalScalarWhereInput[]
  }

  export type RoutineUpdateManyWithoutUserNestedInput = {
    create?: XOR<RoutineCreateWithoutUserInput, RoutineUncheckedCreateWithoutUserInput> | RoutineCreateWithoutUserInput[] | RoutineUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RoutineCreateOrConnectWithoutUserInput | RoutineCreateOrConnectWithoutUserInput[]
    upsert?: RoutineUpsertWithWhereUniqueWithoutUserInput | RoutineUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RoutineCreateManyUserInputEnvelope
    set?: RoutineWhereUniqueInput | RoutineWhereUniqueInput[]
    disconnect?: RoutineWhereUniqueInput | RoutineWhereUniqueInput[]
    delete?: RoutineWhereUniqueInput | RoutineWhereUniqueInput[]
    connect?: RoutineWhereUniqueInput | RoutineWhereUniqueInput[]
    update?: RoutineUpdateWithWhereUniqueWithoutUserInput | RoutineUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RoutineUpdateManyWithWhereWithoutUserInput | RoutineUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RoutineScalarWhereInput | RoutineScalarWhereInput[]
  }

  export type GmailConnectionUpdateOneWithoutUserNestedInput = {
    create?: XOR<GmailConnectionCreateWithoutUserInput, GmailConnectionUncheckedCreateWithoutUserInput>
    connectOrCreate?: GmailConnectionCreateOrConnectWithoutUserInput
    upsert?: GmailConnectionUpsertWithoutUserInput
    disconnect?: GmailConnectionWhereInput | boolean
    delete?: GmailConnectionWhereInput | boolean
    connect?: GmailConnectionWhereUniqueInput
    update?: XOR<XOR<GmailConnectionUpdateToOneWithWhereWithoutUserInput, GmailConnectionUpdateWithoutUserInput>, GmailConnectionUncheckedUpdateWithoutUserInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type JobUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<JobCreateWithoutUserInput, JobUncheckedCreateWithoutUserInput> | JobCreateWithoutUserInput[] | JobUncheckedCreateWithoutUserInput[]
    connectOrCreate?: JobCreateOrConnectWithoutUserInput | JobCreateOrConnectWithoutUserInput[]
    upsert?: JobUpsertWithWhereUniqueWithoutUserInput | JobUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: JobCreateManyUserInputEnvelope
    set?: JobWhereUniqueInput | JobWhereUniqueInput[]
    disconnect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    delete?: JobWhereUniqueInput | JobWhereUniqueInput[]
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    update?: JobUpdateWithWhereUniqueWithoutUserInput | JobUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: JobUpdateManyWithWhereWithoutUserInput | JobUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: JobScalarWhereInput | JobScalarWhereInput[]
  }

  export type ProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    upsert?: ProfileUpsertWithoutUserInput
    disconnect?: ProfileWhereInput | boolean
    delete?: ProfileWhereInput | boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutUserInput, ProfileUpdateWithoutUserInput>, ProfileUncheckedUpdateWithoutUserInput>
  }

  export type SubscriptionUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserInput
    upsert?: SubscriptionUpsertWithoutUserInput
    disconnect?: SubscriptionWhereInput | boolean
    delete?: SubscriptionWhereInput | boolean
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutUserInput, SubscriptionUpdateWithoutUserInput>, SubscriptionUncheckedUpdateWithoutUserInput>
  }

  export type UsageTrackingUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UsageTrackingCreateWithoutUserInput, UsageTrackingUncheckedCreateWithoutUserInput> | UsageTrackingCreateWithoutUserInput[] | UsageTrackingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UsageTrackingCreateOrConnectWithoutUserInput | UsageTrackingCreateOrConnectWithoutUserInput[]
    upsert?: UsageTrackingUpsertWithWhereUniqueWithoutUserInput | UsageTrackingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UsageTrackingCreateManyUserInputEnvelope
    set?: UsageTrackingWhereUniqueInput | UsageTrackingWhereUniqueInput[]
    disconnect?: UsageTrackingWhereUniqueInput | UsageTrackingWhereUniqueInput[]
    delete?: UsageTrackingWhereUniqueInput | UsageTrackingWhereUniqueInput[]
    connect?: UsageTrackingWhereUniqueInput | UsageTrackingWhereUniqueInput[]
    update?: UsageTrackingUpdateWithWhereUniqueWithoutUserInput | UsageTrackingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UsageTrackingUpdateManyWithWhereWithoutUserInput | UsageTrackingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UsageTrackingScalarWhereInput | UsageTrackingScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutUserInput | PaymentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutUserInput | PaymentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutUserInput | PaymentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type AutoApplicationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AutoApplicationCreateWithoutUserInput, AutoApplicationUncheckedCreateWithoutUserInput> | AutoApplicationCreateWithoutUserInput[] | AutoApplicationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AutoApplicationCreateOrConnectWithoutUserInput | AutoApplicationCreateOrConnectWithoutUserInput[]
    upsert?: AutoApplicationUpsertWithWhereUniqueWithoutUserInput | AutoApplicationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AutoApplicationCreateManyUserInputEnvelope
    set?: AutoApplicationWhereUniqueInput | AutoApplicationWhereUniqueInput[]
    disconnect?: AutoApplicationWhereUniqueInput | AutoApplicationWhereUniqueInput[]
    delete?: AutoApplicationWhereUniqueInput | AutoApplicationWhereUniqueInput[]
    connect?: AutoApplicationWhereUniqueInput | AutoApplicationWhereUniqueInput[]
    update?: AutoApplicationUpdateWithWhereUniqueWithoutUserInput | AutoApplicationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AutoApplicationUpdateManyWithWhereWithoutUserInput | AutoApplicationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AutoApplicationScalarWhereInput | AutoApplicationScalarWhereInput[]
  }

  export type ConversationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ConversationCreateWithoutUserInput, ConversationUncheckedCreateWithoutUserInput> | ConversationCreateWithoutUserInput[] | ConversationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutUserInput | ConversationCreateOrConnectWithoutUserInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutUserInput | ConversationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ConversationCreateManyUserInputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutUserInput | ConversationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutUserInput | ConversationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type GoalUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<GoalCreateWithoutUserInput, GoalUncheckedCreateWithoutUserInput> | GoalCreateWithoutUserInput[] | GoalUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GoalCreateOrConnectWithoutUserInput | GoalCreateOrConnectWithoutUserInput[]
    upsert?: GoalUpsertWithWhereUniqueWithoutUserInput | GoalUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GoalCreateManyUserInputEnvelope
    set?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
    disconnect?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
    delete?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
    connect?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
    update?: GoalUpdateWithWhereUniqueWithoutUserInput | GoalUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GoalUpdateManyWithWhereWithoutUserInput | GoalUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GoalScalarWhereInput | GoalScalarWhereInput[]
  }

  export type RoutineUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RoutineCreateWithoutUserInput, RoutineUncheckedCreateWithoutUserInput> | RoutineCreateWithoutUserInput[] | RoutineUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RoutineCreateOrConnectWithoutUserInput | RoutineCreateOrConnectWithoutUserInput[]
    upsert?: RoutineUpsertWithWhereUniqueWithoutUserInput | RoutineUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RoutineCreateManyUserInputEnvelope
    set?: RoutineWhereUniqueInput | RoutineWhereUniqueInput[]
    disconnect?: RoutineWhereUniqueInput | RoutineWhereUniqueInput[]
    delete?: RoutineWhereUniqueInput | RoutineWhereUniqueInput[]
    connect?: RoutineWhereUniqueInput | RoutineWhereUniqueInput[]
    update?: RoutineUpdateWithWhereUniqueWithoutUserInput | RoutineUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RoutineUpdateManyWithWhereWithoutUserInput | RoutineUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RoutineScalarWhereInput | RoutineScalarWhereInput[]
  }

  export type GmailConnectionUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<GmailConnectionCreateWithoutUserInput, GmailConnectionUncheckedCreateWithoutUserInput>
    connectOrCreate?: GmailConnectionCreateOrConnectWithoutUserInput
    upsert?: GmailConnectionUpsertWithoutUserInput
    disconnect?: GmailConnectionWhereInput | boolean
    delete?: GmailConnectionWhereInput | boolean
    connect?: GmailConnectionWhereUniqueInput
    update?: XOR<XOR<GmailConnectionUpdateToOneWithWhereWithoutUserInput, GmailConnectionUpdateWithoutUserInput>, GmailConnectionUncheckedUpdateWithoutUserInput>
  }

  export type UserCreateNestedOneWithoutGmailConnectionInput = {
    create?: XOR<UserCreateWithoutGmailConnectionInput, UserUncheckedCreateWithoutGmailConnectionInput>
    connectOrCreate?: UserCreateOrConnectWithoutGmailConnectionInput
    connect?: UserWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserUpdateOneRequiredWithoutGmailConnectionNestedInput = {
    create?: XOR<UserCreateWithoutGmailConnectionInput, UserUncheckedCreateWithoutGmailConnectionInput>
    connectOrCreate?: UserCreateOrConnectWithoutGmailConnectionInput
    upsert?: UserUpsertWithoutGmailConnectionInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutGmailConnectionInput, UserUpdateWithoutGmailConnectionInput>, UserUncheckedUpdateWithoutGmailConnectionInput>
  }

  export type UserCreateNestedOneWithoutProfileInput = {
    create?: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutProfileNestedInput = {
    create?: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileInput
    upsert?: UserUpsertWithoutProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProfileInput, UserUpdateWithoutProfileInput>, UserUncheckedUpdateWithoutProfileInput>
  }

  export type JobCreateprocessingLogInput = {
    set: InputJsonValue[]
  }

  export type ArtifactCreateNestedManyWithoutJobInput = {
    create?: XOR<ArtifactCreateWithoutJobInput, ArtifactUncheckedCreateWithoutJobInput> | ArtifactCreateWithoutJobInput[] | ArtifactUncheckedCreateWithoutJobInput[]
    connectOrCreate?: ArtifactCreateOrConnectWithoutJobInput | ArtifactCreateOrConnectWithoutJobInput[]
    createMany?: ArtifactCreateManyJobInputEnvelope
    connect?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
  }

  export type EmbeddingCreateNestedManyWithoutJobInput = {
    create?: XOR<EmbeddingCreateWithoutJobInput, EmbeddingUncheckedCreateWithoutJobInput> | EmbeddingCreateWithoutJobInput[] | EmbeddingUncheckedCreateWithoutJobInput[]
    connectOrCreate?: EmbeddingCreateOrConnectWithoutJobInput | EmbeddingCreateOrConnectWithoutJobInput[]
    createMany?: EmbeddingCreateManyJobInputEnvelope
    connect?: EmbeddingWhereUniqueInput | EmbeddingWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutJobsInput = {
    create?: XOR<UserCreateWithoutJobsInput, UserUncheckedCreateWithoutJobsInput>
    connectOrCreate?: UserCreateOrConnectWithoutJobsInput
    connect?: UserWhereUniqueInput
  }

  export type ArtifactUncheckedCreateNestedManyWithoutJobInput = {
    create?: XOR<ArtifactCreateWithoutJobInput, ArtifactUncheckedCreateWithoutJobInput> | ArtifactCreateWithoutJobInput[] | ArtifactUncheckedCreateWithoutJobInput[]
    connectOrCreate?: ArtifactCreateOrConnectWithoutJobInput | ArtifactCreateOrConnectWithoutJobInput[]
    createMany?: ArtifactCreateManyJobInputEnvelope
    connect?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
  }

  export type EmbeddingUncheckedCreateNestedManyWithoutJobInput = {
    create?: XOR<EmbeddingCreateWithoutJobInput, EmbeddingUncheckedCreateWithoutJobInput> | EmbeddingCreateWithoutJobInput[] | EmbeddingUncheckedCreateWithoutJobInput[]
    connectOrCreate?: EmbeddingCreateOrConnectWithoutJobInput | EmbeddingCreateOrConnectWithoutJobInput[]
    createMany?: EmbeddingCreateManyJobInputEnvelope
    connect?: EmbeddingWhereUniqueInput | EmbeddingWhereUniqueInput[]
  }

  export type EnumJobStatusFieldUpdateOperationsInput = {
    set?: $Enums.JobStatus
  }

  export type JobUpdateprocessingLogInput = {
    set?: InputJsonValue[]
    push?: InputJsonValue | InputJsonValue[]
  }

  export type ArtifactUpdateManyWithoutJobNestedInput = {
    create?: XOR<ArtifactCreateWithoutJobInput, ArtifactUncheckedCreateWithoutJobInput> | ArtifactCreateWithoutJobInput[] | ArtifactUncheckedCreateWithoutJobInput[]
    connectOrCreate?: ArtifactCreateOrConnectWithoutJobInput | ArtifactCreateOrConnectWithoutJobInput[]
    upsert?: ArtifactUpsertWithWhereUniqueWithoutJobInput | ArtifactUpsertWithWhereUniqueWithoutJobInput[]
    createMany?: ArtifactCreateManyJobInputEnvelope
    set?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
    disconnect?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
    delete?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
    connect?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
    update?: ArtifactUpdateWithWhereUniqueWithoutJobInput | ArtifactUpdateWithWhereUniqueWithoutJobInput[]
    updateMany?: ArtifactUpdateManyWithWhereWithoutJobInput | ArtifactUpdateManyWithWhereWithoutJobInput[]
    deleteMany?: ArtifactScalarWhereInput | ArtifactScalarWhereInput[]
  }

  export type EmbeddingUpdateManyWithoutJobNestedInput = {
    create?: XOR<EmbeddingCreateWithoutJobInput, EmbeddingUncheckedCreateWithoutJobInput> | EmbeddingCreateWithoutJobInput[] | EmbeddingUncheckedCreateWithoutJobInput[]
    connectOrCreate?: EmbeddingCreateOrConnectWithoutJobInput | EmbeddingCreateOrConnectWithoutJobInput[]
    upsert?: EmbeddingUpsertWithWhereUniqueWithoutJobInput | EmbeddingUpsertWithWhereUniqueWithoutJobInput[]
    createMany?: EmbeddingCreateManyJobInputEnvelope
    set?: EmbeddingWhereUniqueInput | EmbeddingWhereUniqueInput[]
    disconnect?: EmbeddingWhereUniqueInput | EmbeddingWhereUniqueInput[]
    delete?: EmbeddingWhereUniqueInput | EmbeddingWhereUniqueInput[]
    connect?: EmbeddingWhereUniqueInput | EmbeddingWhereUniqueInput[]
    update?: EmbeddingUpdateWithWhereUniqueWithoutJobInput | EmbeddingUpdateWithWhereUniqueWithoutJobInput[]
    updateMany?: EmbeddingUpdateManyWithWhereWithoutJobInput | EmbeddingUpdateManyWithWhereWithoutJobInput[]
    deleteMany?: EmbeddingScalarWhereInput | EmbeddingScalarWhereInput[]
  }

  export type UserUpdateOneWithoutJobsNestedInput = {
    create?: XOR<UserCreateWithoutJobsInput, UserUncheckedCreateWithoutJobsInput>
    connectOrCreate?: UserCreateOrConnectWithoutJobsInput
    upsert?: UserUpsertWithoutJobsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutJobsInput, UserUpdateWithoutJobsInput>, UserUncheckedUpdateWithoutJobsInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ArtifactUncheckedUpdateManyWithoutJobNestedInput = {
    create?: XOR<ArtifactCreateWithoutJobInput, ArtifactUncheckedCreateWithoutJobInput> | ArtifactCreateWithoutJobInput[] | ArtifactUncheckedCreateWithoutJobInput[]
    connectOrCreate?: ArtifactCreateOrConnectWithoutJobInput | ArtifactCreateOrConnectWithoutJobInput[]
    upsert?: ArtifactUpsertWithWhereUniqueWithoutJobInput | ArtifactUpsertWithWhereUniqueWithoutJobInput[]
    createMany?: ArtifactCreateManyJobInputEnvelope
    set?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
    disconnect?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
    delete?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
    connect?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
    update?: ArtifactUpdateWithWhereUniqueWithoutJobInput | ArtifactUpdateWithWhereUniqueWithoutJobInput[]
    updateMany?: ArtifactUpdateManyWithWhereWithoutJobInput | ArtifactUpdateManyWithWhereWithoutJobInput[]
    deleteMany?: ArtifactScalarWhereInput | ArtifactScalarWhereInput[]
  }

  export type EmbeddingUncheckedUpdateManyWithoutJobNestedInput = {
    create?: XOR<EmbeddingCreateWithoutJobInput, EmbeddingUncheckedCreateWithoutJobInput> | EmbeddingCreateWithoutJobInput[] | EmbeddingUncheckedCreateWithoutJobInput[]
    connectOrCreate?: EmbeddingCreateOrConnectWithoutJobInput | EmbeddingCreateOrConnectWithoutJobInput[]
    upsert?: EmbeddingUpsertWithWhereUniqueWithoutJobInput | EmbeddingUpsertWithWhereUniqueWithoutJobInput[]
    createMany?: EmbeddingCreateManyJobInputEnvelope
    set?: EmbeddingWhereUniqueInput | EmbeddingWhereUniqueInput[]
    disconnect?: EmbeddingWhereUniqueInput | EmbeddingWhereUniqueInput[]
    delete?: EmbeddingWhereUniqueInput | EmbeddingWhereUniqueInput[]
    connect?: EmbeddingWhereUniqueInput | EmbeddingWhereUniqueInput[]
    update?: EmbeddingUpdateWithWhereUniqueWithoutJobInput | EmbeddingUpdateWithWhereUniqueWithoutJobInput[]
    updateMany?: EmbeddingUpdateManyWithWhereWithoutJobInput | EmbeddingUpdateManyWithWhereWithoutJobInput[]
    deleteMany?: EmbeddingScalarWhereInput | EmbeddingScalarWhereInput[]
  }

  export type JobCreateNestedOneWithoutArtifactsInput = {
    create?: XOR<JobCreateWithoutArtifactsInput, JobUncheckedCreateWithoutArtifactsInput>
    connectOrCreate?: JobCreateOrConnectWithoutArtifactsInput
    connect?: JobWhereUniqueInput
  }

  export type EnumArtifactTypeFieldUpdateOperationsInput = {
    set?: $Enums.ArtifactType
  }

  export type BytesFieldUpdateOperationsInput = {
    set?: Buffer
  }

  export type JobUpdateOneRequiredWithoutArtifactsNestedInput = {
    create?: XOR<JobCreateWithoutArtifactsInput, JobUncheckedCreateWithoutArtifactsInput>
    connectOrCreate?: JobCreateOrConnectWithoutArtifactsInput
    upsert?: JobUpsertWithoutArtifactsInput
    connect?: JobWhereUniqueInput
    update?: XOR<XOR<JobUpdateToOneWithWhereWithoutArtifactsInput, JobUpdateWithoutArtifactsInput>, JobUncheckedUpdateWithoutArtifactsInput>
  }

  export type EmbeddingCreateembeddingInput = {
    set: number[]
  }

  export type JobCreateNestedOneWithoutEmbeddingsInput = {
    create?: XOR<JobCreateWithoutEmbeddingsInput, JobUncheckedCreateWithoutEmbeddingsInput>
    connectOrCreate?: JobCreateOrConnectWithoutEmbeddingsInput
    connect?: JobWhereUniqueInput
  }

  export type EnumEmbeddingTypeFieldUpdateOperationsInput = {
    set?: $Enums.EmbeddingType
  }

  export type EmbeddingUpdateembeddingInput = {
    set?: number[]
    push?: number | number[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type JobUpdateOneRequiredWithoutEmbeddingsNestedInput = {
    create?: XOR<JobCreateWithoutEmbeddingsInput, JobUncheckedCreateWithoutEmbeddingsInput>
    connectOrCreate?: JobCreateOrConnectWithoutEmbeddingsInput
    upsert?: JobUpsertWithoutEmbeddingsInput
    connect?: JobWhereUniqueInput
    update?: XOR<XOR<JobUpdateToOneWithWhereWithoutEmbeddingsInput, JobUpdateWithoutEmbeddingsInput>, JobUncheckedUpdateWithoutEmbeddingsInput>
  }

  export type UserCreateNestedOneWithoutSubscriptionInput = {
    create?: XOR<UserCreateWithoutSubscriptionInput, UserUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubscriptionInput
    connect?: UserWhereUniqueInput
  }

  export type EnumSubscriptionTierFieldUpdateOperationsInput = {
    set?: $Enums.SubscriptionTier
  }

  export type EnumSubscriptionStatusFieldUpdateOperationsInput = {
    set?: $Enums.SubscriptionStatus
  }

  export type UserUpdateOneRequiredWithoutSubscriptionNestedInput = {
    create?: XOR<UserCreateWithoutSubscriptionInput, UserUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubscriptionInput
    upsert?: UserUpsertWithoutSubscriptionInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSubscriptionInput, UserUpdateWithoutSubscriptionInput>, UserUncheckedUpdateWithoutSubscriptionInput>
  }

  export type UserCreateNestedOneWithoutUsageTrackingInput = {
    create?: XOR<UserCreateWithoutUsageTrackingInput, UserUncheckedCreateWithoutUsageTrackingInput>
    connectOrCreate?: UserCreateOrConnectWithoutUsageTrackingInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUsageTrackingNestedInput = {
    create?: XOR<UserCreateWithoutUsageTrackingInput, UserUncheckedCreateWithoutUsageTrackingInput>
    connectOrCreate?: UserCreateOrConnectWithoutUsageTrackingInput
    upsert?: UserUpsertWithoutUsageTrackingInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUsageTrackingInput, UserUpdateWithoutUsageTrackingInput>, UserUncheckedUpdateWithoutUsageTrackingInput>
  }

  export type UserCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumPaymentStatusFieldUpdateOperationsInput = {
    set?: $Enums.PaymentStatus
  }

  export type UserUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentsInput
    upsert?: UserUpsertWithoutPaymentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPaymentsInput, UserUpdateWithoutPaymentsInput>, UserUncheckedUpdateWithoutPaymentsInput>
  }

  export type AggregatedJobCreateextractedSkillsInput = {
    set: string[]
  }

  export type AggregatedJobCreateextractedKeywordsInput = {
    set: string[]
  }

  export type AggregatedJobCreateextractedBenefitsInput = {
    set: string[]
  }

  export type AutoApplicationCreateNestedManyWithoutJobInput = {
    create?: XOR<AutoApplicationCreateWithoutJobInput, AutoApplicationUncheckedCreateWithoutJobInput> | AutoApplicationCreateWithoutJobInput[] | AutoApplicationUncheckedCreateWithoutJobInput[]
    connectOrCreate?: AutoApplicationCreateOrConnectWithoutJobInput | AutoApplicationCreateOrConnectWithoutJobInput[]
    createMany?: AutoApplicationCreateManyJobInputEnvelope
    connect?: AutoApplicationWhereUniqueInput | AutoApplicationWhereUniqueInput[]
  }

  export type AutoApplicationUncheckedCreateNestedManyWithoutJobInput = {
    create?: XOR<AutoApplicationCreateWithoutJobInput, AutoApplicationUncheckedCreateWithoutJobInput> | AutoApplicationCreateWithoutJobInput[] | AutoApplicationUncheckedCreateWithoutJobInput[]
    connectOrCreate?: AutoApplicationCreateOrConnectWithoutJobInput | AutoApplicationCreateOrConnectWithoutJobInput[]
    createMany?: AutoApplicationCreateManyJobInputEnvelope
    connect?: AutoApplicationWhereUniqueInput | AutoApplicationWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AggregatedJobUpdateextractedSkillsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type AggregatedJobUpdateextractedKeywordsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type AggregatedJobUpdateextractedBenefitsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type AutoApplicationUpdateManyWithoutJobNestedInput = {
    create?: XOR<AutoApplicationCreateWithoutJobInput, AutoApplicationUncheckedCreateWithoutJobInput> | AutoApplicationCreateWithoutJobInput[] | AutoApplicationUncheckedCreateWithoutJobInput[]
    connectOrCreate?: AutoApplicationCreateOrConnectWithoutJobInput | AutoApplicationCreateOrConnectWithoutJobInput[]
    upsert?: AutoApplicationUpsertWithWhereUniqueWithoutJobInput | AutoApplicationUpsertWithWhereUniqueWithoutJobInput[]
    createMany?: AutoApplicationCreateManyJobInputEnvelope
    set?: AutoApplicationWhereUniqueInput | AutoApplicationWhereUniqueInput[]
    disconnect?: AutoApplicationWhereUniqueInput | AutoApplicationWhereUniqueInput[]
    delete?: AutoApplicationWhereUniqueInput | AutoApplicationWhereUniqueInput[]
    connect?: AutoApplicationWhereUniqueInput | AutoApplicationWhereUniqueInput[]
    update?: AutoApplicationUpdateWithWhereUniqueWithoutJobInput | AutoApplicationUpdateWithWhereUniqueWithoutJobInput[]
    updateMany?: AutoApplicationUpdateManyWithWhereWithoutJobInput | AutoApplicationUpdateManyWithWhereWithoutJobInput[]
    deleteMany?: AutoApplicationScalarWhereInput | AutoApplicationScalarWhereInput[]
  }

  export type AutoApplicationUncheckedUpdateManyWithoutJobNestedInput = {
    create?: XOR<AutoApplicationCreateWithoutJobInput, AutoApplicationUncheckedCreateWithoutJobInput> | AutoApplicationCreateWithoutJobInput[] | AutoApplicationUncheckedCreateWithoutJobInput[]
    connectOrCreate?: AutoApplicationCreateOrConnectWithoutJobInput | AutoApplicationCreateOrConnectWithoutJobInput[]
    upsert?: AutoApplicationUpsertWithWhereUniqueWithoutJobInput | AutoApplicationUpsertWithWhereUniqueWithoutJobInput[]
    createMany?: AutoApplicationCreateManyJobInputEnvelope
    set?: AutoApplicationWhereUniqueInput | AutoApplicationWhereUniqueInput[]
    disconnect?: AutoApplicationWhereUniqueInput | AutoApplicationWhereUniqueInput[]
    delete?: AutoApplicationWhereUniqueInput | AutoApplicationWhereUniqueInput[]
    connect?: AutoApplicationWhereUniqueInput | AutoApplicationWhereUniqueInput[]
    update?: AutoApplicationUpdateWithWhereUniqueWithoutJobInput | AutoApplicationUpdateWithWhereUniqueWithoutJobInput[]
    updateMany?: AutoApplicationUpdateManyWithWhereWithoutJobInput | AutoApplicationUpdateManyWithWhereWithoutJobInput[]
    deleteMany?: AutoApplicationScalarWhereInput | AutoApplicationScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAutoApplicationsInput = {
    create?: XOR<UserCreateWithoutAutoApplicationsInput, UserUncheckedCreateWithoutAutoApplicationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAutoApplicationsInput
    connect?: UserWhereUniqueInput
  }

  export type AggregatedJobCreateNestedOneWithoutApplicationsInput = {
    create?: XOR<AggregatedJobCreateWithoutApplicationsInput, AggregatedJobUncheckedCreateWithoutApplicationsInput>
    connectOrCreate?: AggregatedJobCreateOrConnectWithoutApplicationsInput
    connect?: AggregatedJobWhereUniqueInput
  }

  export type WorkerSessionCreateNestedOneWithoutAutoApplicationInput = {
    create?: XOR<WorkerSessionCreateWithoutAutoApplicationInput, WorkerSessionUncheckedCreateWithoutAutoApplicationInput>
    connectOrCreate?: WorkerSessionCreateOrConnectWithoutAutoApplicationInput
    connect?: WorkerSessionWhereUniqueInput
  }

  export type WorkerSessionUncheckedCreateNestedOneWithoutAutoApplicationInput = {
    create?: XOR<WorkerSessionCreateWithoutAutoApplicationInput, WorkerSessionUncheckedCreateWithoutAutoApplicationInput>
    connectOrCreate?: WorkerSessionCreateOrConnectWithoutAutoApplicationInput
    connect?: WorkerSessionWhereUniqueInput
  }

  export type EnumAutoApplicationStatusFieldUpdateOperationsInput = {
    set?: $Enums.AutoApplicationStatus
  }

  export type UserUpdateOneRequiredWithoutAutoApplicationsNestedInput = {
    create?: XOR<UserCreateWithoutAutoApplicationsInput, UserUncheckedCreateWithoutAutoApplicationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAutoApplicationsInput
    upsert?: UserUpsertWithoutAutoApplicationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAutoApplicationsInput, UserUpdateWithoutAutoApplicationsInput>, UserUncheckedUpdateWithoutAutoApplicationsInput>
  }

  export type AggregatedJobUpdateOneRequiredWithoutApplicationsNestedInput = {
    create?: XOR<AggregatedJobCreateWithoutApplicationsInput, AggregatedJobUncheckedCreateWithoutApplicationsInput>
    connectOrCreate?: AggregatedJobCreateOrConnectWithoutApplicationsInput
    upsert?: AggregatedJobUpsertWithoutApplicationsInput
    connect?: AggregatedJobWhereUniqueInput
    update?: XOR<XOR<AggregatedJobUpdateToOneWithWhereWithoutApplicationsInput, AggregatedJobUpdateWithoutApplicationsInput>, AggregatedJobUncheckedUpdateWithoutApplicationsInput>
  }

  export type WorkerSessionUpdateOneWithoutAutoApplicationNestedInput = {
    create?: XOR<WorkerSessionCreateWithoutAutoApplicationInput, WorkerSessionUncheckedCreateWithoutAutoApplicationInput>
    connectOrCreate?: WorkerSessionCreateOrConnectWithoutAutoApplicationInput
    upsert?: WorkerSessionUpsertWithoutAutoApplicationInput
    disconnect?: WorkerSessionWhereInput | boolean
    delete?: WorkerSessionWhereInput | boolean
    connect?: WorkerSessionWhereUniqueInput
    update?: XOR<XOR<WorkerSessionUpdateToOneWithWhereWithoutAutoApplicationInput, WorkerSessionUpdateWithoutAutoApplicationInput>, WorkerSessionUncheckedUpdateWithoutAutoApplicationInput>
  }

  export type WorkerSessionUncheckedUpdateOneWithoutAutoApplicationNestedInput = {
    create?: XOR<WorkerSessionCreateWithoutAutoApplicationInput, WorkerSessionUncheckedCreateWithoutAutoApplicationInput>
    connectOrCreate?: WorkerSessionCreateOrConnectWithoutAutoApplicationInput
    upsert?: WorkerSessionUpsertWithoutAutoApplicationInput
    disconnect?: WorkerSessionWhereInput | boolean
    delete?: WorkerSessionWhereInput | boolean
    connect?: WorkerSessionWhereUniqueInput
    update?: XOR<XOR<WorkerSessionUpdateToOneWithWhereWithoutAutoApplicationInput, WorkerSessionUpdateWithoutAutoApplicationInput>, WorkerSessionUncheckedUpdateWithoutAutoApplicationInput>
  }

  export type RecipeExecutionCreateNestedManyWithoutRecipeInput = {
    create?: XOR<RecipeExecutionCreateWithoutRecipeInput, RecipeExecutionUncheckedCreateWithoutRecipeInput> | RecipeExecutionCreateWithoutRecipeInput[] | RecipeExecutionUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: RecipeExecutionCreateOrConnectWithoutRecipeInput | RecipeExecutionCreateOrConnectWithoutRecipeInput[]
    createMany?: RecipeExecutionCreateManyRecipeInputEnvelope
    connect?: RecipeExecutionWhereUniqueInput | RecipeExecutionWhereUniqueInput[]
  }

  export type RecipeExecutionUncheckedCreateNestedManyWithoutRecipeInput = {
    create?: XOR<RecipeExecutionCreateWithoutRecipeInput, RecipeExecutionUncheckedCreateWithoutRecipeInput> | RecipeExecutionCreateWithoutRecipeInput[] | RecipeExecutionUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: RecipeExecutionCreateOrConnectWithoutRecipeInput | RecipeExecutionCreateOrConnectWithoutRecipeInput[]
    createMany?: RecipeExecutionCreateManyRecipeInputEnvelope
    connect?: RecipeExecutionWhereUniqueInput | RecipeExecutionWhereUniqueInput[]
  }

  export type RecipeExecutionUpdateManyWithoutRecipeNestedInput = {
    create?: XOR<RecipeExecutionCreateWithoutRecipeInput, RecipeExecutionUncheckedCreateWithoutRecipeInput> | RecipeExecutionCreateWithoutRecipeInput[] | RecipeExecutionUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: RecipeExecutionCreateOrConnectWithoutRecipeInput | RecipeExecutionCreateOrConnectWithoutRecipeInput[]
    upsert?: RecipeExecutionUpsertWithWhereUniqueWithoutRecipeInput | RecipeExecutionUpsertWithWhereUniqueWithoutRecipeInput[]
    createMany?: RecipeExecutionCreateManyRecipeInputEnvelope
    set?: RecipeExecutionWhereUniqueInput | RecipeExecutionWhereUniqueInput[]
    disconnect?: RecipeExecutionWhereUniqueInput | RecipeExecutionWhereUniqueInput[]
    delete?: RecipeExecutionWhereUniqueInput | RecipeExecutionWhereUniqueInput[]
    connect?: RecipeExecutionWhereUniqueInput | RecipeExecutionWhereUniqueInput[]
    update?: RecipeExecutionUpdateWithWhereUniqueWithoutRecipeInput | RecipeExecutionUpdateWithWhereUniqueWithoutRecipeInput[]
    updateMany?: RecipeExecutionUpdateManyWithWhereWithoutRecipeInput | RecipeExecutionUpdateManyWithWhereWithoutRecipeInput[]
    deleteMany?: RecipeExecutionScalarWhereInput | RecipeExecutionScalarWhereInput[]
  }

  export type RecipeExecutionUncheckedUpdateManyWithoutRecipeNestedInput = {
    create?: XOR<RecipeExecutionCreateWithoutRecipeInput, RecipeExecutionUncheckedCreateWithoutRecipeInput> | RecipeExecutionCreateWithoutRecipeInput[] | RecipeExecutionUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: RecipeExecutionCreateOrConnectWithoutRecipeInput | RecipeExecutionCreateOrConnectWithoutRecipeInput[]
    upsert?: RecipeExecutionUpsertWithWhereUniqueWithoutRecipeInput | RecipeExecutionUpsertWithWhereUniqueWithoutRecipeInput[]
    createMany?: RecipeExecutionCreateManyRecipeInputEnvelope
    set?: RecipeExecutionWhereUniqueInput | RecipeExecutionWhereUniqueInput[]
    disconnect?: RecipeExecutionWhereUniqueInput | RecipeExecutionWhereUniqueInput[]
    delete?: RecipeExecutionWhereUniqueInput | RecipeExecutionWhereUniqueInput[]
    connect?: RecipeExecutionWhereUniqueInput | RecipeExecutionWhereUniqueInput[]
    update?: RecipeExecutionUpdateWithWhereUniqueWithoutRecipeInput | RecipeExecutionUpdateWithWhereUniqueWithoutRecipeInput[]
    updateMany?: RecipeExecutionUpdateManyWithWhereWithoutRecipeInput | RecipeExecutionUpdateManyWithWhereWithoutRecipeInput[]
    deleteMany?: RecipeExecutionScalarWhereInput | RecipeExecutionScalarWhereInput[]
  }

  export type ApplicationRecipeCreateNestedOneWithoutExecutionsInput = {
    create?: XOR<ApplicationRecipeCreateWithoutExecutionsInput, ApplicationRecipeUncheckedCreateWithoutExecutionsInput>
    connectOrCreate?: ApplicationRecipeCreateOrConnectWithoutExecutionsInput
    connect?: ApplicationRecipeWhereUniqueInput
  }

  export type ApplicationRecipeUpdateOneRequiredWithoutExecutionsNestedInput = {
    create?: XOR<ApplicationRecipeCreateWithoutExecutionsInput, ApplicationRecipeUncheckedCreateWithoutExecutionsInput>
    connectOrCreate?: ApplicationRecipeCreateOrConnectWithoutExecutionsInput
    upsert?: ApplicationRecipeUpsertWithoutExecutionsInput
    connect?: ApplicationRecipeWhereUniqueInput
    update?: XOR<XOR<ApplicationRecipeUpdateToOneWithWhereWithoutExecutionsInput, ApplicationRecipeUpdateWithoutExecutionsInput>, ApplicationRecipeUncheckedUpdateWithoutExecutionsInput>
  }

  export type MessageCreateNestedManyWithoutConversationInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type GoalCreateNestedManyWithoutConversationInput = {
    create?: XOR<GoalCreateWithoutConversationInput, GoalUncheckedCreateWithoutConversationInput> | GoalCreateWithoutConversationInput[] | GoalUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: GoalCreateOrConnectWithoutConversationInput | GoalCreateOrConnectWithoutConversationInput[]
    createMany?: GoalCreateManyConversationInputEnvelope
    connect?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutConversationsInput = {
    create?: XOR<UserCreateWithoutConversationsInput, UserUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutConversationsInput
    connect?: UserWhereUniqueInput
  }

  export type MessageUncheckedCreateNestedManyWithoutConversationInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type GoalUncheckedCreateNestedManyWithoutConversationInput = {
    create?: XOR<GoalCreateWithoutConversationInput, GoalUncheckedCreateWithoutConversationInput> | GoalCreateWithoutConversationInput[] | GoalUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: GoalCreateOrConnectWithoutConversationInput | GoalCreateOrConnectWithoutConversationInput[]
    createMany?: GoalCreateManyConversationInputEnvelope
    connect?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
  }

  export type MessageUpdateManyWithoutConversationNestedInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutConversationInput | MessageUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutConversationInput | MessageUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutConversationInput | MessageUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type GoalUpdateManyWithoutConversationNestedInput = {
    create?: XOR<GoalCreateWithoutConversationInput, GoalUncheckedCreateWithoutConversationInput> | GoalCreateWithoutConversationInput[] | GoalUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: GoalCreateOrConnectWithoutConversationInput | GoalCreateOrConnectWithoutConversationInput[]
    upsert?: GoalUpsertWithWhereUniqueWithoutConversationInput | GoalUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: GoalCreateManyConversationInputEnvelope
    set?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
    disconnect?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
    delete?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
    connect?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
    update?: GoalUpdateWithWhereUniqueWithoutConversationInput | GoalUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: GoalUpdateManyWithWhereWithoutConversationInput | GoalUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: GoalScalarWhereInput | GoalScalarWhereInput[]
  }

  export type UserUpdateOneWithoutConversationsNestedInput = {
    create?: XOR<UserCreateWithoutConversationsInput, UserUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutConversationsInput
    upsert?: UserUpsertWithoutConversationsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutConversationsInput, UserUpdateWithoutConversationsInput>, UserUncheckedUpdateWithoutConversationsInput>
  }

  export type MessageUncheckedUpdateManyWithoutConversationNestedInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutConversationInput | MessageUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutConversationInput | MessageUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutConversationInput | MessageUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type GoalUncheckedUpdateManyWithoutConversationNestedInput = {
    create?: XOR<GoalCreateWithoutConversationInput, GoalUncheckedCreateWithoutConversationInput> | GoalCreateWithoutConversationInput[] | GoalUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: GoalCreateOrConnectWithoutConversationInput | GoalCreateOrConnectWithoutConversationInput[]
    upsert?: GoalUpsertWithWhereUniqueWithoutConversationInput | GoalUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: GoalCreateManyConversationInputEnvelope
    set?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
    disconnect?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
    delete?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
    connect?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
    update?: GoalUpdateWithWhereUniqueWithoutConversationInput | GoalUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: GoalUpdateManyWithWhereWithoutConversationInput | GoalUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: GoalScalarWhereInput | GoalScalarWhereInput[]
  }

  export type ConversationCreateNestedOneWithoutMessagesInput = {
    create?: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutMessagesInput
    connect?: ConversationWhereUniqueInput
  }

  export type EnumMessageRoleFieldUpdateOperationsInput = {
    set?: $Enums.MessageRole
  }

  export type ConversationUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutMessagesInput
    upsert?: ConversationUpsertWithoutMessagesInput
    connect?: ConversationWhereUniqueInput
    update?: XOR<XOR<ConversationUpdateToOneWithWhereWithoutMessagesInput, ConversationUpdateWithoutMessagesInput>, ConversationUncheckedUpdateWithoutMessagesInput>
  }

  export type ConversationCreateNestedOneWithoutGoalsInput = {
    create?: XOR<ConversationCreateWithoutGoalsInput, ConversationUncheckedCreateWithoutGoalsInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutGoalsInput
    connect?: ConversationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutGoalsInput = {
    create?: XOR<UserCreateWithoutGoalsInput, UserUncheckedCreateWithoutGoalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutGoalsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumGoalTypeFieldUpdateOperationsInput = {
    set?: $Enums.GoalType
  }

  export type EnumGoalStatusFieldUpdateOperationsInput = {
    set?: $Enums.GoalStatus
  }

  export type ConversationUpdateOneWithoutGoalsNestedInput = {
    create?: XOR<ConversationCreateWithoutGoalsInput, ConversationUncheckedCreateWithoutGoalsInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutGoalsInput
    upsert?: ConversationUpsertWithoutGoalsInput
    disconnect?: ConversationWhereInput | boolean
    delete?: ConversationWhereInput | boolean
    connect?: ConversationWhereUniqueInput
    update?: XOR<XOR<ConversationUpdateToOneWithWhereWithoutGoalsInput, ConversationUpdateWithoutGoalsInput>, ConversationUncheckedUpdateWithoutGoalsInput>
  }

  export type UserUpdateOneRequiredWithoutGoalsNestedInput = {
    create?: XOR<UserCreateWithoutGoalsInput, UserUncheckedCreateWithoutGoalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutGoalsInput
    upsert?: UserUpsertWithoutGoalsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutGoalsInput, UserUpdateWithoutGoalsInput>, UserUncheckedUpdateWithoutGoalsInput>
  }

  export type UserCreateNestedOneWithoutRoutinesInput = {
    create?: XOR<UserCreateWithoutRoutinesInput, UserUncheckedCreateWithoutRoutinesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRoutinesInput
    connect?: UserWhereUniqueInput
  }

  export type RoutineExecutionCreateNestedManyWithoutRoutineInput = {
    create?: XOR<RoutineExecutionCreateWithoutRoutineInput, RoutineExecutionUncheckedCreateWithoutRoutineInput> | RoutineExecutionCreateWithoutRoutineInput[] | RoutineExecutionUncheckedCreateWithoutRoutineInput[]
    connectOrCreate?: RoutineExecutionCreateOrConnectWithoutRoutineInput | RoutineExecutionCreateOrConnectWithoutRoutineInput[]
    createMany?: RoutineExecutionCreateManyRoutineInputEnvelope
    connect?: RoutineExecutionWhereUniqueInput | RoutineExecutionWhereUniqueInput[]
  }

  export type RoutineExecutionUncheckedCreateNestedManyWithoutRoutineInput = {
    create?: XOR<RoutineExecutionCreateWithoutRoutineInput, RoutineExecutionUncheckedCreateWithoutRoutineInput> | RoutineExecutionCreateWithoutRoutineInput[] | RoutineExecutionUncheckedCreateWithoutRoutineInput[]
    connectOrCreate?: RoutineExecutionCreateOrConnectWithoutRoutineInput | RoutineExecutionCreateOrConnectWithoutRoutineInput[]
    createMany?: RoutineExecutionCreateManyRoutineInputEnvelope
    connect?: RoutineExecutionWhereUniqueInput | RoutineExecutionWhereUniqueInput[]
  }

  export type EnumRoutineTypeFieldUpdateOperationsInput = {
    set?: $Enums.RoutineType
  }

  export type UserUpdateOneRequiredWithoutRoutinesNestedInput = {
    create?: XOR<UserCreateWithoutRoutinesInput, UserUncheckedCreateWithoutRoutinesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRoutinesInput
    upsert?: UserUpsertWithoutRoutinesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRoutinesInput, UserUpdateWithoutRoutinesInput>, UserUncheckedUpdateWithoutRoutinesInput>
  }

  export type RoutineExecutionUpdateManyWithoutRoutineNestedInput = {
    create?: XOR<RoutineExecutionCreateWithoutRoutineInput, RoutineExecutionUncheckedCreateWithoutRoutineInput> | RoutineExecutionCreateWithoutRoutineInput[] | RoutineExecutionUncheckedCreateWithoutRoutineInput[]
    connectOrCreate?: RoutineExecutionCreateOrConnectWithoutRoutineInput | RoutineExecutionCreateOrConnectWithoutRoutineInput[]
    upsert?: RoutineExecutionUpsertWithWhereUniqueWithoutRoutineInput | RoutineExecutionUpsertWithWhereUniqueWithoutRoutineInput[]
    createMany?: RoutineExecutionCreateManyRoutineInputEnvelope
    set?: RoutineExecutionWhereUniqueInput | RoutineExecutionWhereUniqueInput[]
    disconnect?: RoutineExecutionWhereUniqueInput | RoutineExecutionWhereUniqueInput[]
    delete?: RoutineExecutionWhereUniqueInput | RoutineExecutionWhereUniqueInput[]
    connect?: RoutineExecutionWhereUniqueInput | RoutineExecutionWhereUniqueInput[]
    update?: RoutineExecutionUpdateWithWhereUniqueWithoutRoutineInput | RoutineExecutionUpdateWithWhereUniqueWithoutRoutineInput[]
    updateMany?: RoutineExecutionUpdateManyWithWhereWithoutRoutineInput | RoutineExecutionUpdateManyWithWhereWithoutRoutineInput[]
    deleteMany?: RoutineExecutionScalarWhereInput | RoutineExecutionScalarWhereInput[]
  }

  export type RoutineExecutionUncheckedUpdateManyWithoutRoutineNestedInput = {
    create?: XOR<RoutineExecutionCreateWithoutRoutineInput, RoutineExecutionUncheckedCreateWithoutRoutineInput> | RoutineExecutionCreateWithoutRoutineInput[] | RoutineExecutionUncheckedCreateWithoutRoutineInput[]
    connectOrCreate?: RoutineExecutionCreateOrConnectWithoutRoutineInput | RoutineExecutionCreateOrConnectWithoutRoutineInput[]
    upsert?: RoutineExecutionUpsertWithWhereUniqueWithoutRoutineInput | RoutineExecutionUpsertWithWhereUniqueWithoutRoutineInput[]
    createMany?: RoutineExecutionCreateManyRoutineInputEnvelope
    set?: RoutineExecutionWhereUniqueInput | RoutineExecutionWhereUniqueInput[]
    disconnect?: RoutineExecutionWhereUniqueInput | RoutineExecutionWhereUniqueInput[]
    delete?: RoutineExecutionWhereUniqueInput | RoutineExecutionWhereUniqueInput[]
    connect?: RoutineExecutionWhereUniqueInput | RoutineExecutionWhereUniqueInput[]
    update?: RoutineExecutionUpdateWithWhereUniqueWithoutRoutineInput | RoutineExecutionUpdateWithWhereUniqueWithoutRoutineInput[]
    updateMany?: RoutineExecutionUpdateManyWithWhereWithoutRoutineInput | RoutineExecutionUpdateManyWithWhereWithoutRoutineInput[]
    deleteMany?: RoutineExecutionScalarWhereInput | RoutineExecutionScalarWhereInput[]
  }

  export type RoutineCreateNestedOneWithoutExecutionsInput = {
    create?: XOR<RoutineCreateWithoutExecutionsInput, RoutineUncheckedCreateWithoutExecutionsInput>
    connectOrCreate?: RoutineCreateOrConnectWithoutExecutionsInput
    connect?: RoutineWhereUniqueInput
  }

  export type RoutineUpdateOneRequiredWithoutExecutionsNestedInput = {
    create?: XOR<RoutineCreateWithoutExecutionsInput, RoutineUncheckedCreateWithoutExecutionsInput>
    connectOrCreate?: RoutineCreateOrConnectWithoutExecutionsInput
    upsert?: RoutineUpsertWithoutExecutionsInput
    connect?: RoutineWhereUniqueInput
    update?: XOR<XOR<RoutineUpdateToOneWithWhereWithoutExecutionsInput, RoutineUpdateWithoutExecutionsInput>, RoutineUncheckedUpdateWithoutExecutionsInput>
  }

  export type WorkerSessionCreateNestedManyWithoutWorkerInput = {
    create?: XOR<WorkerSessionCreateWithoutWorkerInput, WorkerSessionUncheckedCreateWithoutWorkerInput> | WorkerSessionCreateWithoutWorkerInput[] | WorkerSessionUncheckedCreateWithoutWorkerInput[]
    connectOrCreate?: WorkerSessionCreateOrConnectWithoutWorkerInput | WorkerSessionCreateOrConnectWithoutWorkerInput[]
    createMany?: WorkerSessionCreateManyWorkerInputEnvelope
    connect?: WorkerSessionWhereUniqueInput | WorkerSessionWhereUniqueInput[]
  }

  export type WorkerSessionUncheckedCreateNestedManyWithoutWorkerInput = {
    create?: XOR<WorkerSessionCreateWithoutWorkerInput, WorkerSessionUncheckedCreateWithoutWorkerInput> | WorkerSessionCreateWithoutWorkerInput[] | WorkerSessionUncheckedCreateWithoutWorkerInput[]
    connectOrCreate?: WorkerSessionCreateOrConnectWithoutWorkerInput | WorkerSessionCreateOrConnectWithoutWorkerInput[]
    createMany?: WorkerSessionCreateManyWorkerInputEnvelope
    connect?: WorkerSessionWhereUniqueInput | WorkerSessionWhereUniqueInput[]
  }

  export type EnumWorkerRoleFieldUpdateOperationsInput = {
    set?: $Enums.WorkerRole
  }

  export type WorkerSessionUpdateManyWithoutWorkerNestedInput = {
    create?: XOR<WorkerSessionCreateWithoutWorkerInput, WorkerSessionUncheckedCreateWithoutWorkerInput> | WorkerSessionCreateWithoutWorkerInput[] | WorkerSessionUncheckedCreateWithoutWorkerInput[]
    connectOrCreate?: WorkerSessionCreateOrConnectWithoutWorkerInput | WorkerSessionCreateOrConnectWithoutWorkerInput[]
    upsert?: WorkerSessionUpsertWithWhereUniqueWithoutWorkerInput | WorkerSessionUpsertWithWhereUniqueWithoutWorkerInput[]
    createMany?: WorkerSessionCreateManyWorkerInputEnvelope
    set?: WorkerSessionWhereUniqueInput | WorkerSessionWhereUniqueInput[]
    disconnect?: WorkerSessionWhereUniqueInput | WorkerSessionWhereUniqueInput[]
    delete?: WorkerSessionWhereUniqueInput | WorkerSessionWhereUniqueInput[]
    connect?: WorkerSessionWhereUniqueInput | WorkerSessionWhereUniqueInput[]
    update?: WorkerSessionUpdateWithWhereUniqueWithoutWorkerInput | WorkerSessionUpdateWithWhereUniqueWithoutWorkerInput[]
    updateMany?: WorkerSessionUpdateManyWithWhereWithoutWorkerInput | WorkerSessionUpdateManyWithWhereWithoutWorkerInput[]
    deleteMany?: WorkerSessionScalarWhereInput | WorkerSessionScalarWhereInput[]
  }

  export type WorkerSessionUncheckedUpdateManyWithoutWorkerNestedInput = {
    create?: XOR<WorkerSessionCreateWithoutWorkerInput, WorkerSessionUncheckedCreateWithoutWorkerInput> | WorkerSessionCreateWithoutWorkerInput[] | WorkerSessionUncheckedCreateWithoutWorkerInput[]
    connectOrCreate?: WorkerSessionCreateOrConnectWithoutWorkerInput | WorkerSessionCreateOrConnectWithoutWorkerInput[]
    upsert?: WorkerSessionUpsertWithWhereUniqueWithoutWorkerInput | WorkerSessionUpsertWithWhereUniqueWithoutWorkerInput[]
    createMany?: WorkerSessionCreateManyWorkerInputEnvelope
    set?: WorkerSessionWhereUniqueInput | WorkerSessionWhereUniqueInput[]
    disconnect?: WorkerSessionWhereUniqueInput | WorkerSessionWhereUniqueInput[]
    delete?: WorkerSessionWhereUniqueInput | WorkerSessionWhereUniqueInput[]
    connect?: WorkerSessionWhereUniqueInput | WorkerSessionWhereUniqueInput[]
    update?: WorkerSessionUpdateWithWhereUniqueWithoutWorkerInput | WorkerSessionUpdateWithWhereUniqueWithoutWorkerInput[]
    updateMany?: WorkerSessionUpdateManyWithWhereWithoutWorkerInput | WorkerSessionUpdateManyWithWhereWithoutWorkerInput[]
    deleteMany?: WorkerSessionScalarWhereInput | WorkerSessionScalarWhereInput[]
  }

  export type WorkerCreateNestedOneWithoutSessionsInput = {
    create?: XOR<WorkerCreateWithoutSessionsInput, WorkerUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: WorkerCreateOrConnectWithoutSessionsInput
    connect?: WorkerWhereUniqueInput
  }

  export type AutoApplicationCreateNestedOneWithoutWorkerSessionInput = {
    create?: XOR<AutoApplicationCreateWithoutWorkerSessionInput, AutoApplicationUncheckedCreateWithoutWorkerSessionInput>
    connectOrCreate?: AutoApplicationCreateOrConnectWithoutWorkerSessionInput
    connect?: AutoApplicationWhereUniqueInput
  }

  export type EnumWorkerSessionStatusFieldUpdateOperationsInput = {
    set?: $Enums.WorkerSessionStatus
  }

  export type WorkerUpdateOneWithoutSessionsNestedInput = {
    create?: XOR<WorkerCreateWithoutSessionsInput, WorkerUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: WorkerCreateOrConnectWithoutSessionsInput
    upsert?: WorkerUpsertWithoutSessionsInput
    disconnect?: WorkerWhereInput | boolean
    delete?: WorkerWhereInput | boolean
    connect?: WorkerWhereUniqueInput
    update?: XOR<XOR<WorkerUpdateToOneWithWhereWithoutSessionsInput, WorkerUpdateWithoutSessionsInput>, WorkerUncheckedUpdateWithoutSessionsInput>
  }

  export type AutoApplicationUpdateOneRequiredWithoutWorkerSessionNestedInput = {
    create?: XOR<AutoApplicationCreateWithoutWorkerSessionInput, AutoApplicationUncheckedCreateWithoutWorkerSessionInput>
    connectOrCreate?: AutoApplicationCreateOrConnectWithoutWorkerSessionInput
    upsert?: AutoApplicationUpsertWithoutWorkerSessionInput
    connect?: AutoApplicationWhereUniqueInput
    update?: XOR<XOR<AutoApplicationUpdateToOneWithWhereWithoutWorkerSessionInput, AutoApplicationUpdateWithoutWorkerSessionInput>, AutoApplicationUncheckedUpdateWithoutWorkerSessionInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumJobStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.JobStatus | EnumJobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumJobStatusFilter<$PrismaModel> | $Enums.JobStatus
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumJobStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.JobStatus | EnumJobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumJobStatusWithAggregatesFilter<$PrismaModel> | $Enums.JobStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumJobStatusFilter<$PrismaModel>
    _max?: NestedEnumJobStatusFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumArtifactTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ArtifactType | EnumArtifactTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ArtifactType[] | ListEnumArtifactTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ArtifactType[] | ListEnumArtifactTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumArtifactTypeFilter<$PrismaModel> | $Enums.ArtifactType
  }

  export type NestedBytesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel>
    in?: Buffer[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Buffer[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesFilter<$PrismaModel> | Buffer
  }

  export type NestedEnumArtifactTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ArtifactType | EnumArtifactTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ArtifactType[] | ListEnumArtifactTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ArtifactType[] | ListEnumArtifactTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumArtifactTypeWithAggregatesFilter<$PrismaModel> | $Enums.ArtifactType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumArtifactTypeFilter<$PrismaModel>
    _max?: NestedEnumArtifactTypeFilter<$PrismaModel>
  }

  export type NestedBytesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel>
    in?: Buffer[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Buffer[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesWithAggregatesFilter<$PrismaModel> | Buffer
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBytesFilter<$PrismaModel>
    _max?: NestedBytesFilter<$PrismaModel>
  }

  export type NestedEnumEmbeddingTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EmbeddingType | EnumEmbeddingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EmbeddingType[] | ListEnumEmbeddingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmbeddingType[] | ListEnumEmbeddingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEmbeddingTypeFilter<$PrismaModel> | $Enums.EmbeddingType
  }

  export type NestedEnumEmbeddingTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EmbeddingType | EnumEmbeddingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EmbeddingType[] | ListEnumEmbeddingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmbeddingType[] | ListEnumEmbeddingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEmbeddingTypeWithAggregatesFilter<$PrismaModel> | $Enums.EmbeddingType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEmbeddingTypeFilter<$PrismaModel>
    _max?: NestedEnumEmbeddingTypeFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumSubscriptionTierFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionTier | EnumSubscriptionTierFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionTierFilter<$PrismaModel> | $Enums.SubscriptionTier
  }

  export type NestedEnumSubscriptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusFilter<$PrismaModel> | $Enums.SubscriptionStatus
  }

  export type NestedEnumSubscriptionTierWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionTier | EnumSubscriptionTierFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionTierWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionTier
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionTierFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionTierFilter<$PrismaModel>
  }

  export type NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
  }

  export type NestedEnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumAutoApplicationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AutoApplicationStatus | EnumAutoApplicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AutoApplicationStatus[] | ListEnumAutoApplicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AutoApplicationStatus[] | ListEnumAutoApplicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAutoApplicationStatusFilter<$PrismaModel> | $Enums.AutoApplicationStatus
  }

  export type NestedEnumAutoApplicationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AutoApplicationStatus | EnumAutoApplicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AutoApplicationStatus[] | ListEnumAutoApplicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AutoApplicationStatus[] | ListEnumAutoApplicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAutoApplicationStatusWithAggregatesFilter<$PrismaModel> | $Enums.AutoApplicationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAutoApplicationStatusFilter<$PrismaModel>
    _max?: NestedEnumAutoApplicationStatusFilter<$PrismaModel>
  }

  export type NestedEnumMessageRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageRole | EnumMessageRoleFieldRefInput<$PrismaModel>
    in?: $Enums.MessageRole[] | ListEnumMessageRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageRole[] | ListEnumMessageRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageRoleFilter<$PrismaModel> | $Enums.MessageRole
  }

  export type NestedEnumMessageRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageRole | EnumMessageRoleFieldRefInput<$PrismaModel>
    in?: $Enums.MessageRole[] | ListEnumMessageRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageRole[] | ListEnumMessageRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageRoleWithAggregatesFilter<$PrismaModel> | $Enums.MessageRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessageRoleFilter<$PrismaModel>
    _max?: NestedEnumMessageRoleFilter<$PrismaModel>
  }

  export type NestedEnumGoalTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.GoalType | EnumGoalTypeFieldRefInput<$PrismaModel>
    in?: $Enums.GoalType[] | ListEnumGoalTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.GoalType[] | ListEnumGoalTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumGoalTypeFilter<$PrismaModel> | $Enums.GoalType
  }

  export type NestedEnumGoalStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.GoalStatus | EnumGoalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.GoalStatus[] | ListEnumGoalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.GoalStatus[] | ListEnumGoalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumGoalStatusFilter<$PrismaModel> | $Enums.GoalStatus
  }

  export type NestedEnumGoalTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GoalType | EnumGoalTypeFieldRefInput<$PrismaModel>
    in?: $Enums.GoalType[] | ListEnumGoalTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.GoalType[] | ListEnumGoalTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumGoalTypeWithAggregatesFilter<$PrismaModel> | $Enums.GoalType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGoalTypeFilter<$PrismaModel>
    _max?: NestedEnumGoalTypeFilter<$PrismaModel>
  }

  export type NestedEnumGoalStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GoalStatus | EnumGoalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.GoalStatus[] | ListEnumGoalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.GoalStatus[] | ListEnumGoalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumGoalStatusWithAggregatesFilter<$PrismaModel> | $Enums.GoalStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGoalStatusFilter<$PrismaModel>
    _max?: NestedEnumGoalStatusFilter<$PrismaModel>
  }

  export type NestedEnumRoutineTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RoutineType | EnumRoutineTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RoutineType[] | ListEnumRoutineTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoutineType[] | ListEnumRoutineTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRoutineTypeFilter<$PrismaModel> | $Enums.RoutineType
  }

  export type NestedEnumRoutineTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RoutineType | EnumRoutineTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RoutineType[] | ListEnumRoutineTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoutineType[] | ListEnumRoutineTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRoutineTypeWithAggregatesFilter<$PrismaModel> | $Enums.RoutineType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoutineTypeFilter<$PrismaModel>
    _max?: NestedEnumRoutineTypeFilter<$PrismaModel>
  }

  export type NestedEnumWorkerRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkerRole | EnumWorkerRoleFieldRefInput<$PrismaModel>
    in?: $Enums.WorkerRole[] | ListEnumWorkerRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkerRole[] | ListEnumWorkerRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkerRoleFilter<$PrismaModel> | $Enums.WorkerRole
  }

  export type NestedEnumWorkerRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkerRole | EnumWorkerRoleFieldRefInput<$PrismaModel>
    in?: $Enums.WorkerRole[] | ListEnumWorkerRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkerRole[] | ListEnumWorkerRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkerRoleWithAggregatesFilter<$PrismaModel> | $Enums.WorkerRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkerRoleFilter<$PrismaModel>
    _max?: NestedEnumWorkerRoleFilter<$PrismaModel>
  }

  export type NestedEnumWorkerSessionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkerSessionStatus | EnumWorkerSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkerSessionStatus[] | ListEnumWorkerSessionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkerSessionStatus[] | ListEnumWorkerSessionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkerSessionStatusFilter<$PrismaModel> | $Enums.WorkerSessionStatus
  }

  export type NestedEnumWorkerSessionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkerSessionStatus | EnumWorkerSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkerSessionStatus[] | ListEnumWorkerSessionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkerSessionStatus[] | ListEnumWorkerSessionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkerSessionStatusWithAggregatesFilter<$PrismaModel> | $Enums.WorkerSessionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkerSessionStatusFilter<$PrismaModel>
    _max?: NestedEnumWorkerSessionStatusFilter<$PrismaModel>
  }

  export type JobCreateWithoutUserInput = {
    id?: string
    status?: $Enums.JobStatus
    priority?: number
    attempts?: number
    maxAttempts?: number
    resumeText?: string | null
    jobDescription: string
    aiMode?: string | null
    matchMode?: string | null
    error?: string | null
    diagnostics?: NullableJsonNullValueInput | InputJsonValue
    processingLog?: JobCreateprocessingLogInput | InputJsonValue[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    company?: string | null
    jobUrl?: string | null
    role?: string | null
    artifacts?: ArtifactCreateNestedManyWithoutJobInput
    embeddings?: EmbeddingCreateNestedManyWithoutJobInput
  }

  export type JobUncheckedCreateWithoutUserInput = {
    id?: string
    status?: $Enums.JobStatus
    priority?: number
    attempts?: number
    maxAttempts?: number
    resumeText?: string | null
    jobDescription: string
    aiMode?: string | null
    matchMode?: string | null
    error?: string | null
    diagnostics?: NullableJsonNullValueInput | InputJsonValue
    processingLog?: JobCreateprocessingLogInput | InputJsonValue[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    company?: string | null
    jobUrl?: string | null
    role?: string | null
    artifacts?: ArtifactUncheckedCreateNestedManyWithoutJobInput
    embeddings?: EmbeddingUncheckedCreateNestedManyWithoutJobInput
  }

  export type JobCreateOrConnectWithoutUserInput = {
    where: JobWhereUniqueInput
    create: XOR<JobCreateWithoutUserInput, JobUncheckedCreateWithoutUserInput>
  }

  export type JobCreateManyUserInputEnvelope = {
    data: JobCreateManyUserInput | JobCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ProfileCreateWithoutUserInput = {
    data: JsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
  }

  export type ProfileUncheckedCreateWithoutUserInput = {
    id?: number
    data: JsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
  }

  export type ProfileCreateOrConnectWithoutUserInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
  }

  export type SubscriptionCreateWithoutUserInput = {
    id?: string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    tier?: $Enums.SubscriptionTier
    status?: $Enums.SubscriptionStatus
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    cancelAtPeriodEnd?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionUncheckedCreateWithoutUserInput = {
    id?: string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    tier?: $Enums.SubscriptionTier
    status?: $Enums.SubscriptionStatus
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    cancelAtPeriodEnd?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionCreateOrConnectWithoutUserInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput>
  }

  export type UsageTrackingCreateWithoutUserInput = {
    id?: string
    date?: Date | string
    resumesGenerated?: number
    dailyLimit: number
    tier: $Enums.SubscriptionTier
    resetAt: Date | string
  }

  export type UsageTrackingUncheckedCreateWithoutUserInput = {
    id?: string
    date?: Date | string
    resumesGenerated?: number
    dailyLimit: number
    tier: $Enums.SubscriptionTier
    resetAt: Date | string
  }

  export type UsageTrackingCreateOrConnectWithoutUserInput = {
    where: UsageTrackingWhereUniqueInput
    create: XOR<UsageTrackingCreateWithoutUserInput, UsageTrackingUncheckedCreateWithoutUserInput>
  }

  export type UsageTrackingCreateManyUserInputEnvelope = {
    data: UsageTrackingCreateManyUserInput | UsageTrackingCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutUserInput = {
    id?: string
    stripePaymentId: string
    amount: number
    currency?: string
    status: $Enums.PaymentStatus
    description?: string | null
    createdAt?: Date | string
  }

  export type PaymentUncheckedCreateWithoutUserInput = {
    id?: string
    stripePaymentId: string
    amount: number
    currency?: string
    status: $Enums.PaymentStatus
    description?: string | null
    createdAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutUserInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput>
  }

  export type PaymentCreateManyUserInputEnvelope = {
    data: PaymentCreateManyUserInput | PaymentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AutoApplicationCreateWithoutUserInput = {
    id?: string
    status?: $Enums.AutoApplicationStatus
    method?: string
    submittedAt?: Date | string | null
    confirmationUrl?: string | null
    confirmationId?: string | null
    confirmationData?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    errorType?: string | null
    retryCount?: number
    maxRetries?: number
    cost?: number
    createdAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    job: AggregatedJobCreateNestedOneWithoutApplicationsInput
    workerSession?: WorkerSessionCreateNestedOneWithoutAutoApplicationInput
  }

  export type AutoApplicationUncheckedCreateWithoutUserInput = {
    id?: string
    jobId: string
    status?: $Enums.AutoApplicationStatus
    method?: string
    submittedAt?: Date | string | null
    confirmationUrl?: string | null
    confirmationId?: string | null
    confirmationData?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    errorType?: string | null
    retryCount?: number
    maxRetries?: number
    cost?: number
    createdAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    workerSession?: WorkerSessionUncheckedCreateNestedOneWithoutAutoApplicationInput
  }

  export type AutoApplicationCreateOrConnectWithoutUserInput = {
    where: AutoApplicationWhereUniqueInput
    create: XOR<AutoApplicationCreateWithoutUserInput, AutoApplicationUncheckedCreateWithoutUserInput>
  }

  export type AutoApplicationCreateManyUserInputEnvelope = {
    data: AutoApplicationCreateManyUserInput | AutoApplicationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ConversationCreateWithoutUserInput = {
    id?: string
    title?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastMessageAt?: Date | string
    messages?: MessageCreateNestedManyWithoutConversationInput
    goals?: GoalCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutUserInput = {
    id?: string
    title?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastMessageAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
    goals?: GoalUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutUserInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutUserInput, ConversationUncheckedCreateWithoutUserInput>
  }

  export type ConversationCreateManyUserInputEnvelope = {
    data: ConversationCreateManyUserInput | ConversationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type GoalCreateWithoutUserInput = {
    id?: string
    title: string
    description?: string | null
    type?: $Enums.GoalType
    status?: $Enums.GoalStatus
    targetDate?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    conversation?: ConversationCreateNestedOneWithoutGoalsInput
  }

  export type GoalUncheckedCreateWithoutUserInput = {
    id?: string
    conversationId?: string | null
    title: string
    description?: string | null
    type?: $Enums.GoalType
    status?: $Enums.GoalStatus
    targetDate?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type GoalCreateOrConnectWithoutUserInput = {
    where: GoalWhereUniqueInput
    create: XOR<GoalCreateWithoutUserInput, GoalUncheckedCreateWithoutUserInput>
  }

  export type GoalCreateManyUserInputEnvelope = {
    data: GoalCreateManyUserInput | GoalCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RoutineCreateWithoutUserInput = {
    id?: string
    title: string
    description?: string | null
    type?: $Enums.RoutineType
    frequency?: string
    schedule?: string
    config?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    lastRun?: Date | string | null
    nextRun?: Date | string | null
    runCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    executions?: RoutineExecutionCreateNestedManyWithoutRoutineInput
  }

  export type RoutineUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    description?: string | null
    type?: $Enums.RoutineType
    frequency?: string
    schedule?: string
    config?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    lastRun?: Date | string | null
    nextRun?: Date | string | null
    runCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    executions?: RoutineExecutionUncheckedCreateNestedManyWithoutRoutineInput
  }

  export type RoutineCreateOrConnectWithoutUserInput = {
    where: RoutineWhereUniqueInput
    create: XOR<RoutineCreateWithoutUserInput, RoutineUncheckedCreateWithoutUserInput>
  }

  export type RoutineCreateManyUserInputEnvelope = {
    data: RoutineCreateManyUserInput | RoutineCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type GmailConnectionCreateWithoutUserInput = {
    id?: string
    email: string
    accessToken: string
    refreshToken: string
    expiresAt: Date | string
    scope: string
    isActive?: boolean
    lastUsed?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GmailConnectionUncheckedCreateWithoutUserInput = {
    id?: string
    email: string
    accessToken: string
    refreshToken: string
    expiresAt: Date | string
    scope: string
    isActive?: boolean
    lastUsed?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GmailConnectionCreateOrConnectWithoutUserInput = {
    where: GmailConnectionWhereUniqueInput
    create: XOR<GmailConnectionCreateWithoutUserInput, GmailConnectionUncheckedCreateWithoutUserInput>
  }

  export type JobUpsertWithWhereUniqueWithoutUserInput = {
    where: JobWhereUniqueInput
    update: XOR<JobUpdateWithoutUserInput, JobUncheckedUpdateWithoutUserInput>
    create: XOR<JobCreateWithoutUserInput, JobUncheckedCreateWithoutUserInput>
  }

  export type JobUpdateWithWhereUniqueWithoutUserInput = {
    where: JobWhereUniqueInput
    data: XOR<JobUpdateWithoutUserInput, JobUncheckedUpdateWithoutUserInput>
  }

  export type JobUpdateManyWithWhereWithoutUserInput = {
    where: JobScalarWhereInput
    data: XOR<JobUpdateManyMutationInput, JobUncheckedUpdateManyWithoutUserInput>
  }

  export type JobScalarWhereInput = {
    AND?: JobScalarWhereInput | JobScalarWhereInput[]
    OR?: JobScalarWhereInput[]
    NOT?: JobScalarWhereInput | JobScalarWhereInput[]
    id?: StringFilter<"Job"> | string
    userId?: IntNullableFilter<"Job"> | number | null
    status?: EnumJobStatusFilter<"Job"> | $Enums.JobStatus
    priority?: IntFilter<"Job"> | number
    attempts?: IntFilter<"Job"> | number
    maxAttempts?: IntFilter<"Job"> | number
    resumeText?: StringNullableFilter<"Job"> | string | null
    jobDescription?: StringFilter<"Job"> | string
    aiMode?: StringNullableFilter<"Job"> | string | null
    matchMode?: StringNullableFilter<"Job"> | string | null
    error?: StringNullableFilter<"Job"> | string | null
    diagnostics?: JsonNullableFilter<"Job">
    processingLog?: JsonNullableListFilter<"Job">
    metadata?: JsonNullableFilter<"Job">
    createdAt?: DateTimeFilter<"Job"> | Date | string
    updatedAt?: DateTimeFilter<"Job"> | Date | string
    startedAt?: DateTimeNullableFilter<"Job"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Job"> | Date | string | null
    company?: StringNullableFilter<"Job"> | string | null
    jobUrl?: StringNullableFilter<"Job"> | string | null
    role?: StringNullableFilter<"Job"> | string | null
  }

  export type ProfileUpsertWithoutUserInput = {
    update: XOR<ProfileUpdateWithoutUserInput, ProfileUncheckedUpdateWithoutUserInput>
    create: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutUserInput, ProfileUncheckedUpdateWithoutUserInput>
  }

  export type ProfileUpdateWithoutUserInput = {
    data?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUpsertWithoutUserInput = {
    update: XOR<SubscriptionUpdateWithoutUserInput, SubscriptionUncheckedUpdateWithoutUserInput>
    create: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput>
    where?: SubscriptionWhereInput
  }

  export type SubscriptionUpdateToOneWithWhereWithoutUserInput = {
    where?: SubscriptionWhereInput
    data: XOR<SubscriptionUpdateWithoutUserInput, SubscriptionUncheckedUpdateWithoutUserInput>
  }

  export type SubscriptionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    tier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    tier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageTrackingUpsertWithWhereUniqueWithoutUserInput = {
    where: UsageTrackingWhereUniqueInput
    update: XOR<UsageTrackingUpdateWithoutUserInput, UsageTrackingUncheckedUpdateWithoutUserInput>
    create: XOR<UsageTrackingCreateWithoutUserInput, UsageTrackingUncheckedCreateWithoutUserInput>
  }

  export type UsageTrackingUpdateWithWhereUniqueWithoutUserInput = {
    where: UsageTrackingWhereUniqueInput
    data: XOR<UsageTrackingUpdateWithoutUserInput, UsageTrackingUncheckedUpdateWithoutUserInput>
  }

  export type UsageTrackingUpdateManyWithWhereWithoutUserInput = {
    where: UsageTrackingScalarWhereInput
    data: XOR<UsageTrackingUpdateManyMutationInput, UsageTrackingUncheckedUpdateManyWithoutUserInput>
  }

  export type UsageTrackingScalarWhereInput = {
    AND?: UsageTrackingScalarWhereInput | UsageTrackingScalarWhereInput[]
    OR?: UsageTrackingScalarWhereInput[]
    NOT?: UsageTrackingScalarWhereInput | UsageTrackingScalarWhereInput[]
    id?: StringFilter<"UsageTracking"> | string
    userId?: IntFilter<"UsageTracking"> | number
    date?: DateTimeFilter<"UsageTracking"> | Date | string
    resumesGenerated?: IntFilter<"UsageTracking"> | number
    dailyLimit?: IntFilter<"UsageTracking"> | number
    tier?: EnumSubscriptionTierFilter<"UsageTracking"> | $Enums.SubscriptionTier
    resetAt?: DateTimeFilter<"UsageTracking"> | Date | string
  }

  export type PaymentUpsertWithWhereUniqueWithoutUserInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutUserInput, PaymentUncheckedUpdateWithoutUserInput>
    create: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutUserInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutUserInput, PaymentUncheckedUpdateWithoutUserInput>
  }

  export type PaymentUpdateManyWithWhereWithoutUserInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutUserInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: StringFilter<"Payment"> | string
    userId?: IntFilter<"Payment"> | number
    stripePaymentId?: StringFilter<"Payment"> | string
    amount?: IntFilter<"Payment"> | number
    currency?: StringFilter<"Payment"> | string
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    description?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
  }

  export type AutoApplicationUpsertWithWhereUniqueWithoutUserInput = {
    where: AutoApplicationWhereUniqueInput
    update: XOR<AutoApplicationUpdateWithoutUserInput, AutoApplicationUncheckedUpdateWithoutUserInput>
    create: XOR<AutoApplicationCreateWithoutUserInput, AutoApplicationUncheckedCreateWithoutUserInput>
  }

  export type AutoApplicationUpdateWithWhereUniqueWithoutUserInput = {
    where: AutoApplicationWhereUniqueInput
    data: XOR<AutoApplicationUpdateWithoutUserInput, AutoApplicationUncheckedUpdateWithoutUserInput>
  }

  export type AutoApplicationUpdateManyWithWhereWithoutUserInput = {
    where: AutoApplicationScalarWhereInput
    data: XOR<AutoApplicationUpdateManyMutationInput, AutoApplicationUncheckedUpdateManyWithoutUserInput>
  }

  export type AutoApplicationScalarWhereInput = {
    AND?: AutoApplicationScalarWhereInput | AutoApplicationScalarWhereInput[]
    OR?: AutoApplicationScalarWhereInput[]
    NOT?: AutoApplicationScalarWhereInput | AutoApplicationScalarWhereInput[]
    id?: StringFilter<"AutoApplication"> | string
    userId?: IntFilter<"AutoApplication"> | number
    jobId?: StringFilter<"AutoApplication"> | string
    status?: EnumAutoApplicationStatusFilter<"AutoApplication"> | $Enums.AutoApplicationStatus
    method?: StringFilter<"AutoApplication"> | string
    submittedAt?: DateTimeNullableFilter<"AutoApplication"> | Date | string | null
    confirmationUrl?: StringNullableFilter<"AutoApplication"> | string | null
    confirmationId?: StringNullableFilter<"AutoApplication"> | string | null
    confirmationData?: JsonNullableFilter<"AutoApplication">
    error?: StringNullableFilter<"AutoApplication"> | string | null
    errorType?: StringNullableFilter<"AutoApplication"> | string | null
    retryCount?: IntFilter<"AutoApplication"> | number
    maxRetries?: IntFilter<"AutoApplication"> | number
    cost?: FloatFilter<"AutoApplication"> | number
    createdAt?: DateTimeFilter<"AutoApplication"> | Date | string
    startedAt?: DateTimeNullableFilter<"AutoApplication"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"AutoApplication"> | Date | string | null
  }

  export type ConversationUpsertWithWhereUniqueWithoutUserInput = {
    where: ConversationWhereUniqueInput
    update: XOR<ConversationUpdateWithoutUserInput, ConversationUncheckedUpdateWithoutUserInput>
    create: XOR<ConversationCreateWithoutUserInput, ConversationUncheckedCreateWithoutUserInput>
  }

  export type ConversationUpdateWithWhereUniqueWithoutUserInput = {
    where: ConversationWhereUniqueInput
    data: XOR<ConversationUpdateWithoutUserInput, ConversationUncheckedUpdateWithoutUserInput>
  }

  export type ConversationUpdateManyWithWhereWithoutUserInput = {
    where: ConversationScalarWhereInput
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyWithoutUserInput>
  }

  export type ConversationScalarWhereInput = {
    AND?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
    OR?: ConversationScalarWhereInput[]
    NOT?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
    id?: StringFilter<"Conversation"> | string
    userId?: IntNullableFilter<"Conversation"> | number | null
    title?: StringNullableFilter<"Conversation"> | string | null
    createdAt?: DateTimeFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeFilter<"Conversation"> | Date | string
    lastMessageAt?: DateTimeFilter<"Conversation"> | Date | string
  }

  export type GoalUpsertWithWhereUniqueWithoutUserInput = {
    where: GoalWhereUniqueInput
    update: XOR<GoalUpdateWithoutUserInput, GoalUncheckedUpdateWithoutUserInput>
    create: XOR<GoalCreateWithoutUserInput, GoalUncheckedCreateWithoutUserInput>
  }

  export type GoalUpdateWithWhereUniqueWithoutUserInput = {
    where: GoalWhereUniqueInput
    data: XOR<GoalUpdateWithoutUserInput, GoalUncheckedUpdateWithoutUserInput>
  }

  export type GoalUpdateManyWithWhereWithoutUserInput = {
    where: GoalScalarWhereInput
    data: XOR<GoalUpdateManyMutationInput, GoalUncheckedUpdateManyWithoutUserInput>
  }

  export type GoalScalarWhereInput = {
    AND?: GoalScalarWhereInput | GoalScalarWhereInput[]
    OR?: GoalScalarWhereInput[]
    NOT?: GoalScalarWhereInput | GoalScalarWhereInput[]
    id?: StringFilter<"Goal"> | string
    conversationId?: StringNullableFilter<"Goal"> | string | null
    userId?: IntFilter<"Goal"> | number
    title?: StringFilter<"Goal"> | string
    description?: StringNullableFilter<"Goal"> | string | null
    type?: EnumGoalTypeFilter<"Goal"> | $Enums.GoalType
    status?: EnumGoalStatusFilter<"Goal"> | $Enums.GoalStatus
    targetDate?: DateTimeNullableFilter<"Goal"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Goal"> | Date | string | null
    createdAt?: DateTimeFilter<"Goal"> | Date | string
    updatedAt?: DateTimeFilter<"Goal"> | Date | string
    metadata?: JsonNullableFilter<"Goal">
  }

  export type RoutineUpsertWithWhereUniqueWithoutUserInput = {
    where: RoutineWhereUniqueInput
    update: XOR<RoutineUpdateWithoutUserInput, RoutineUncheckedUpdateWithoutUserInput>
    create: XOR<RoutineCreateWithoutUserInput, RoutineUncheckedCreateWithoutUserInput>
  }

  export type RoutineUpdateWithWhereUniqueWithoutUserInput = {
    where: RoutineWhereUniqueInput
    data: XOR<RoutineUpdateWithoutUserInput, RoutineUncheckedUpdateWithoutUserInput>
  }

  export type RoutineUpdateManyWithWhereWithoutUserInput = {
    where: RoutineScalarWhereInput
    data: XOR<RoutineUpdateManyMutationInput, RoutineUncheckedUpdateManyWithoutUserInput>
  }

  export type RoutineScalarWhereInput = {
    AND?: RoutineScalarWhereInput | RoutineScalarWhereInput[]
    OR?: RoutineScalarWhereInput[]
    NOT?: RoutineScalarWhereInput | RoutineScalarWhereInput[]
    id?: StringFilter<"Routine"> | string
    userId?: IntFilter<"Routine"> | number
    title?: StringFilter<"Routine"> | string
    description?: StringNullableFilter<"Routine"> | string | null
    type?: EnumRoutineTypeFilter<"Routine"> | $Enums.RoutineType
    frequency?: StringFilter<"Routine"> | string
    schedule?: StringFilter<"Routine"> | string
    config?: JsonNullableFilter<"Routine">
    isActive?: BoolFilter<"Routine"> | boolean
    lastRun?: DateTimeNullableFilter<"Routine"> | Date | string | null
    nextRun?: DateTimeNullableFilter<"Routine"> | Date | string | null
    runCount?: IntFilter<"Routine"> | number
    createdAt?: DateTimeFilter<"Routine"> | Date | string
    updatedAt?: DateTimeFilter<"Routine"> | Date | string
  }

  export type GmailConnectionUpsertWithoutUserInput = {
    update: XOR<GmailConnectionUpdateWithoutUserInput, GmailConnectionUncheckedUpdateWithoutUserInput>
    create: XOR<GmailConnectionCreateWithoutUserInput, GmailConnectionUncheckedCreateWithoutUserInput>
    where?: GmailConnectionWhereInput
  }

  export type GmailConnectionUpdateToOneWithWhereWithoutUserInput = {
    where?: GmailConnectionWhereInput
    data: XOR<GmailConnectionUpdateWithoutUserInput, GmailConnectionUncheckedUpdateWithoutUserInput>
  }

  export type GmailConnectionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scope?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GmailConnectionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scope?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutGmailConnectionInput = {
    email: string
    password: string
    clerkId?: string | null
    createdAt?: Date | string
    jobs?: JobCreateNestedManyWithoutUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    usageTracking?: UsageTrackingCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    autoApplications?: AutoApplicationCreateNestedManyWithoutUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    goals?: GoalCreateNestedManyWithoutUserInput
    routines?: RoutineCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutGmailConnectionInput = {
    id?: number
    email: string
    password: string
    clerkId?: string | null
    createdAt?: Date | string
    jobs?: JobUncheckedCreateNestedManyWithoutUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    usageTracking?: UsageTrackingUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    autoApplications?: AutoApplicationUncheckedCreateNestedManyWithoutUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    goals?: GoalUncheckedCreateNestedManyWithoutUserInput
    routines?: RoutineUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutGmailConnectionInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGmailConnectionInput, UserUncheckedCreateWithoutGmailConnectionInput>
  }

  export type UserUpsertWithoutGmailConnectionInput = {
    update: XOR<UserUpdateWithoutGmailConnectionInput, UserUncheckedUpdateWithoutGmailConnectionInput>
    create: XOR<UserCreateWithoutGmailConnectionInput, UserUncheckedCreateWithoutGmailConnectionInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutGmailConnectionInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutGmailConnectionInput, UserUncheckedUpdateWithoutGmailConnectionInput>
  }

  export type UserUpdateWithoutGmailConnectionInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    clerkId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobs?: JobUpdateManyWithoutUserNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    usageTracking?: UsageTrackingUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    autoApplications?: AutoApplicationUpdateManyWithoutUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    goals?: GoalUpdateManyWithoutUserNestedInput
    routines?: RoutineUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutGmailConnectionInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    clerkId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobs?: JobUncheckedUpdateManyWithoutUserNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    usageTracking?: UsageTrackingUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    autoApplications?: AutoApplicationUncheckedUpdateManyWithoutUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    goals?: GoalUncheckedUpdateManyWithoutUserNestedInput
    routines?: RoutineUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutProfileInput = {
    email: string
    password: string
    clerkId?: string | null
    createdAt?: Date | string
    jobs?: JobCreateNestedManyWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    usageTracking?: UsageTrackingCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    autoApplications?: AutoApplicationCreateNestedManyWithoutUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    goals?: GoalCreateNestedManyWithoutUserInput
    routines?: RoutineCreateNestedManyWithoutUserInput
    gmailConnection?: GmailConnectionCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProfileInput = {
    id?: number
    email: string
    password: string
    clerkId?: string | null
    createdAt?: Date | string
    jobs?: JobUncheckedCreateNestedManyWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    usageTracking?: UsageTrackingUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    autoApplications?: AutoApplicationUncheckedCreateNestedManyWithoutUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    goals?: GoalUncheckedCreateNestedManyWithoutUserInput
    routines?: RoutineUncheckedCreateNestedManyWithoutUserInput
    gmailConnection?: GmailConnectionUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
  }

  export type UserUpsertWithoutProfileInput = {
    update: XOR<UserUpdateWithoutProfileInput, UserUncheckedUpdateWithoutProfileInput>
    create: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProfileInput, UserUncheckedUpdateWithoutProfileInput>
  }

  export type UserUpdateWithoutProfileInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    clerkId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobs?: JobUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    usageTracking?: UsageTrackingUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    autoApplications?: AutoApplicationUpdateManyWithoutUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    goals?: GoalUpdateManyWithoutUserNestedInput
    routines?: RoutineUpdateManyWithoutUserNestedInput
    gmailConnection?: GmailConnectionUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProfileInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    clerkId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobs?: JobUncheckedUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    usageTracking?: UsageTrackingUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    autoApplications?: AutoApplicationUncheckedUpdateManyWithoutUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    goals?: GoalUncheckedUpdateManyWithoutUserNestedInput
    routines?: RoutineUncheckedUpdateManyWithoutUserNestedInput
    gmailConnection?: GmailConnectionUncheckedUpdateOneWithoutUserNestedInput
  }

  export type ArtifactCreateWithoutJobInput = {
    id?: string
    type: $Enums.ArtifactType
    version?: number
    content: Buffer
    metadata?: NullableJsonNullValueInput | InputJsonValue
    schema?: NullableJsonNullValueInput | InputJsonValue
    validated?: boolean
    createdAt?: Date | string
  }

  export type ArtifactUncheckedCreateWithoutJobInput = {
    id?: string
    type: $Enums.ArtifactType
    version?: number
    content: Buffer
    metadata?: NullableJsonNullValueInput | InputJsonValue
    schema?: NullableJsonNullValueInput | InputJsonValue
    validated?: boolean
    createdAt?: Date | string
  }

  export type ArtifactCreateOrConnectWithoutJobInput = {
    where: ArtifactWhereUniqueInput
    create: XOR<ArtifactCreateWithoutJobInput, ArtifactUncheckedCreateWithoutJobInput>
  }

  export type ArtifactCreateManyJobInputEnvelope = {
    data: ArtifactCreateManyJobInput | ArtifactCreateManyJobInput[]
    skipDuplicates?: boolean
  }

  export type EmbeddingCreateWithoutJobInput = {
    id?: string
    content: string
    contentType: $Enums.EmbeddingType
    embedding?: EmbeddingCreateembeddingInput | number[]
    relevance?: number | null
    createdAt?: Date | string
  }

  export type EmbeddingUncheckedCreateWithoutJobInput = {
    id?: string
    content: string
    contentType: $Enums.EmbeddingType
    embedding?: EmbeddingCreateembeddingInput | number[]
    relevance?: number | null
    createdAt?: Date | string
  }

  export type EmbeddingCreateOrConnectWithoutJobInput = {
    where: EmbeddingWhereUniqueInput
    create: XOR<EmbeddingCreateWithoutJobInput, EmbeddingUncheckedCreateWithoutJobInput>
  }

  export type EmbeddingCreateManyJobInputEnvelope = {
    data: EmbeddingCreateManyJobInput | EmbeddingCreateManyJobInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutJobsInput = {
    email: string
    password: string
    clerkId?: string | null
    createdAt?: Date | string
    profile?: ProfileCreateNestedOneWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    usageTracking?: UsageTrackingCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    autoApplications?: AutoApplicationCreateNestedManyWithoutUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    goals?: GoalCreateNestedManyWithoutUserInput
    routines?: RoutineCreateNestedManyWithoutUserInput
    gmailConnection?: GmailConnectionCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutJobsInput = {
    id?: number
    email: string
    password: string
    clerkId?: string | null
    createdAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    usageTracking?: UsageTrackingUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    autoApplications?: AutoApplicationUncheckedCreateNestedManyWithoutUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    goals?: GoalUncheckedCreateNestedManyWithoutUserInput
    routines?: RoutineUncheckedCreateNestedManyWithoutUserInput
    gmailConnection?: GmailConnectionUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutJobsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutJobsInput, UserUncheckedCreateWithoutJobsInput>
  }

  export type ArtifactUpsertWithWhereUniqueWithoutJobInput = {
    where: ArtifactWhereUniqueInput
    update: XOR<ArtifactUpdateWithoutJobInput, ArtifactUncheckedUpdateWithoutJobInput>
    create: XOR<ArtifactCreateWithoutJobInput, ArtifactUncheckedCreateWithoutJobInput>
  }

  export type ArtifactUpdateWithWhereUniqueWithoutJobInput = {
    where: ArtifactWhereUniqueInput
    data: XOR<ArtifactUpdateWithoutJobInput, ArtifactUncheckedUpdateWithoutJobInput>
  }

  export type ArtifactUpdateManyWithWhereWithoutJobInput = {
    where: ArtifactScalarWhereInput
    data: XOR<ArtifactUpdateManyMutationInput, ArtifactUncheckedUpdateManyWithoutJobInput>
  }

  export type ArtifactScalarWhereInput = {
    AND?: ArtifactScalarWhereInput | ArtifactScalarWhereInput[]
    OR?: ArtifactScalarWhereInput[]
    NOT?: ArtifactScalarWhereInput | ArtifactScalarWhereInput[]
    id?: StringFilter<"Artifact"> | string
    jobId?: StringFilter<"Artifact"> | string
    type?: EnumArtifactTypeFilter<"Artifact"> | $Enums.ArtifactType
    version?: IntFilter<"Artifact"> | number
    content?: BytesFilter<"Artifact"> | Buffer
    metadata?: JsonNullableFilter<"Artifact">
    schema?: JsonNullableFilter<"Artifact">
    validated?: BoolFilter<"Artifact"> | boolean
    createdAt?: DateTimeFilter<"Artifact"> | Date | string
  }

  export type EmbeddingUpsertWithWhereUniqueWithoutJobInput = {
    where: EmbeddingWhereUniqueInput
    update: XOR<EmbeddingUpdateWithoutJobInput, EmbeddingUncheckedUpdateWithoutJobInput>
    create: XOR<EmbeddingCreateWithoutJobInput, EmbeddingUncheckedCreateWithoutJobInput>
  }

  export type EmbeddingUpdateWithWhereUniqueWithoutJobInput = {
    where: EmbeddingWhereUniqueInput
    data: XOR<EmbeddingUpdateWithoutJobInput, EmbeddingUncheckedUpdateWithoutJobInput>
  }

  export type EmbeddingUpdateManyWithWhereWithoutJobInput = {
    where: EmbeddingScalarWhereInput
    data: XOR<EmbeddingUpdateManyMutationInput, EmbeddingUncheckedUpdateManyWithoutJobInput>
  }

  export type EmbeddingScalarWhereInput = {
    AND?: EmbeddingScalarWhereInput | EmbeddingScalarWhereInput[]
    OR?: EmbeddingScalarWhereInput[]
    NOT?: EmbeddingScalarWhereInput | EmbeddingScalarWhereInput[]
    id?: StringFilter<"Embedding"> | string
    jobId?: StringFilter<"Embedding"> | string
    content?: StringFilter<"Embedding"> | string
    contentType?: EnumEmbeddingTypeFilter<"Embedding"> | $Enums.EmbeddingType
    embedding?: FloatNullableListFilter<"Embedding">
    relevance?: FloatNullableFilter<"Embedding"> | number | null
    createdAt?: DateTimeFilter<"Embedding"> | Date | string
  }

  export type UserUpsertWithoutJobsInput = {
    update: XOR<UserUpdateWithoutJobsInput, UserUncheckedUpdateWithoutJobsInput>
    create: XOR<UserCreateWithoutJobsInput, UserUncheckedCreateWithoutJobsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutJobsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutJobsInput, UserUncheckedUpdateWithoutJobsInput>
  }

  export type UserUpdateWithoutJobsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    clerkId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    usageTracking?: UsageTrackingUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    autoApplications?: AutoApplicationUpdateManyWithoutUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    goals?: GoalUpdateManyWithoutUserNestedInput
    routines?: RoutineUpdateManyWithoutUserNestedInput
    gmailConnection?: GmailConnectionUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutJobsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    clerkId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    usageTracking?: UsageTrackingUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    autoApplications?: AutoApplicationUncheckedUpdateManyWithoutUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    goals?: GoalUncheckedUpdateManyWithoutUserNestedInput
    routines?: RoutineUncheckedUpdateManyWithoutUserNestedInput
    gmailConnection?: GmailConnectionUncheckedUpdateOneWithoutUserNestedInput
  }

  export type JobCreateWithoutArtifactsInput = {
    id?: string
    status?: $Enums.JobStatus
    priority?: number
    attempts?: number
    maxAttempts?: number
    resumeText?: string | null
    jobDescription: string
    aiMode?: string | null
    matchMode?: string | null
    error?: string | null
    diagnostics?: NullableJsonNullValueInput | InputJsonValue
    processingLog?: JobCreateprocessingLogInput | InputJsonValue[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    company?: string | null
    jobUrl?: string | null
    role?: string | null
    embeddings?: EmbeddingCreateNestedManyWithoutJobInput
    user?: UserCreateNestedOneWithoutJobsInput
  }

  export type JobUncheckedCreateWithoutArtifactsInput = {
    id?: string
    userId?: number | null
    status?: $Enums.JobStatus
    priority?: number
    attempts?: number
    maxAttempts?: number
    resumeText?: string | null
    jobDescription: string
    aiMode?: string | null
    matchMode?: string | null
    error?: string | null
    diagnostics?: NullableJsonNullValueInput | InputJsonValue
    processingLog?: JobCreateprocessingLogInput | InputJsonValue[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    company?: string | null
    jobUrl?: string | null
    role?: string | null
    embeddings?: EmbeddingUncheckedCreateNestedManyWithoutJobInput
  }

  export type JobCreateOrConnectWithoutArtifactsInput = {
    where: JobWhereUniqueInput
    create: XOR<JobCreateWithoutArtifactsInput, JobUncheckedCreateWithoutArtifactsInput>
  }

  export type JobUpsertWithoutArtifactsInput = {
    update: XOR<JobUpdateWithoutArtifactsInput, JobUncheckedUpdateWithoutArtifactsInput>
    create: XOR<JobCreateWithoutArtifactsInput, JobUncheckedCreateWithoutArtifactsInput>
    where?: JobWhereInput
  }

  export type JobUpdateToOneWithWhereWithoutArtifactsInput = {
    where?: JobWhereInput
    data: XOR<JobUpdateWithoutArtifactsInput, JobUncheckedUpdateWithoutArtifactsInput>
  }

  export type JobUpdateWithoutArtifactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    priority?: IntFieldUpdateOperationsInput | number
    attempts?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    resumeText?: NullableStringFieldUpdateOperationsInput | string | null
    jobDescription?: StringFieldUpdateOperationsInput | string
    aiMode?: NullableStringFieldUpdateOperationsInput | string | null
    matchMode?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    diagnostics?: NullableJsonNullValueInput | InputJsonValue
    processingLog?: JobUpdateprocessingLogInput | InputJsonValue[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    jobUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    embeddings?: EmbeddingUpdateManyWithoutJobNestedInput
    user?: UserUpdateOneWithoutJobsNestedInput
  }

  export type JobUncheckedUpdateWithoutArtifactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    priority?: IntFieldUpdateOperationsInput | number
    attempts?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    resumeText?: NullableStringFieldUpdateOperationsInput | string | null
    jobDescription?: StringFieldUpdateOperationsInput | string
    aiMode?: NullableStringFieldUpdateOperationsInput | string | null
    matchMode?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    diagnostics?: NullableJsonNullValueInput | InputJsonValue
    processingLog?: JobUpdateprocessingLogInput | InputJsonValue[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    jobUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    embeddings?: EmbeddingUncheckedUpdateManyWithoutJobNestedInput
  }

  export type JobCreateWithoutEmbeddingsInput = {
    id?: string
    status?: $Enums.JobStatus
    priority?: number
    attempts?: number
    maxAttempts?: number
    resumeText?: string | null
    jobDescription: string
    aiMode?: string | null
    matchMode?: string | null
    error?: string | null
    diagnostics?: NullableJsonNullValueInput | InputJsonValue
    processingLog?: JobCreateprocessingLogInput | InputJsonValue[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    company?: string | null
    jobUrl?: string | null
    role?: string | null
    artifacts?: ArtifactCreateNestedManyWithoutJobInput
    user?: UserCreateNestedOneWithoutJobsInput
  }

  export type JobUncheckedCreateWithoutEmbeddingsInput = {
    id?: string
    userId?: number | null
    status?: $Enums.JobStatus
    priority?: number
    attempts?: number
    maxAttempts?: number
    resumeText?: string | null
    jobDescription: string
    aiMode?: string | null
    matchMode?: string | null
    error?: string | null
    diagnostics?: NullableJsonNullValueInput | InputJsonValue
    processingLog?: JobCreateprocessingLogInput | InputJsonValue[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    company?: string | null
    jobUrl?: string | null
    role?: string | null
    artifacts?: ArtifactUncheckedCreateNestedManyWithoutJobInput
  }

  export type JobCreateOrConnectWithoutEmbeddingsInput = {
    where: JobWhereUniqueInput
    create: XOR<JobCreateWithoutEmbeddingsInput, JobUncheckedCreateWithoutEmbeddingsInput>
  }

  export type JobUpsertWithoutEmbeddingsInput = {
    update: XOR<JobUpdateWithoutEmbeddingsInput, JobUncheckedUpdateWithoutEmbeddingsInput>
    create: XOR<JobCreateWithoutEmbeddingsInput, JobUncheckedCreateWithoutEmbeddingsInput>
    where?: JobWhereInput
  }

  export type JobUpdateToOneWithWhereWithoutEmbeddingsInput = {
    where?: JobWhereInput
    data: XOR<JobUpdateWithoutEmbeddingsInput, JobUncheckedUpdateWithoutEmbeddingsInput>
  }

  export type JobUpdateWithoutEmbeddingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    priority?: IntFieldUpdateOperationsInput | number
    attempts?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    resumeText?: NullableStringFieldUpdateOperationsInput | string | null
    jobDescription?: StringFieldUpdateOperationsInput | string
    aiMode?: NullableStringFieldUpdateOperationsInput | string | null
    matchMode?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    diagnostics?: NullableJsonNullValueInput | InputJsonValue
    processingLog?: JobUpdateprocessingLogInput | InputJsonValue[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    jobUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    artifacts?: ArtifactUpdateManyWithoutJobNestedInput
    user?: UserUpdateOneWithoutJobsNestedInput
  }

  export type JobUncheckedUpdateWithoutEmbeddingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    priority?: IntFieldUpdateOperationsInput | number
    attempts?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    resumeText?: NullableStringFieldUpdateOperationsInput | string | null
    jobDescription?: StringFieldUpdateOperationsInput | string
    aiMode?: NullableStringFieldUpdateOperationsInput | string | null
    matchMode?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    diagnostics?: NullableJsonNullValueInput | InputJsonValue
    processingLog?: JobUpdateprocessingLogInput | InputJsonValue[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    jobUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    artifacts?: ArtifactUncheckedUpdateManyWithoutJobNestedInput
  }

  export type UserCreateWithoutSubscriptionInput = {
    email: string
    password: string
    clerkId?: string | null
    createdAt?: Date | string
    jobs?: JobCreateNestedManyWithoutUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    usageTracking?: UsageTrackingCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    autoApplications?: AutoApplicationCreateNestedManyWithoutUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    goals?: GoalCreateNestedManyWithoutUserInput
    routines?: RoutineCreateNestedManyWithoutUserInput
    gmailConnection?: GmailConnectionCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSubscriptionInput = {
    id?: number
    email: string
    password: string
    clerkId?: string | null
    createdAt?: Date | string
    jobs?: JobUncheckedCreateNestedManyWithoutUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    usageTracking?: UsageTrackingUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    autoApplications?: AutoApplicationUncheckedCreateNestedManyWithoutUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    goals?: GoalUncheckedCreateNestedManyWithoutUserInput
    routines?: RoutineUncheckedCreateNestedManyWithoutUserInput
    gmailConnection?: GmailConnectionUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSubscriptionInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSubscriptionInput, UserUncheckedCreateWithoutSubscriptionInput>
  }

  export type UserUpsertWithoutSubscriptionInput = {
    update: XOR<UserUpdateWithoutSubscriptionInput, UserUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<UserCreateWithoutSubscriptionInput, UserUncheckedCreateWithoutSubscriptionInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSubscriptionInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSubscriptionInput, UserUncheckedUpdateWithoutSubscriptionInput>
  }

  export type UserUpdateWithoutSubscriptionInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    clerkId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobs?: JobUpdateManyWithoutUserNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    usageTracking?: UsageTrackingUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    autoApplications?: AutoApplicationUpdateManyWithoutUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    goals?: GoalUpdateManyWithoutUserNestedInput
    routines?: RoutineUpdateManyWithoutUserNestedInput
    gmailConnection?: GmailConnectionUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSubscriptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    clerkId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobs?: JobUncheckedUpdateManyWithoutUserNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    usageTracking?: UsageTrackingUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    autoApplications?: AutoApplicationUncheckedUpdateManyWithoutUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    goals?: GoalUncheckedUpdateManyWithoutUserNestedInput
    routines?: RoutineUncheckedUpdateManyWithoutUserNestedInput
    gmailConnection?: GmailConnectionUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutUsageTrackingInput = {
    email: string
    password: string
    clerkId?: string | null
    createdAt?: Date | string
    jobs?: JobCreateNestedManyWithoutUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    autoApplications?: AutoApplicationCreateNestedManyWithoutUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    goals?: GoalCreateNestedManyWithoutUserInput
    routines?: RoutineCreateNestedManyWithoutUserInput
    gmailConnection?: GmailConnectionCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUsageTrackingInput = {
    id?: number
    email: string
    password: string
    clerkId?: string | null
    createdAt?: Date | string
    jobs?: JobUncheckedCreateNestedManyWithoutUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    autoApplications?: AutoApplicationUncheckedCreateNestedManyWithoutUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    goals?: GoalUncheckedCreateNestedManyWithoutUserInput
    routines?: RoutineUncheckedCreateNestedManyWithoutUserInput
    gmailConnection?: GmailConnectionUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUsageTrackingInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUsageTrackingInput, UserUncheckedCreateWithoutUsageTrackingInput>
  }

  export type UserUpsertWithoutUsageTrackingInput = {
    update: XOR<UserUpdateWithoutUsageTrackingInput, UserUncheckedUpdateWithoutUsageTrackingInput>
    create: XOR<UserCreateWithoutUsageTrackingInput, UserUncheckedCreateWithoutUsageTrackingInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUsageTrackingInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUsageTrackingInput, UserUncheckedUpdateWithoutUsageTrackingInput>
  }

  export type UserUpdateWithoutUsageTrackingInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    clerkId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobs?: JobUpdateManyWithoutUserNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    autoApplications?: AutoApplicationUpdateManyWithoutUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    goals?: GoalUpdateManyWithoutUserNestedInput
    routines?: RoutineUpdateManyWithoutUserNestedInput
    gmailConnection?: GmailConnectionUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUsageTrackingInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    clerkId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobs?: JobUncheckedUpdateManyWithoutUserNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    autoApplications?: AutoApplicationUncheckedUpdateManyWithoutUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    goals?: GoalUncheckedUpdateManyWithoutUserNestedInput
    routines?: RoutineUncheckedUpdateManyWithoutUserNestedInput
    gmailConnection?: GmailConnectionUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutPaymentsInput = {
    email: string
    password: string
    clerkId?: string | null
    createdAt?: Date | string
    jobs?: JobCreateNestedManyWithoutUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    usageTracking?: UsageTrackingCreateNestedManyWithoutUserInput
    autoApplications?: AutoApplicationCreateNestedManyWithoutUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    goals?: GoalCreateNestedManyWithoutUserInput
    routines?: RoutineCreateNestedManyWithoutUserInput
    gmailConnection?: GmailConnectionCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPaymentsInput = {
    id?: number
    email: string
    password: string
    clerkId?: string | null
    createdAt?: Date | string
    jobs?: JobUncheckedCreateNestedManyWithoutUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    usageTracking?: UsageTrackingUncheckedCreateNestedManyWithoutUserInput
    autoApplications?: AutoApplicationUncheckedCreateNestedManyWithoutUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    goals?: GoalUncheckedCreateNestedManyWithoutUserInput
    routines?: RoutineUncheckedCreateNestedManyWithoutUserInput
    gmailConnection?: GmailConnectionUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPaymentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
  }

  export type UserUpsertWithoutPaymentsInput = {
    update: XOR<UserUpdateWithoutPaymentsInput, UserUncheckedUpdateWithoutPaymentsInput>
    create: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPaymentsInput, UserUncheckedUpdateWithoutPaymentsInput>
  }

  export type UserUpdateWithoutPaymentsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    clerkId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobs?: JobUpdateManyWithoutUserNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    usageTracking?: UsageTrackingUpdateManyWithoutUserNestedInput
    autoApplications?: AutoApplicationUpdateManyWithoutUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    goals?: GoalUpdateManyWithoutUserNestedInput
    routines?: RoutineUpdateManyWithoutUserNestedInput
    gmailConnection?: GmailConnectionUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPaymentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    clerkId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobs?: JobUncheckedUpdateManyWithoutUserNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    usageTracking?: UsageTrackingUncheckedUpdateManyWithoutUserNestedInput
    autoApplications?: AutoApplicationUncheckedUpdateManyWithoutUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    goals?: GoalUncheckedUpdateManyWithoutUserNestedInput
    routines?: RoutineUncheckedUpdateManyWithoutUserNestedInput
    gmailConnection?: GmailConnectionUncheckedUpdateOneWithoutUserNestedInput
  }

  export type AutoApplicationCreateWithoutJobInput = {
    id?: string
    status?: $Enums.AutoApplicationStatus
    method?: string
    submittedAt?: Date | string | null
    confirmationUrl?: string | null
    confirmationId?: string | null
    confirmationData?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    errorType?: string | null
    retryCount?: number
    maxRetries?: number
    cost?: number
    createdAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    user: UserCreateNestedOneWithoutAutoApplicationsInput
    workerSession?: WorkerSessionCreateNestedOneWithoutAutoApplicationInput
  }

  export type AutoApplicationUncheckedCreateWithoutJobInput = {
    id?: string
    userId: number
    status?: $Enums.AutoApplicationStatus
    method?: string
    submittedAt?: Date | string | null
    confirmationUrl?: string | null
    confirmationId?: string | null
    confirmationData?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    errorType?: string | null
    retryCount?: number
    maxRetries?: number
    cost?: number
    createdAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    workerSession?: WorkerSessionUncheckedCreateNestedOneWithoutAutoApplicationInput
  }

  export type AutoApplicationCreateOrConnectWithoutJobInput = {
    where: AutoApplicationWhereUniqueInput
    create: XOR<AutoApplicationCreateWithoutJobInput, AutoApplicationUncheckedCreateWithoutJobInput>
  }

  export type AutoApplicationCreateManyJobInputEnvelope = {
    data: AutoApplicationCreateManyJobInput | AutoApplicationCreateManyJobInput[]
    skipDuplicates?: boolean
  }

  export type AutoApplicationUpsertWithWhereUniqueWithoutJobInput = {
    where: AutoApplicationWhereUniqueInput
    update: XOR<AutoApplicationUpdateWithoutJobInput, AutoApplicationUncheckedUpdateWithoutJobInput>
    create: XOR<AutoApplicationCreateWithoutJobInput, AutoApplicationUncheckedCreateWithoutJobInput>
  }

  export type AutoApplicationUpdateWithWhereUniqueWithoutJobInput = {
    where: AutoApplicationWhereUniqueInput
    data: XOR<AutoApplicationUpdateWithoutJobInput, AutoApplicationUncheckedUpdateWithoutJobInput>
  }

  export type AutoApplicationUpdateManyWithWhereWithoutJobInput = {
    where: AutoApplicationScalarWhereInput
    data: XOR<AutoApplicationUpdateManyMutationInput, AutoApplicationUncheckedUpdateManyWithoutJobInput>
  }

  export type UserCreateWithoutAutoApplicationsInput = {
    email: string
    password: string
    clerkId?: string | null
    createdAt?: Date | string
    jobs?: JobCreateNestedManyWithoutUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    usageTracking?: UsageTrackingCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    goals?: GoalCreateNestedManyWithoutUserInput
    routines?: RoutineCreateNestedManyWithoutUserInput
    gmailConnection?: GmailConnectionCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAutoApplicationsInput = {
    id?: number
    email: string
    password: string
    clerkId?: string | null
    createdAt?: Date | string
    jobs?: JobUncheckedCreateNestedManyWithoutUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    usageTracking?: UsageTrackingUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    goals?: GoalUncheckedCreateNestedManyWithoutUserInput
    routines?: RoutineUncheckedCreateNestedManyWithoutUserInput
    gmailConnection?: GmailConnectionUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAutoApplicationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAutoApplicationsInput, UserUncheckedCreateWithoutAutoApplicationsInput>
  }

  export type AggregatedJobCreateWithoutApplicationsInput = {
    id?: string
    externalId: string
    source: string
    title: string
    company: string
    location?: string | null
    salary?: string | null
    description: string
    requirements?: string | null
    applyUrl: string
    companyUrl?: string | null
    atsType: string
    atsCompany?: string | null
    atsComplexity: string
    atsConfidence: number
    aiApplyable?: boolean
    extractedSkills?: AggregatedJobCreateextractedSkillsInput | string[]
    extractedExperience?: string | null
    extractedEducation?: string | null
    extractedJobLevel?: string | null
    extractedKeywords?: AggregatedJobCreateextractedKeywordsInput | string[]
    extractedBenefits?: AggregatedJobCreateextractedBenefitsInput | string[]
    lastExtractedAt?: Date | string | null
    extractionConfidence?: number | null
    postedDate: Date | string
    expiresAt?: Date | string | null
    firstSeenAt?: Date | string
    lastChecked?: Date | string
    closedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type AggregatedJobUncheckedCreateWithoutApplicationsInput = {
    id?: string
    externalId: string
    source: string
    title: string
    company: string
    location?: string | null
    salary?: string | null
    description: string
    requirements?: string | null
    applyUrl: string
    companyUrl?: string | null
    atsType: string
    atsCompany?: string | null
    atsComplexity: string
    atsConfidence: number
    aiApplyable?: boolean
    extractedSkills?: AggregatedJobCreateextractedSkillsInput | string[]
    extractedExperience?: string | null
    extractedEducation?: string | null
    extractedJobLevel?: string | null
    extractedKeywords?: AggregatedJobCreateextractedKeywordsInput | string[]
    extractedBenefits?: AggregatedJobCreateextractedBenefitsInput | string[]
    lastExtractedAt?: Date | string | null
    extractionConfidence?: number | null
    postedDate: Date | string
    expiresAt?: Date | string | null
    firstSeenAt?: Date | string
    lastChecked?: Date | string
    closedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type AggregatedJobCreateOrConnectWithoutApplicationsInput = {
    where: AggregatedJobWhereUniqueInput
    create: XOR<AggregatedJobCreateWithoutApplicationsInput, AggregatedJobUncheckedCreateWithoutApplicationsInput>
  }

  export type WorkerSessionCreateWithoutAutoApplicationInput = {
    id?: string
    status?: $Enums.WorkerSessionStatus
    browserSessionId?: string | null
    vncUrl?: string | null
    queuedAt?: Date | string
    assignedAt?: Date | string | null
    aiStartedAt?: Date | string | null
    aiCompletedAt?: Date | string | null
    submittedAt?: Date | string | null
    completedAt?: Date | string | null
    formData?: NullableJsonNullValueInput | InputJsonValue
    screenshotUrl?: string | null
    workerNotes?: string | null
    failReason?: string | null
    skipReason?: string | null
    worker?: WorkerCreateNestedOneWithoutSessionsInput
  }

  export type WorkerSessionUncheckedCreateWithoutAutoApplicationInput = {
    id?: string
    workerId?: number | null
    status?: $Enums.WorkerSessionStatus
    browserSessionId?: string | null
    vncUrl?: string | null
    queuedAt?: Date | string
    assignedAt?: Date | string | null
    aiStartedAt?: Date | string | null
    aiCompletedAt?: Date | string | null
    submittedAt?: Date | string | null
    completedAt?: Date | string | null
    formData?: NullableJsonNullValueInput | InputJsonValue
    screenshotUrl?: string | null
    workerNotes?: string | null
    failReason?: string | null
    skipReason?: string | null
  }

  export type WorkerSessionCreateOrConnectWithoutAutoApplicationInput = {
    where: WorkerSessionWhereUniqueInput
    create: XOR<WorkerSessionCreateWithoutAutoApplicationInput, WorkerSessionUncheckedCreateWithoutAutoApplicationInput>
  }

  export type UserUpsertWithoutAutoApplicationsInput = {
    update: XOR<UserUpdateWithoutAutoApplicationsInput, UserUncheckedUpdateWithoutAutoApplicationsInput>
    create: XOR<UserCreateWithoutAutoApplicationsInput, UserUncheckedCreateWithoutAutoApplicationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAutoApplicationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAutoApplicationsInput, UserUncheckedUpdateWithoutAutoApplicationsInput>
  }

  export type UserUpdateWithoutAutoApplicationsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    clerkId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobs?: JobUpdateManyWithoutUserNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    usageTracking?: UsageTrackingUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    goals?: GoalUpdateManyWithoutUserNestedInput
    routines?: RoutineUpdateManyWithoutUserNestedInput
    gmailConnection?: GmailConnectionUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAutoApplicationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    clerkId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobs?: JobUncheckedUpdateManyWithoutUserNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    usageTracking?: UsageTrackingUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    goals?: GoalUncheckedUpdateManyWithoutUserNestedInput
    routines?: RoutineUncheckedUpdateManyWithoutUserNestedInput
    gmailConnection?: GmailConnectionUncheckedUpdateOneWithoutUserNestedInput
  }

  export type AggregatedJobUpsertWithoutApplicationsInput = {
    update: XOR<AggregatedJobUpdateWithoutApplicationsInput, AggregatedJobUncheckedUpdateWithoutApplicationsInput>
    create: XOR<AggregatedJobCreateWithoutApplicationsInput, AggregatedJobUncheckedCreateWithoutApplicationsInput>
    where?: AggregatedJobWhereInput
  }

  export type AggregatedJobUpdateToOneWithWhereWithoutApplicationsInput = {
    where?: AggregatedJobWhereInput
    data: XOR<AggregatedJobUpdateWithoutApplicationsInput, AggregatedJobUncheckedUpdateWithoutApplicationsInput>
  }

  export type AggregatedJobUpdateWithoutApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    applyUrl?: StringFieldUpdateOperationsInput | string
    companyUrl?: NullableStringFieldUpdateOperationsInput | string | null
    atsType?: StringFieldUpdateOperationsInput | string
    atsCompany?: NullableStringFieldUpdateOperationsInput | string | null
    atsComplexity?: StringFieldUpdateOperationsInput | string
    atsConfidence?: FloatFieldUpdateOperationsInput | number
    aiApplyable?: BoolFieldUpdateOperationsInput | boolean
    extractedSkills?: AggregatedJobUpdateextractedSkillsInput | string[]
    extractedExperience?: NullableStringFieldUpdateOperationsInput | string | null
    extractedEducation?: NullableStringFieldUpdateOperationsInput | string | null
    extractedJobLevel?: NullableStringFieldUpdateOperationsInput | string | null
    extractedKeywords?: AggregatedJobUpdateextractedKeywordsInput | string[]
    extractedBenefits?: AggregatedJobUpdateextractedBenefitsInput | string[]
    lastExtractedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extractionConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    postedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firstSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChecked?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AggregatedJobUncheckedUpdateWithoutApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    applyUrl?: StringFieldUpdateOperationsInput | string
    companyUrl?: NullableStringFieldUpdateOperationsInput | string | null
    atsType?: StringFieldUpdateOperationsInput | string
    atsCompany?: NullableStringFieldUpdateOperationsInput | string | null
    atsComplexity?: StringFieldUpdateOperationsInput | string
    atsConfidence?: FloatFieldUpdateOperationsInput | number
    aiApplyable?: BoolFieldUpdateOperationsInput | boolean
    extractedSkills?: AggregatedJobUpdateextractedSkillsInput | string[]
    extractedExperience?: NullableStringFieldUpdateOperationsInput | string | null
    extractedEducation?: NullableStringFieldUpdateOperationsInput | string | null
    extractedJobLevel?: NullableStringFieldUpdateOperationsInput | string | null
    extractedKeywords?: AggregatedJobUpdateextractedKeywordsInput | string[]
    extractedBenefits?: AggregatedJobUpdateextractedBenefitsInput | string[]
    lastExtractedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extractionConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    postedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firstSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastChecked?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkerSessionUpsertWithoutAutoApplicationInput = {
    update: XOR<WorkerSessionUpdateWithoutAutoApplicationInput, WorkerSessionUncheckedUpdateWithoutAutoApplicationInput>
    create: XOR<WorkerSessionCreateWithoutAutoApplicationInput, WorkerSessionUncheckedCreateWithoutAutoApplicationInput>
    where?: WorkerSessionWhereInput
  }

  export type WorkerSessionUpdateToOneWithWhereWithoutAutoApplicationInput = {
    where?: WorkerSessionWhereInput
    data: XOR<WorkerSessionUpdateWithoutAutoApplicationInput, WorkerSessionUncheckedUpdateWithoutAutoApplicationInput>
  }

  export type WorkerSessionUpdateWithoutAutoApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumWorkerSessionStatusFieldUpdateOperationsInput | $Enums.WorkerSessionStatus
    browserSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    vncUrl?: NullableStringFieldUpdateOperationsInput | string | null
    queuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    formData?: NullableJsonNullValueInput | InputJsonValue
    screenshotUrl?: NullableStringFieldUpdateOperationsInput | string | null
    workerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    failReason?: NullableStringFieldUpdateOperationsInput | string | null
    skipReason?: NullableStringFieldUpdateOperationsInput | string | null
    worker?: WorkerUpdateOneWithoutSessionsNestedInput
  }

  export type WorkerSessionUncheckedUpdateWithoutAutoApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    workerId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumWorkerSessionStatusFieldUpdateOperationsInput | $Enums.WorkerSessionStatus
    browserSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    vncUrl?: NullableStringFieldUpdateOperationsInput | string | null
    queuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    formData?: NullableJsonNullValueInput | InputJsonValue
    screenshotUrl?: NullableStringFieldUpdateOperationsInput | string | null
    workerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    failReason?: NullableStringFieldUpdateOperationsInput | string | null
    skipReason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RecipeExecutionCreateWithoutRecipeInput = {
    id?: string
    success: boolean
    method: string
    duration?: number | null
    cost: number
    error?: string | null
    errorType?: string | null
    jobUrl?: string | null
    executedAt?: Date | string
  }

  export type RecipeExecutionUncheckedCreateWithoutRecipeInput = {
    id?: string
    success: boolean
    method: string
    duration?: number | null
    cost: number
    error?: string | null
    errorType?: string | null
    jobUrl?: string | null
    executedAt?: Date | string
  }

  export type RecipeExecutionCreateOrConnectWithoutRecipeInput = {
    where: RecipeExecutionWhereUniqueInput
    create: XOR<RecipeExecutionCreateWithoutRecipeInput, RecipeExecutionUncheckedCreateWithoutRecipeInput>
  }

  export type RecipeExecutionCreateManyRecipeInputEnvelope = {
    data: RecipeExecutionCreateManyRecipeInput | RecipeExecutionCreateManyRecipeInput[]
    skipDuplicates?: boolean
  }

  export type RecipeExecutionUpsertWithWhereUniqueWithoutRecipeInput = {
    where: RecipeExecutionWhereUniqueInput
    update: XOR<RecipeExecutionUpdateWithoutRecipeInput, RecipeExecutionUncheckedUpdateWithoutRecipeInput>
    create: XOR<RecipeExecutionCreateWithoutRecipeInput, RecipeExecutionUncheckedCreateWithoutRecipeInput>
  }

  export type RecipeExecutionUpdateWithWhereUniqueWithoutRecipeInput = {
    where: RecipeExecutionWhereUniqueInput
    data: XOR<RecipeExecutionUpdateWithoutRecipeInput, RecipeExecutionUncheckedUpdateWithoutRecipeInput>
  }

  export type RecipeExecutionUpdateManyWithWhereWithoutRecipeInput = {
    where: RecipeExecutionScalarWhereInput
    data: XOR<RecipeExecutionUpdateManyMutationInput, RecipeExecutionUncheckedUpdateManyWithoutRecipeInput>
  }

  export type RecipeExecutionScalarWhereInput = {
    AND?: RecipeExecutionScalarWhereInput | RecipeExecutionScalarWhereInput[]
    OR?: RecipeExecutionScalarWhereInput[]
    NOT?: RecipeExecutionScalarWhereInput | RecipeExecutionScalarWhereInput[]
    id?: StringFilter<"RecipeExecution"> | string
    recipeId?: StringFilter<"RecipeExecution"> | string
    success?: BoolFilter<"RecipeExecution"> | boolean
    method?: StringFilter<"RecipeExecution"> | string
    duration?: IntNullableFilter<"RecipeExecution"> | number | null
    cost?: FloatFilter<"RecipeExecution"> | number
    error?: StringNullableFilter<"RecipeExecution"> | string | null
    errorType?: StringNullableFilter<"RecipeExecution"> | string | null
    jobUrl?: StringNullableFilter<"RecipeExecution"> | string | null
    executedAt?: DateTimeFilter<"RecipeExecution"> | Date | string
  }

  export type ApplicationRecipeCreateWithoutExecutionsInput = {
    id?: string
    platform: string
    atsType: string
    version?: number
    steps: JsonNullValueInput | InputJsonValue
    successRate?: number
    timesUsed?: number
    failureCount?: number
    recordingCost?: number
    replayCost?: number
    totalSaved?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastUsed?: Date | string | null
    lastFailure?: Date | string | null
    recordedBy?: string | null
  }

  export type ApplicationRecipeUncheckedCreateWithoutExecutionsInput = {
    id?: string
    platform: string
    atsType: string
    version?: number
    steps: JsonNullValueInput | InputJsonValue
    successRate?: number
    timesUsed?: number
    failureCount?: number
    recordingCost?: number
    replayCost?: number
    totalSaved?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastUsed?: Date | string | null
    lastFailure?: Date | string | null
    recordedBy?: string | null
  }

  export type ApplicationRecipeCreateOrConnectWithoutExecutionsInput = {
    where: ApplicationRecipeWhereUniqueInput
    create: XOR<ApplicationRecipeCreateWithoutExecutionsInput, ApplicationRecipeUncheckedCreateWithoutExecutionsInput>
  }

  export type ApplicationRecipeUpsertWithoutExecutionsInput = {
    update: XOR<ApplicationRecipeUpdateWithoutExecutionsInput, ApplicationRecipeUncheckedUpdateWithoutExecutionsInput>
    create: XOR<ApplicationRecipeCreateWithoutExecutionsInput, ApplicationRecipeUncheckedCreateWithoutExecutionsInput>
    where?: ApplicationRecipeWhereInput
  }

  export type ApplicationRecipeUpdateToOneWithWhereWithoutExecutionsInput = {
    where?: ApplicationRecipeWhereInput
    data: XOR<ApplicationRecipeUpdateWithoutExecutionsInput, ApplicationRecipeUncheckedUpdateWithoutExecutionsInput>
  }

  export type ApplicationRecipeUpdateWithoutExecutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    atsType?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    steps?: JsonNullValueInput | InputJsonValue
    successRate?: FloatFieldUpdateOperationsInput | number
    timesUsed?: IntFieldUpdateOperationsInput | number
    failureCount?: IntFieldUpdateOperationsInput | number
    recordingCost?: FloatFieldUpdateOperationsInput | number
    replayCost?: FloatFieldUpdateOperationsInput | number
    totalSaved?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastFailure?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recordedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ApplicationRecipeUncheckedUpdateWithoutExecutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    atsType?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    steps?: JsonNullValueInput | InputJsonValue
    successRate?: FloatFieldUpdateOperationsInput | number
    timesUsed?: IntFieldUpdateOperationsInput | number
    failureCount?: IntFieldUpdateOperationsInput | number
    recordingCost?: FloatFieldUpdateOperationsInput | number
    replayCost?: FloatFieldUpdateOperationsInput | number
    totalSaved?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastFailure?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recordedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MessageCreateWithoutConversationInput = {
    id?: string
    role: $Enums.MessageRole
    content: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tokenCount?: number | null
    cost?: number | null
    createdAt?: Date | string
  }

  export type MessageUncheckedCreateWithoutConversationInput = {
    id?: string
    role: $Enums.MessageRole
    content: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tokenCount?: number | null
    cost?: number | null
    createdAt?: Date | string
  }

  export type MessageCreateOrConnectWithoutConversationInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput>
  }

  export type MessageCreateManyConversationInputEnvelope = {
    data: MessageCreateManyConversationInput | MessageCreateManyConversationInput[]
    skipDuplicates?: boolean
  }

  export type GoalCreateWithoutConversationInput = {
    id?: string
    title: string
    description?: string | null
    type?: $Enums.GoalType
    status?: $Enums.GoalStatus
    targetDate?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutGoalsInput
  }

  export type GoalUncheckedCreateWithoutConversationInput = {
    id?: string
    userId: number
    title: string
    description?: string | null
    type?: $Enums.GoalType
    status?: $Enums.GoalStatus
    targetDate?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type GoalCreateOrConnectWithoutConversationInput = {
    where: GoalWhereUniqueInput
    create: XOR<GoalCreateWithoutConversationInput, GoalUncheckedCreateWithoutConversationInput>
  }

  export type GoalCreateManyConversationInputEnvelope = {
    data: GoalCreateManyConversationInput | GoalCreateManyConversationInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutConversationsInput = {
    email: string
    password: string
    clerkId?: string | null
    createdAt?: Date | string
    jobs?: JobCreateNestedManyWithoutUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    usageTracking?: UsageTrackingCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    autoApplications?: AutoApplicationCreateNestedManyWithoutUserInput
    goals?: GoalCreateNestedManyWithoutUserInput
    routines?: RoutineCreateNestedManyWithoutUserInput
    gmailConnection?: GmailConnectionCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutConversationsInput = {
    id?: number
    email: string
    password: string
    clerkId?: string | null
    createdAt?: Date | string
    jobs?: JobUncheckedCreateNestedManyWithoutUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    usageTracking?: UsageTrackingUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    autoApplications?: AutoApplicationUncheckedCreateNestedManyWithoutUserInput
    goals?: GoalUncheckedCreateNestedManyWithoutUserInput
    routines?: RoutineUncheckedCreateNestedManyWithoutUserInput
    gmailConnection?: GmailConnectionUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutConversationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutConversationsInput, UserUncheckedCreateWithoutConversationsInput>
  }

  export type MessageUpsertWithWhereUniqueWithoutConversationInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutConversationInput, MessageUncheckedUpdateWithoutConversationInput>
    create: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutConversationInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutConversationInput, MessageUncheckedUpdateWithoutConversationInput>
  }

  export type MessageUpdateManyWithWhereWithoutConversationInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutConversationInput>
  }

  export type MessageScalarWhereInput = {
    AND?: MessageScalarWhereInput | MessageScalarWhereInput[]
    OR?: MessageScalarWhereInput[]
    NOT?: MessageScalarWhereInput | MessageScalarWhereInput[]
    id?: StringFilter<"Message"> | string
    conversationId?: StringFilter<"Message"> | string
    role?: EnumMessageRoleFilter<"Message"> | $Enums.MessageRole
    content?: StringFilter<"Message"> | string
    metadata?: JsonNullableFilter<"Message">
    tokenCount?: IntNullableFilter<"Message"> | number | null
    cost?: FloatNullableFilter<"Message"> | number | null
    createdAt?: DateTimeFilter<"Message"> | Date | string
  }

  export type GoalUpsertWithWhereUniqueWithoutConversationInput = {
    where: GoalWhereUniqueInput
    update: XOR<GoalUpdateWithoutConversationInput, GoalUncheckedUpdateWithoutConversationInput>
    create: XOR<GoalCreateWithoutConversationInput, GoalUncheckedCreateWithoutConversationInput>
  }

  export type GoalUpdateWithWhereUniqueWithoutConversationInput = {
    where: GoalWhereUniqueInput
    data: XOR<GoalUpdateWithoutConversationInput, GoalUncheckedUpdateWithoutConversationInput>
  }

  export type GoalUpdateManyWithWhereWithoutConversationInput = {
    where: GoalScalarWhereInput
    data: XOR<GoalUpdateManyMutationInput, GoalUncheckedUpdateManyWithoutConversationInput>
  }

  export type UserUpsertWithoutConversationsInput = {
    update: XOR<UserUpdateWithoutConversationsInput, UserUncheckedUpdateWithoutConversationsInput>
    create: XOR<UserCreateWithoutConversationsInput, UserUncheckedCreateWithoutConversationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutConversationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutConversationsInput, UserUncheckedUpdateWithoutConversationsInput>
  }

  export type UserUpdateWithoutConversationsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    clerkId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobs?: JobUpdateManyWithoutUserNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    usageTracking?: UsageTrackingUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    autoApplications?: AutoApplicationUpdateManyWithoutUserNestedInput
    goals?: GoalUpdateManyWithoutUserNestedInput
    routines?: RoutineUpdateManyWithoutUserNestedInput
    gmailConnection?: GmailConnectionUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutConversationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    clerkId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobs?: JobUncheckedUpdateManyWithoutUserNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    usageTracking?: UsageTrackingUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    autoApplications?: AutoApplicationUncheckedUpdateManyWithoutUserNestedInput
    goals?: GoalUncheckedUpdateManyWithoutUserNestedInput
    routines?: RoutineUncheckedUpdateManyWithoutUserNestedInput
    gmailConnection?: GmailConnectionUncheckedUpdateOneWithoutUserNestedInput
  }

  export type ConversationCreateWithoutMessagesInput = {
    id?: string
    title?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastMessageAt?: Date | string
    goals?: GoalCreateNestedManyWithoutConversationInput
    user?: UserCreateNestedOneWithoutConversationsInput
  }

  export type ConversationUncheckedCreateWithoutMessagesInput = {
    id?: string
    userId?: number | null
    title?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastMessageAt?: Date | string
    goals?: GoalUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutMessagesInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
  }

  export type ConversationUpsertWithoutMessagesInput = {
    update: XOR<ConversationUpdateWithoutMessagesInput, ConversationUncheckedUpdateWithoutMessagesInput>
    create: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    where?: ConversationWhereInput
  }

  export type ConversationUpdateToOneWithWhereWithoutMessagesInput = {
    where?: ConversationWhereInput
    data: XOR<ConversationUpdateWithoutMessagesInput, ConversationUncheckedUpdateWithoutMessagesInput>
  }

  export type ConversationUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMessageAt?: DateTimeFieldUpdateOperationsInput | Date | string
    goals?: GoalUpdateManyWithoutConversationNestedInput
    user?: UserUpdateOneWithoutConversationsNestedInput
  }

  export type ConversationUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMessageAt?: DateTimeFieldUpdateOperationsInput | Date | string
    goals?: GoalUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationCreateWithoutGoalsInput = {
    id?: string
    title?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastMessageAt?: Date | string
    messages?: MessageCreateNestedManyWithoutConversationInput
    user?: UserCreateNestedOneWithoutConversationsInput
  }

  export type ConversationUncheckedCreateWithoutGoalsInput = {
    id?: string
    userId?: number | null
    title?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastMessageAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutGoalsInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutGoalsInput, ConversationUncheckedCreateWithoutGoalsInput>
  }

  export type UserCreateWithoutGoalsInput = {
    email: string
    password: string
    clerkId?: string | null
    createdAt?: Date | string
    jobs?: JobCreateNestedManyWithoutUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    usageTracking?: UsageTrackingCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    autoApplications?: AutoApplicationCreateNestedManyWithoutUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    routines?: RoutineCreateNestedManyWithoutUserInput
    gmailConnection?: GmailConnectionCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutGoalsInput = {
    id?: number
    email: string
    password: string
    clerkId?: string | null
    createdAt?: Date | string
    jobs?: JobUncheckedCreateNestedManyWithoutUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    usageTracking?: UsageTrackingUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    autoApplications?: AutoApplicationUncheckedCreateNestedManyWithoutUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    routines?: RoutineUncheckedCreateNestedManyWithoutUserInput
    gmailConnection?: GmailConnectionUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutGoalsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGoalsInput, UserUncheckedCreateWithoutGoalsInput>
  }

  export type ConversationUpsertWithoutGoalsInput = {
    update: XOR<ConversationUpdateWithoutGoalsInput, ConversationUncheckedUpdateWithoutGoalsInput>
    create: XOR<ConversationCreateWithoutGoalsInput, ConversationUncheckedCreateWithoutGoalsInput>
    where?: ConversationWhereInput
  }

  export type ConversationUpdateToOneWithWhereWithoutGoalsInput = {
    where?: ConversationWhereInput
    data: XOR<ConversationUpdateWithoutGoalsInput, ConversationUncheckedUpdateWithoutGoalsInput>
  }

  export type ConversationUpdateWithoutGoalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMessageAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUpdateManyWithoutConversationNestedInput
    user?: UserUpdateOneWithoutConversationsNestedInput
  }

  export type ConversationUncheckedUpdateWithoutGoalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMessageAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type UserUpsertWithoutGoalsInput = {
    update: XOR<UserUpdateWithoutGoalsInput, UserUncheckedUpdateWithoutGoalsInput>
    create: XOR<UserCreateWithoutGoalsInput, UserUncheckedCreateWithoutGoalsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutGoalsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutGoalsInput, UserUncheckedUpdateWithoutGoalsInput>
  }

  export type UserUpdateWithoutGoalsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    clerkId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobs?: JobUpdateManyWithoutUserNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    usageTracking?: UsageTrackingUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    autoApplications?: AutoApplicationUpdateManyWithoutUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    routines?: RoutineUpdateManyWithoutUserNestedInput
    gmailConnection?: GmailConnectionUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutGoalsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    clerkId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobs?: JobUncheckedUpdateManyWithoutUserNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    usageTracking?: UsageTrackingUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    autoApplications?: AutoApplicationUncheckedUpdateManyWithoutUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    routines?: RoutineUncheckedUpdateManyWithoutUserNestedInput
    gmailConnection?: GmailConnectionUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutRoutinesInput = {
    email: string
    password: string
    clerkId?: string | null
    createdAt?: Date | string
    jobs?: JobCreateNestedManyWithoutUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    usageTracking?: UsageTrackingCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    autoApplications?: AutoApplicationCreateNestedManyWithoutUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    goals?: GoalCreateNestedManyWithoutUserInput
    gmailConnection?: GmailConnectionCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRoutinesInput = {
    id?: number
    email: string
    password: string
    clerkId?: string | null
    createdAt?: Date | string
    jobs?: JobUncheckedCreateNestedManyWithoutUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    usageTracking?: UsageTrackingUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    autoApplications?: AutoApplicationUncheckedCreateNestedManyWithoutUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    goals?: GoalUncheckedCreateNestedManyWithoutUserInput
    gmailConnection?: GmailConnectionUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRoutinesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRoutinesInput, UserUncheckedCreateWithoutRoutinesInput>
  }

  export type RoutineExecutionCreateWithoutRoutineInput = {
    id?: string
    status?: string
    summary?: string | null
    results?: NullableJsonNullValueInput | InputJsonValue
    duration?: number | null
    error?: string | null
    createdAt?: Date | string
  }

  export type RoutineExecutionUncheckedCreateWithoutRoutineInput = {
    id?: string
    status?: string
    summary?: string | null
    results?: NullableJsonNullValueInput | InputJsonValue
    duration?: number | null
    error?: string | null
    createdAt?: Date | string
  }

  export type RoutineExecutionCreateOrConnectWithoutRoutineInput = {
    where: RoutineExecutionWhereUniqueInput
    create: XOR<RoutineExecutionCreateWithoutRoutineInput, RoutineExecutionUncheckedCreateWithoutRoutineInput>
  }

  export type RoutineExecutionCreateManyRoutineInputEnvelope = {
    data: RoutineExecutionCreateManyRoutineInput | RoutineExecutionCreateManyRoutineInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutRoutinesInput = {
    update: XOR<UserUpdateWithoutRoutinesInput, UserUncheckedUpdateWithoutRoutinesInput>
    create: XOR<UserCreateWithoutRoutinesInput, UserUncheckedCreateWithoutRoutinesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRoutinesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRoutinesInput, UserUncheckedUpdateWithoutRoutinesInput>
  }

  export type UserUpdateWithoutRoutinesInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    clerkId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobs?: JobUpdateManyWithoutUserNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    usageTracking?: UsageTrackingUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    autoApplications?: AutoApplicationUpdateManyWithoutUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    goals?: GoalUpdateManyWithoutUserNestedInput
    gmailConnection?: GmailConnectionUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRoutinesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    clerkId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobs?: JobUncheckedUpdateManyWithoutUserNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    usageTracking?: UsageTrackingUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    autoApplications?: AutoApplicationUncheckedUpdateManyWithoutUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    goals?: GoalUncheckedUpdateManyWithoutUserNestedInput
    gmailConnection?: GmailConnectionUncheckedUpdateOneWithoutUserNestedInput
  }

  export type RoutineExecutionUpsertWithWhereUniqueWithoutRoutineInput = {
    where: RoutineExecutionWhereUniqueInput
    update: XOR<RoutineExecutionUpdateWithoutRoutineInput, RoutineExecutionUncheckedUpdateWithoutRoutineInput>
    create: XOR<RoutineExecutionCreateWithoutRoutineInput, RoutineExecutionUncheckedCreateWithoutRoutineInput>
  }

  export type RoutineExecutionUpdateWithWhereUniqueWithoutRoutineInput = {
    where: RoutineExecutionWhereUniqueInput
    data: XOR<RoutineExecutionUpdateWithoutRoutineInput, RoutineExecutionUncheckedUpdateWithoutRoutineInput>
  }

  export type RoutineExecutionUpdateManyWithWhereWithoutRoutineInput = {
    where: RoutineExecutionScalarWhereInput
    data: XOR<RoutineExecutionUpdateManyMutationInput, RoutineExecutionUncheckedUpdateManyWithoutRoutineInput>
  }

  export type RoutineExecutionScalarWhereInput = {
    AND?: RoutineExecutionScalarWhereInput | RoutineExecutionScalarWhereInput[]
    OR?: RoutineExecutionScalarWhereInput[]
    NOT?: RoutineExecutionScalarWhereInput | RoutineExecutionScalarWhereInput[]
    id?: StringFilter<"RoutineExecution"> | string
    routineId?: StringFilter<"RoutineExecution"> | string
    status?: StringFilter<"RoutineExecution"> | string
    summary?: StringNullableFilter<"RoutineExecution"> | string | null
    results?: JsonNullableFilter<"RoutineExecution">
    duration?: IntNullableFilter<"RoutineExecution"> | number | null
    error?: StringNullableFilter<"RoutineExecution"> | string | null
    createdAt?: DateTimeFilter<"RoutineExecution"> | Date | string
  }

  export type RoutineCreateWithoutExecutionsInput = {
    id?: string
    title: string
    description?: string | null
    type?: $Enums.RoutineType
    frequency?: string
    schedule?: string
    config?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    lastRun?: Date | string | null
    nextRun?: Date | string | null
    runCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutRoutinesInput
  }

  export type RoutineUncheckedCreateWithoutExecutionsInput = {
    id?: string
    userId: number
    title: string
    description?: string | null
    type?: $Enums.RoutineType
    frequency?: string
    schedule?: string
    config?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    lastRun?: Date | string | null
    nextRun?: Date | string | null
    runCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoutineCreateOrConnectWithoutExecutionsInput = {
    where: RoutineWhereUniqueInput
    create: XOR<RoutineCreateWithoutExecutionsInput, RoutineUncheckedCreateWithoutExecutionsInput>
  }

  export type RoutineUpsertWithoutExecutionsInput = {
    update: XOR<RoutineUpdateWithoutExecutionsInput, RoutineUncheckedUpdateWithoutExecutionsInput>
    create: XOR<RoutineCreateWithoutExecutionsInput, RoutineUncheckedCreateWithoutExecutionsInput>
    where?: RoutineWhereInput
  }

  export type RoutineUpdateToOneWithWhereWithoutExecutionsInput = {
    where?: RoutineWhereInput
    data: XOR<RoutineUpdateWithoutExecutionsInput, RoutineUncheckedUpdateWithoutExecutionsInput>
  }

  export type RoutineUpdateWithoutExecutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumRoutineTypeFieldUpdateOperationsInput | $Enums.RoutineType
    frequency?: StringFieldUpdateOperationsInput | string
    schedule?: StringFieldUpdateOperationsInput | string
    config?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastRun?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRun?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    runCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRoutinesNestedInput
  }

  export type RoutineUncheckedUpdateWithoutExecutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumRoutineTypeFieldUpdateOperationsInput | $Enums.RoutineType
    frequency?: StringFieldUpdateOperationsInput | string
    schedule?: StringFieldUpdateOperationsInput | string
    config?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastRun?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRun?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    runCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkerSessionCreateWithoutWorkerInput = {
    id?: string
    status?: $Enums.WorkerSessionStatus
    browserSessionId?: string | null
    vncUrl?: string | null
    queuedAt?: Date | string
    assignedAt?: Date | string | null
    aiStartedAt?: Date | string | null
    aiCompletedAt?: Date | string | null
    submittedAt?: Date | string | null
    completedAt?: Date | string | null
    formData?: NullableJsonNullValueInput | InputJsonValue
    screenshotUrl?: string | null
    workerNotes?: string | null
    failReason?: string | null
    skipReason?: string | null
    autoApplication: AutoApplicationCreateNestedOneWithoutWorkerSessionInput
  }

  export type WorkerSessionUncheckedCreateWithoutWorkerInput = {
    id?: string
    autoApplicationId: string
    status?: $Enums.WorkerSessionStatus
    browserSessionId?: string | null
    vncUrl?: string | null
    queuedAt?: Date | string
    assignedAt?: Date | string | null
    aiStartedAt?: Date | string | null
    aiCompletedAt?: Date | string | null
    submittedAt?: Date | string | null
    completedAt?: Date | string | null
    formData?: NullableJsonNullValueInput | InputJsonValue
    screenshotUrl?: string | null
    workerNotes?: string | null
    failReason?: string | null
    skipReason?: string | null
  }

  export type WorkerSessionCreateOrConnectWithoutWorkerInput = {
    where: WorkerSessionWhereUniqueInput
    create: XOR<WorkerSessionCreateWithoutWorkerInput, WorkerSessionUncheckedCreateWithoutWorkerInput>
  }

  export type WorkerSessionCreateManyWorkerInputEnvelope = {
    data: WorkerSessionCreateManyWorkerInput | WorkerSessionCreateManyWorkerInput[]
    skipDuplicates?: boolean
  }

  export type WorkerSessionUpsertWithWhereUniqueWithoutWorkerInput = {
    where: WorkerSessionWhereUniqueInput
    update: XOR<WorkerSessionUpdateWithoutWorkerInput, WorkerSessionUncheckedUpdateWithoutWorkerInput>
    create: XOR<WorkerSessionCreateWithoutWorkerInput, WorkerSessionUncheckedCreateWithoutWorkerInput>
  }

  export type WorkerSessionUpdateWithWhereUniqueWithoutWorkerInput = {
    where: WorkerSessionWhereUniqueInput
    data: XOR<WorkerSessionUpdateWithoutWorkerInput, WorkerSessionUncheckedUpdateWithoutWorkerInput>
  }

  export type WorkerSessionUpdateManyWithWhereWithoutWorkerInput = {
    where: WorkerSessionScalarWhereInput
    data: XOR<WorkerSessionUpdateManyMutationInput, WorkerSessionUncheckedUpdateManyWithoutWorkerInput>
  }

  export type WorkerSessionScalarWhereInput = {
    AND?: WorkerSessionScalarWhereInput | WorkerSessionScalarWhereInput[]
    OR?: WorkerSessionScalarWhereInput[]
    NOT?: WorkerSessionScalarWhereInput | WorkerSessionScalarWhereInput[]
    id?: StringFilter<"WorkerSession"> | string
    workerId?: IntNullableFilter<"WorkerSession"> | number | null
    autoApplicationId?: StringFilter<"WorkerSession"> | string
    status?: EnumWorkerSessionStatusFilter<"WorkerSession"> | $Enums.WorkerSessionStatus
    browserSessionId?: StringNullableFilter<"WorkerSession"> | string | null
    vncUrl?: StringNullableFilter<"WorkerSession"> | string | null
    queuedAt?: DateTimeFilter<"WorkerSession"> | Date | string
    assignedAt?: DateTimeNullableFilter<"WorkerSession"> | Date | string | null
    aiStartedAt?: DateTimeNullableFilter<"WorkerSession"> | Date | string | null
    aiCompletedAt?: DateTimeNullableFilter<"WorkerSession"> | Date | string | null
    submittedAt?: DateTimeNullableFilter<"WorkerSession"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"WorkerSession"> | Date | string | null
    formData?: JsonNullableFilter<"WorkerSession">
    screenshotUrl?: StringNullableFilter<"WorkerSession"> | string | null
    workerNotes?: StringNullableFilter<"WorkerSession"> | string | null
    failReason?: StringNullableFilter<"WorkerSession"> | string | null
    skipReason?: StringNullableFilter<"WorkerSession"> | string | null
  }

  export type WorkerCreateWithoutSessionsInput = {
    email: string
    password: string
    name: string
    isActive?: boolean
    role?: $Enums.WorkerRole
    totalCompleted?: number
    totalFailed?: number
    totalSkipped?: number
    avgTimeSeconds?: number | null
    lastActiveAt?: Date | string | null
    currentSessionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkerUncheckedCreateWithoutSessionsInput = {
    id?: number
    email: string
    password: string
    name: string
    isActive?: boolean
    role?: $Enums.WorkerRole
    totalCompleted?: number
    totalFailed?: number
    totalSkipped?: number
    avgTimeSeconds?: number | null
    lastActiveAt?: Date | string | null
    currentSessionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkerCreateOrConnectWithoutSessionsInput = {
    where: WorkerWhereUniqueInput
    create: XOR<WorkerCreateWithoutSessionsInput, WorkerUncheckedCreateWithoutSessionsInput>
  }

  export type AutoApplicationCreateWithoutWorkerSessionInput = {
    id?: string
    status?: $Enums.AutoApplicationStatus
    method?: string
    submittedAt?: Date | string | null
    confirmationUrl?: string | null
    confirmationId?: string | null
    confirmationData?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    errorType?: string | null
    retryCount?: number
    maxRetries?: number
    cost?: number
    createdAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    user: UserCreateNestedOneWithoutAutoApplicationsInput
    job: AggregatedJobCreateNestedOneWithoutApplicationsInput
  }

  export type AutoApplicationUncheckedCreateWithoutWorkerSessionInput = {
    id?: string
    userId: number
    jobId: string
    status?: $Enums.AutoApplicationStatus
    method?: string
    submittedAt?: Date | string | null
    confirmationUrl?: string | null
    confirmationId?: string | null
    confirmationData?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    errorType?: string | null
    retryCount?: number
    maxRetries?: number
    cost?: number
    createdAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
  }

  export type AutoApplicationCreateOrConnectWithoutWorkerSessionInput = {
    where: AutoApplicationWhereUniqueInput
    create: XOR<AutoApplicationCreateWithoutWorkerSessionInput, AutoApplicationUncheckedCreateWithoutWorkerSessionInput>
  }

  export type WorkerUpsertWithoutSessionsInput = {
    update: XOR<WorkerUpdateWithoutSessionsInput, WorkerUncheckedUpdateWithoutSessionsInput>
    create: XOR<WorkerCreateWithoutSessionsInput, WorkerUncheckedCreateWithoutSessionsInput>
    where?: WorkerWhereInput
  }

  export type WorkerUpdateToOneWithWhereWithoutSessionsInput = {
    where?: WorkerWhereInput
    data: XOR<WorkerUpdateWithoutSessionsInput, WorkerUncheckedUpdateWithoutSessionsInput>
  }

  export type WorkerUpdateWithoutSessionsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumWorkerRoleFieldUpdateOperationsInput | $Enums.WorkerRole
    totalCompleted?: IntFieldUpdateOperationsInput | number
    totalFailed?: IntFieldUpdateOperationsInput | number
    totalSkipped?: IntFieldUpdateOperationsInput | number
    avgTimeSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkerUncheckedUpdateWithoutSessionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumWorkerRoleFieldUpdateOperationsInput | $Enums.WorkerRole
    totalCompleted?: IntFieldUpdateOperationsInput | number
    totalFailed?: IntFieldUpdateOperationsInput | number
    totalSkipped?: IntFieldUpdateOperationsInput | number
    avgTimeSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutoApplicationUpsertWithoutWorkerSessionInput = {
    update: XOR<AutoApplicationUpdateWithoutWorkerSessionInput, AutoApplicationUncheckedUpdateWithoutWorkerSessionInput>
    create: XOR<AutoApplicationCreateWithoutWorkerSessionInput, AutoApplicationUncheckedCreateWithoutWorkerSessionInput>
    where?: AutoApplicationWhereInput
  }

  export type AutoApplicationUpdateToOneWithWhereWithoutWorkerSessionInput = {
    where?: AutoApplicationWhereInput
    data: XOR<AutoApplicationUpdateWithoutWorkerSessionInput, AutoApplicationUncheckedUpdateWithoutWorkerSessionInput>
  }

  export type AutoApplicationUpdateWithoutWorkerSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumAutoApplicationStatusFieldUpdateOperationsInput | $Enums.AutoApplicationStatus
    method?: StringFieldUpdateOperationsInput | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    confirmationId?: NullableStringFieldUpdateOperationsInput | string | null
    confirmationData?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    errorType?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    maxRetries?: IntFieldUpdateOperationsInput | number
    cost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutAutoApplicationsNestedInput
    job?: AggregatedJobUpdateOneRequiredWithoutApplicationsNestedInput
  }

  export type AutoApplicationUncheckedUpdateWithoutWorkerSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    jobId?: StringFieldUpdateOperationsInput | string
    status?: EnumAutoApplicationStatusFieldUpdateOperationsInput | $Enums.AutoApplicationStatus
    method?: StringFieldUpdateOperationsInput | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    confirmationId?: NullableStringFieldUpdateOperationsInput | string | null
    confirmationData?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    errorType?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    maxRetries?: IntFieldUpdateOperationsInput | number
    cost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type JobCreateManyUserInput = {
    id?: string
    status?: $Enums.JobStatus
    priority?: number
    attempts?: number
    maxAttempts?: number
    resumeText?: string | null
    jobDescription: string
    aiMode?: string | null
    matchMode?: string | null
    error?: string | null
    diagnostics?: NullableJsonNullValueInput | InputJsonValue
    processingLog?: JobCreateprocessingLogInput | InputJsonValue[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    company?: string | null
    jobUrl?: string | null
    role?: string | null
  }

  export type UsageTrackingCreateManyUserInput = {
    id?: string
    date?: Date | string
    resumesGenerated?: number
    dailyLimit: number
    tier: $Enums.SubscriptionTier
    resetAt: Date | string
  }

  export type PaymentCreateManyUserInput = {
    id?: string
    stripePaymentId: string
    amount: number
    currency?: string
    status: $Enums.PaymentStatus
    description?: string | null
    createdAt?: Date | string
  }

  export type AutoApplicationCreateManyUserInput = {
    id?: string
    jobId: string
    status?: $Enums.AutoApplicationStatus
    method?: string
    submittedAt?: Date | string | null
    confirmationUrl?: string | null
    confirmationId?: string | null
    confirmationData?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    errorType?: string | null
    retryCount?: number
    maxRetries?: number
    cost?: number
    createdAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
  }

  export type ConversationCreateManyUserInput = {
    id?: string
    title?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastMessageAt?: Date | string
  }

  export type GoalCreateManyUserInput = {
    id?: string
    conversationId?: string | null
    title: string
    description?: string | null
    type?: $Enums.GoalType
    status?: $Enums.GoalStatus
    targetDate?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type RoutineCreateManyUserInput = {
    id?: string
    title: string
    description?: string | null
    type?: $Enums.RoutineType
    frequency?: string
    schedule?: string
    config?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    lastRun?: Date | string | null
    nextRun?: Date | string | null
    runCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    priority?: IntFieldUpdateOperationsInput | number
    attempts?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    resumeText?: NullableStringFieldUpdateOperationsInput | string | null
    jobDescription?: StringFieldUpdateOperationsInput | string
    aiMode?: NullableStringFieldUpdateOperationsInput | string | null
    matchMode?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    diagnostics?: NullableJsonNullValueInput | InputJsonValue
    processingLog?: JobUpdateprocessingLogInput | InputJsonValue[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    jobUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    artifacts?: ArtifactUpdateManyWithoutJobNestedInput
    embeddings?: EmbeddingUpdateManyWithoutJobNestedInput
  }

  export type JobUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    priority?: IntFieldUpdateOperationsInput | number
    attempts?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    resumeText?: NullableStringFieldUpdateOperationsInput | string | null
    jobDescription?: StringFieldUpdateOperationsInput | string
    aiMode?: NullableStringFieldUpdateOperationsInput | string | null
    matchMode?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    diagnostics?: NullableJsonNullValueInput | InputJsonValue
    processingLog?: JobUpdateprocessingLogInput | InputJsonValue[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    jobUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    artifacts?: ArtifactUncheckedUpdateManyWithoutJobNestedInput
    embeddings?: EmbeddingUncheckedUpdateManyWithoutJobNestedInput
  }

  export type JobUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    priority?: IntFieldUpdateOperationsInput | number
    attempts?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    resumeText?: NullableStringFieldUpdateOperationsInput | string | null
    jobDescription?: StringFieldUpdateOperationsInput | string
    aiMode?: NullableStringFieldUpdateOperationsInput | string | null
    matchMode?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    diagnostics?: NullableJsonNullValueInput | InputJsonValue
    processingLog?: JobUpdateprocessingLogInput | InputJsonValue[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    jobUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UsageTrackingUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    resumesGenerated?: IntFieldUpdateOperationsInput | number
    dailyLimit?: IntFieldUpdateOperationsInput | number
    tier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    resetAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageTrackingUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    resumesGenerated?: IntFieldUpdateOperationsInput | number
    dailyLimit?: IntFieldUpdateOperationsInput | number
    tier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    resetAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageTrackingUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    resumesGenerated?: IntFieldUpdateOperationsInput | number
    dailyLimit?: IntFieldUpdateOperationsInput | number
    tier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    resetAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripePaymentId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripePaymentId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripePaymentId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutoApplicationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumAutoApplicationStatusFieldUpdateOperationsInput | $Enums.AutoApplicationStatus
    method?: StringFieldUpdateOperationsInput | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    confirmationId?: NullableStringFieldUpdateOperationsInput | string | null
    confirmationData?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    errorType?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    maxRetries?: IntFieldUpdateOperationsInput | number
    cost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    job?: AggregatedJobUpdateOneRequiredWithoutApplicationsNestedInput
    workerSession?: WorkerSessionUpdateOneWithoutAutoApplicationNestedInput
  }

  export type AutoApplicationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    status?: EnumAutoApplicationStatusFieldUpdateOperationsInput | $Enums.AutoApplicationStatus
    method?: StringFieldUpdateOperationsInput | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    confirmationId?: NullableStringFieldUpdateOperationsInput | string | null
    confirmationData?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    errorType?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    maxRetries?: IntFieldUpdateOperationsInput | number
    cost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workerSession?: WorkerSessionUncheckedUpdateOneWithoutAutoApplicationNestedInput
  }

  export type AutoApplicationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    status?: EnumAutoApplicationStatusFieldUpdateOperationsInput | $Enums.AutoApplicationStatus
    method?: StringFieldUpdateOperationsInput | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    confirmationId?: NullableStringFieldUpdateOperationsInput | string | null
    confirmationData?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    errorType?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    maxRetries?: IntFieldUpdateOperationsInput | number
    cost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ConversationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMessageAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUpdateManyWithoutConversationNestedInput
    goals?: GoalUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMessageAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
    goals?: GoalUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMessageAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GoalUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumGoalTypeFieldUpdateOperationsInput | $Enums.GoalType
    status?: EnumGoalStatusFieldUpdateOperationsInput | $Enums.GoalStatus
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    conversation?: ConversationUpdateOneWithoutGoalsNestedInput
  }

  export type GoalUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumGoalTypeFieldUpdateOperationsInput | $Enums.GoalType
    status?: EnumGoalStatusFieldUpdateOperationsInput | $Enums.GoalStatus
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type GoalUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumGoalTypeFieldUpdateOperationsInput | $Enums.GoalType
    status?: EnumGoalStatusFieldUpdateOperationsInput | $Enums.GoalStatus
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type RoutineUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumRoutineTypeFieldUpdateOperationsInput | $Enums.RoutineType
    frequency?: StringFieldUpdateOperationsInput | string
    schedule?: StringFieldUpdateOperationsInput | string
    config?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastRun?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRun?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    runCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executions?: RoutineExecutionUpdateManyWithoutRoutineNestedInput
  }

  export type RoutineUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumRoutineTypeFieldUpdateOperationsInput | $Enums.RoutineType
    frequency?: StringFieldUpdateOperationsInput | string
    schedule?: StringFieldUpdateOperationsInput | string
    config?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastRun?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRun?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    runCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executions?: RoutineExecutionUncheckedUpdateManyWithoutRoutineNestedInput
  }

  export type RoutineUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumRoutineTypeFieldUpdateOperationsInput | $Enums.RoutineType
    frequency?: StringFieldUpdateOperationsInput | string
    schedule?: StringFieldUpdateOperationsInput | string
    config?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastRun?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRun?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    runCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArtifactCreateManyJobInput = {
    id?: string
    type: $Enums.ArtifactType
    version?: number
    content: Buffer
    metadata?: NullableJsonNullValueInput | InputJsonValue
    schema?: NullableJsonNullValueInput | InputJsonValue
    validated?: boolean
    createdAt?: Date | string
  }

  export type EmbeddingCreateManyJobInput = {
    id?: string
    content: string
    contentType: $Enums.EmbeddingType
    embedding?: EmbeddingCreateembeddingInput | number[]
    relevance?: number | null
    createdAt?: Date | string
  }

  export type ArtifactUpdateWithoutJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumArtifactTypeFieldUpdateOperationsInput | $Enums.ArtifactType
    version?: IntFieldUpdateOperationsInput | number
    content?: BytesFieldUpdateOperationsInput | Buffer
    metadata?: NullableJsonNullValueInput | InputJsonValue
    schema?: NullableJsonNullValueInput | InputJsonValue
    validated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArtifactUncheckedUpdateWithoutJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumArtifactTypeFieldUpdateOperationsInput | $Enums.ArtifactType
    version?: IntFieldUpdateOperationsInput | number
    content?: BytesFieldUpdateOperationsInput | Buffer
    metadata?: NullableJsonNullValueInput | InputJsonValue
    schema?: NullableJsonNullValueInput | InputJsonValue
    validated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArtifactUncheckedUpdateManyWithoutJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumArtifactTypeFieldUpdateOperationsInput | $Enums.ArtifactType
    version?: IntFieldUpdateOperationsInput | number
    content?: BytesFieldUpdateOperationsInput | Buffer
    metadata?: NullableJsonNullValueInput | InputJsonValue
    schema?: NullableJsonNullValueInput | InputJsonValue
    validated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmbeddingUpdateWithoutJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    contentType?: EnumEmbeddingTypeFieldUpdateOperationsInput | $Enums.EmbeddingType
    embedding?: EmbeddingUpdateembeddingInput | number[]
    relevance?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmbeddingUncheckedUpdateWithoutJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    contentType?: EnumEmbeddingTypeFieldUpdateOperationsInput | $Enums.EmbeddingType
    embedding?: EmbeddingUpdateembeddingInput | number[]
    relevance?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmbeddingUncheckedUpdateManyWithoutJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    contentType?: EnumEmbeddingTypeFieldUpdateOperationsInput | $Enums.EmbeddingType
    embedding?: EmbeddingUpdateembeddingInput | number[]
    relevance?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutoApplicationCreateManyJobInput = {
    id?: string
    userId: number
    status?: $Enums.AutoApplicationStatus
    method?: string
    submittedAt?: Date | string | null
    confirmationUrl?: string | null
    confirmationId?: string | null
    confirmationData?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    errorType?: string | null
    retryCount?: number
    maxRetries?: number
    cost?: number
    createdAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
  }

  export type AutoApplicationUpdateWithoutJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumAutoApplicationStatusFieldUpdateOperationsInput | $Enums.AutoApplicationStatus
    method?: StringFieldUpdateOperationsInput | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    confirmationId?: NullableStringFieldUpdateOperationsInput | string | null
    confirmationData?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    errorType?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    maxRetries?: IntFieldUpdateOperationsInput | number
    cost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutAutoApplicationsNestedInput
    workerSession?: WorkerSessionUpdateOneWithoutAutoApplicationNestedInput
  }

  export type AutoApplicationUncheckedUpdateWithoutJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    status?: EnumAutoApplicationStatusFieldUpdateOperationsInput | $Enums.AutoApplicationStatus
    method?: StringFieldUpdateOperationsInput | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    confirmationId?: NullableStringFieldUpdateOperationsInput | string | null
    confirmationData?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    errorType?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    maxRetries?: IntFieldUpdateOperationsInput | number
    cost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workerSession?: WorkerSessionUncheckedUpdateOneWithoutAutoApplicationNestedInput
  }

  export type AutoApplicationUncheckedUpdateManyWithoutJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    status?: EnumAutoApplicationStatusFieldUpdateOperationsInput | $Enums.AutoApplicationStatus
    method?: StringFieldUpdateOperationsInput | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    confirmationId?: NullableStringFieldUpdateOperationsInput | string | null
    confirmationData?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    errorType?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    maxRetries?: IntFieldUpdateOperationsInput | number
    cost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RecipeExecutionCreateManyRecipeInput = {
    id?: string
    success: boolean
    method: string
    duration?: number | null
    cost: number
    error?: string | null
    errorType?: string | null
    jobUrl?: string | null
    executedAt?: Date | string
  }

  export type RecipeExecutionUpdateWithoutRecipeInput = {
    id?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    method?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    cost?: FloatFieldUpdateOperationsInput | number
    error?: NullableStringFieldUpdateOperationsInput | string | null
    errorType?: NullableStringFieldUpdateOperationsInput | string | null
    jobUrl?: NullableStringFieldUpdateOperationsInput | string | null
    executedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecipeExecutionUncheckedUpdateWithoutRecipeInput = {
    id?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    method?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    cost?: FloatFieldUpdateOperationsInput | number
    error?: NullableStringFieldUpdateOperationsInput | string | null
    errorType?: NullableStringFieldUpdateOperationsInput | string | null
    jobUrl?: NullableStringFieldUpdateOperationsInput | string | null
    executedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecipeExecutionUncheckedUpdateManyWithoutRecipeInput = {
    id?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    method?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    cost?: FloatFieldUpdateOperationsInput | number
    error?: NullableStringFieldUpdateOperationsInput | string | null
    errorType?: NullableStringFieldUpdateOperationsInput | string | null
    jobUrl?: NullableStringFieldUpdateOperationsInput | string | null
    executedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateManyConversationInput = {
    id?: string
    role: $Enums.MessageRole
    content: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tokenCount?: number | null
    cost?: number | null
    createdAt?: Date | string
  }

  export type GoalCreateManyConversationInput = {
    id?: string
    userId: number
    title: string
    description?: string | null
    type?: $Enums.GoalType
    status?: $Enums.GoalStatus
    targetDate?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MessageUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumMessageRoleFieldUpdateOperationsInput | $Enums.MessageRole
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tokenCount?: NullableIntFieldUpdateOperationsInput | number | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumMessageRoleFieldUpdateOperationsInput | $Enums.MessageRole
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tokenCount?: NullableIntFieldUpdateOperationsInput | number | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumMessageRoleFieldUpdateOperationsInput | $Enums.MessageRole
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tokenCount?: NullableIntFieldUpdateOperationsInput | number | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GoalUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumGoalTypeFieldUpdateOperationsInput | $Enums.GoalType
    status?: EnumGoalStatusFieldUpdateOperationsInput | $Enums.GoalStatus
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutGoalsNestedInput
  }

  export type GoalUncheckedUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumGoalTypeFieldUpdateOperationsInput | $Enums.GoalType
    status?: EnumGoalStatusFieldUpdateOperationsInput | $Enums.GoalStatus
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type GoalUncheckedUpdateManyWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumGoalTypeFieldUpdateOperationsInput | $Enums.GoalType
    status?: EnumGoalStatusFieldUpdateOperationsInput | $Enums.GoalStatus
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type RoutineExecutionCreateManyRoutineInput = {
    id?: string
    status?: string
    summary?: string | null
    results?: NullableJsonNullValueInput | InputJsonValue
    duration?: number | null
    error?: string | null
    createdAt?: Date | string
  }

  export type RoutineExecutionUpdateWithoutRoutineInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    results?: NullableJsonNullValueInput | InputJsonValue
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoutineExecutionUncheckedUpdateWithoutRoutineInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    results?: NullableJsonNullValueInput | InputJsonValue
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoutineExecutionUncheckedUpdateManyWithoutRoutineInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    results?: NullableJsonNullValueInput | InputJsonValue
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkerSessionCreateManyWorkerInput = {
    id?: string
    autoApplicationId: string
    status?: $Enums.WorkerSessionStatus
    browserSessionId?: string | null
    vncUrl?: string | null
    queuedAt?: Date | string
    assignedAt?: Date | string | null
    aiStartedAt?: Date | string | null
    aiCompletedAt?: Date | string | null
    submittedAt?: Date | string | null
    completedAt?: Date | string | null
    formData?: NullableJsonNullValueInput | InputJsonValue
    screenshotUrl?: string | null
    workerNotes?: string | null
    failReason?: string | null
    skipReason?: string | null
  }

  export type WorkerSessionUpdateWithoutWorkerInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumWorkerSessionStatusFieldUpdateOperationsInput | $Enums.WorkerSessionStatus
    browserSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    vncUrl?: NullableStringFieldUpdateOperationsInput | string | null
    queuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    formData?: NullableJsonNullValueInput | InputJsonValue
    screenshotUrl?: NullableStringFieldUpdateOperationsInput | string | null
    workerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    failReason?: NullableStringFieldUpdateOperationsInput | string | null
    skipReason?: NullableStringFieldUpdateOperationsInput | string | null
    autoApplication?: AutoApplicationUpdateOneRequiredWithoutWorkerSessionNestedInput
  }

  export type WorkerSessionUncheckedUpdateWithoutWorkerInput = {
    id?: StringFieldUpdateOperationsInput | string
    autoApplicationId?: StringFieldUpdateOperationsInput | string
    status?: EnumWorkerSessionStatusFieldUpdateOperationsInput | $Enums.WorkerSessionStatus
    browserSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    vncUrl?: NullableStringFieldUpdateOperationsInput | string | null
    queuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    formData?: NullableJsonNullValueInput | InputJsonValue
    screenshotUrl?: NullableStringFieldUpdateOperationsInput | string | null
    workerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    failReason?: NullableStringFieldUpdateOperationsInput | string | null
    skipReason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkerSessionUncheckedUpdateManyWithoutWorkerInput = {
    id?: StringFieldUpdateOperationsInput | string
    autoApplicationId?: StringFieldUpdateOperationsInput | string
    status?: EnumWorkerSessionStatusFieldUpdateOperationsInput | $Enums.WorkerSessionStatus
    browserSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    vncUrl?: NullableStringFieldUpdateOperationsInput | string | null
    queuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aiCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    formData?: NullableJsonNullValueInput | InputJsonValue
    screenshotUrl?: NullableStringFieldUpdateOperationsInput | string | null
    workerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    failReason?: NullableStringFieldUpdateOperationsInput | string | null
    skipReason?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use JobCountOutputTypeDefaultArgs instead
     */
    export type JobCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = JobCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AggregatedJobCountOutputTypeDefaultArgs instead
     */
    export type AggregatedJobCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AggregatedJobCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ApplicationRecipeCountOutputTypeDefaultArgs instead
     */
    export type ApplicationRecipeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ApplicationRecipeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConversationCountOutputTypeDefaultArgs instead
     */
    export type ConversationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConversationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoutineCountOutputTypeDefaultArgs instead
     */
    export type RoutineCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoutineCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkerCountOutputTypeDefaultArgs instead
     */
    export type WorkerCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkerCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GmailConnectionDefaultArgs instead
     */
    export type GmailConnectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GmailConnectionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProfileDefaultArgs instead
     */
    export type ProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProfileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use JobDefaultArgs instead
     */
    export type JobArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = JobDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ArtifactDefaultArgs instead
     */
    export type ArtifactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ArtifactDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmbeddingDefaultArgs instead
     */
    export type EmbeddingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmbeddingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubscriptionDefaultArgs instead
     */
    export type SubscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubscriptionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsageTrackingDefaultArgs instead
     */
    export type UsageTrackingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsageTrackingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PaymentDefaultArgs instead
     */
    export type PaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PaymentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AggregatedJobDefaultArgs instead
     */
    export type AggregatedJobArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AggregatedJobDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AutoApplicationDefaultArgs instead
     */
    export type AutoApplicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AutoApplicationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ApplicationRecipeDefaultArgs instead
     */
    export type ApplicationRecipeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ApplicationRecipeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RecipeExecutionDefaultArgs instead
     */
    export type RecipeExecutionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RecipeExecutionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DiscoveredCompanyDefaultArgs instead
     */
    export type DiscoveredCompanyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DiscoveredCompanyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConversationDefaultArgs instead
     */
    export type ConversationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConversationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MessageDefaultArgs instead
     */
    export type MessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MessageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GoalDefaultArgs instead
     */
    export type GoalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GoalDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MessageUsageDefaultArgs instead
     */
    export type MessageUsageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MessageUsageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoutineDefaultArgs instead
     */
    export type RoutineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoutineDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoutineExecutionDefaultArgs instead
     */
    export type RoutineExecutionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoutineExecutionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkerDefaultArgs instead
     */
    export type WorkerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkerSessionDefaultArgs instead
     */
    export type WorkerSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkerSessionDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}