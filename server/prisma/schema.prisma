generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id              Int               @id @default(autoincrement())
  email           String            @unique
  password        String
  clerkId         String?           @unique
  createdAt       DateTime          @default(now())
  jobs            Job[]
  profile         Profile?
  subscription    Subscription?
  usageTracking   UsageTracking[]
  payments        Payment[]
  autoApplications AutoApplication[]
}

model Profile {
  id        Int      @id @default(autoincrement())
  userId    Int      @unique
  data      Json
  updatedAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id])
}

model Job {
  id             String      @id @default(cuid())
  userId         Int?
  status         JobStatus   @default(PENDING)
  priority       Int         @default(0)
  attempts       Int         @default(0)
  maxAttempts    Int         @default(3)
  resumeText     String?     @default("")
  jobDescription String
  aiMode         String?
  matchMode      String?
  error          String?
  diagnostics    Json?
  processingLog  Json[]
  createdAt      DateTime    @default(now())
  updatedAt      DateTime    @updatedAt
  startedAt      DateTime?
  completedAt    DateTime?
  company        String?
  jobUrl         String?
  role           String?
  artifacts      Artifact[]
  embeddings     Embedding[]
  user           User?       @relation(fields: [userId], references: [id])

  @@index([status, priority, createdAt])
  @@index([userId])
}

model Artifact {
  id        String       @id @default(cuid())
  jobId     String
  type      ArtifactType
  version   Int          @default(1)
  content   Bytes
  metadata  Json?
  schema    Json?
  validated Boolean      @default(false)
  createdAt DateTime     @default(now())
  job       Job          @relation(fields: [jobId], references: [id], onDelete: Cascade)

  @@unique([jobId, type, version])
  @@index([jobId, type])
}

model Embedding {
  id          String        @id @default(cuid())
  jobId       String
  content     String
  contentType EmbeddingType
  embedding   Float[]
  relevance   Float?
  createdAt   DateTime      @default(now())
  job         Job           @relation(fields: [jobId], references: [id], onDelete: Cascade)

  @@index([jobId, contentType])
}

enum JobStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  RETRYING
}

enum ArtifactType {
  RESUME_JSON
  LATEX_SOURCE
  PDF_OUTPUT
  JOB_DESCRIPTION
  DIAGNOSTIC_LOG
}

enum EmbeddingType {
  SKILL
  EXPERIENCE
  REQUIREMENT
  KEYWORD
}

model Subscription {
  id                   String             @id @default(cuid())
  userId               Int                @unique
  stripeCustomerId     String?            @unique
  stripeSubscriptionId String?            @unique
  tier                 SubscriptionTier   @default(FREE)
  status               SubscriptionStatus @default(ACTIVE)
  currentPeriodStart   DateTime?
  currentPeriodEnd     DateTime?
  cancelAtPeriodEnd    Boolean            @default(false)
  createdAt            DateTime           @default(now())
  updatedAt            DateTime           @updatedAt
  user                 User               @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([stripeCustomerId])
  @@index([stripeSubscriptionId])
}

model UsageTracking {
  id               String           @id @default(cuid())
  userId           Int
  date             DateTime         @default(now())
  resumesGenerated Int              @default(0)
  dailyLimit       Int
  tier             SubscriptionTier
  resetAt          DateTime
  user             User             @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, date])
  @@index([userId, date])
}

model Payment {
  id              String        @id @default(cuid())
  userId          Int
  stripePaymentId String        @unique
  amount          Int
  currency        String        @default("usd")
  status          PaymentStatus
  description     String?
  createdAt       DateTime      @default(now())
  user            User          @relation(fields: [userId], references: [id])

  @@index([userId])
  @@index([stripePaymentId])
}

enum SubscriptionTier {
  FREE
  PRO
  UNLIMITED
}

enum SubscriptionStatus {
  ACTIVE
  CANCELED
  PAST_DUE
  PAUSED
  INCOMPLETE
}

enum PaymentStatus {
  PENDING
  SUCCEEDED
  FAILED
  REFUNDED
}

// Auto-Apply System Models

model AggregatedJob {
  id                    String            @id @default(cuid())
  externalId            String            @unique
  source                String
  title                 String
  company               String
  location              String?
  salary                String?
  description           String
  requirements          String?
  applyUrl              String
  companyUrl            String?
  atsType               String
  atsCompany            String?
  atsComplexity         String
  atsConfidence         Float
  aiApplyable           Boolean           @default(false)
  extractedSkills       String[]          @default([])
  extractedExperience   String?
  extractedEducation    String?
  extractedJobLevel     String?
  extractedKeywords     String[]          @default([])
  extractedBenefits     String[]          @default([])
  lastExtractedAt       DateTime?
  extractionConfidence  Float?
  postedDate            DateTime
  expiresAt             DateTime?
  lastChecked           DateTime          @default(now())
  isActive              Boolean           @default(true)
  applications          AutoApplication[]

  @@index([aiApplyable, postedDate])
  @@index([atsType])
  @@index([isActive, postedDate])
  @@index([source])
  @@index([extractedSkills], type: Gin)
}

model AutoApplication {
  id                String                  @id @default(cuid())
  userId            Int
  jobId             String
  status            AutoApplicationStatus   @default(QUEUED)
  method            String                  @default("AI_AUTO")
  submittedAt       DateTime?
  confirmationUrl   String?
  confirmationId    String?
  confirmationData  Json?
  error             String?
  errorType         String?
  retryCount        Int                     @default(0)
  maxRetries        Int                     @default(3)
  cost              Float                   @default(0)
  createdAt         DateTime                @default(now())
  startedAt         DateTime?
  completedAt       DateTime?
  user              User                    @relation(fields: [userId], references: [id], onDelete: Cascade)
  job               AggregatedJob           @relation(fields: [jobId], references: [id], onDelete: Cascade)

  @@unique([userId, jobId])
  @@index([userId, status])
  @@index([status])
  @@index([createdAt])
}

model ApplicationRecipe {
  id             String             @id @default(cuid())
  platform       String             @unique
  atsType        String
  version        Int                @default(1)
  steps          Json
  successRate    Float              @default(1.0)
  timesUsed      Int                @default(0)
  failureCount   Int                @default(0)
  recordingCost  Float              @default(0.80)
  replayCost     Float              @default(0.05)
  totalSaved     Float              @default(0.0)
  createdAt      DateTime           @default(now())
  updatedAt      DateTime           @updatedAt
  lastUsed       DateTime?
  lastFailure    DateTime?
  recordedBy     String?
  executions     RecipeExecution[]

  @@index([platform])
  @@index([atsType])
  @@index([successRate])
}

model RecipeExecution {
  id          String            @id @default(cuid())
  recipeId    String
  success     Boolean
  method      String
  duration    Int?
  cost        Float
  error       String?
  errorType   String?
  jobUrl      String?
  executedAt  DateTime          @default(now())
  recipe      ApplicationRecipe @relation(fields: [recipeId], references: [id], onDelete: Cascade)

  @@index([recipeId, executedAt])
  @@index([success])
}

model DiscoveredCompany {
  id             String   @id @default(cuid())
  atsType        String
  slug           String
  name           String?
  discoveredAt   DateTime @default(now())
  discoveredFrom String?
  lastFetchedAt  DateTime
  isActive       Boolean  @default(true)
  totalJobs      Int      @default(0)
  lastJobCount   Int      @default(0)

  @@unique([atsType, slug])
  @@index([atsType, isActive])
  @@index([lastFetchedAt])
}

enum AutoApplicationStatus {
  QUEUED
  APPLYING
  SUBMITTED
  FAILED
  CANCELLED
  RETRYING
}
